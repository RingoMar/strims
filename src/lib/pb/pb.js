/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const Call = $root.Call = (() => {

    /**
     * Properties of a Call.
     * @exports ICall
     * @interface ICall
     * @property {number|null} [id] Call id
     * @property {number|null} [parentId] Call parentId
     * @property {string|null} [method] Call method
     * @property {google.protobuf.IAny|null} [argument] Call argument
     */

    /**
     * Constructs a new Call.
     * @exports Call
     * @classdesc Represents a Call.
     * @implements ICall
     * @constructor
     * @param {ICall=} [properties] Properties to set
     */
    function Call(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Call id.
     * @member {number} id
     * @memberof Call
     * @instance
     */
    Call.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Call parentId.
     * @member {number} parentId
     * @memberof Call
     * @instance
     */
    Call.prototype.parentId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Call method.
     * @member {string} method
     * @memberof Call
     * @instance
     */
    Call.prototype.method = "";

    /**
     * Call argument.
     * @member {google.protobuf.IAny|null|undefined} argument
     * @memberof Call
     * @instance
     */
    Call.prototype.argument = null;

    /**
     * Creates a new Call instance using the specified properties.
     * @function create
     * @memberof Call
     * @static
     * @param {ICall=} [properties] Properties to set
     * @returns {Call} Call instance
     */
    Call.create = function create(properties) {
        return new Call(properties);
    };

    /**
     * Encodes the specified Call message. Does not implicitly {@link Call.verify|verify} messages.
     * @function encode
     * @memberof Call
     * @static
     * @param {ICall} message Call message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Call.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.parentId);
        if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.method);
        if (message.argument != null && Object.hasOwnProperty.call(message, "argument"))
            $root.google.protobuf.Any.encode(message.argument, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Call message, length delimited. Does not implicitly {@link Call.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Call
     * @static
     * @param {ICall} message Call message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Call.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Call message from the specified reader or buffer.
     * @function decode
     * @memberof Call
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Call} Call
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Call.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Call();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.parentId = reader.uint64();
                break;
            case 3:
                message.method = reader.string();
                break;
            case 4:
                message.argument = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Call message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Call
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Call} Call
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Call.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Call message.
     * @function verify
     * @memberof Call
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Call.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.parentId != null && message.hasOwnProperty("parentId"))
            if (!$util.isInteger(message.parentId) && !(message.parentId && $util.isInteger(message.parentId.low) && $util.isInteger(message.parentId.high)))
                return "parentId: integer|Long expected";
        if (message.method != null && message.hasOwnProperty("method"))
            if (!$util.isString(message.method))
                return "method: string expected";
        if (message.argument != null && message.hasOwnProperty("argument")) {
            let error = $root.google.protobuf.Any.verify(message.argument);
            if (error)
                return "argument." + error;
        }
        return null;
    };

    /**
     * Creates a Call message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Call
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Call} Call
     */
    Call.fromObject = function fromObject(object) {
        if (object instanceof $root.Call)
            return object;
        let message = new $root.Call();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.parentId != null)
            if ($util.Long)
                (message.parentId = $util.Long.fromValue(object.parentId)).unsigned = true;
            else if (typeof object.parentId === "string")
                message.parentId = parseInt(object.parentId, 10);
            else if (typeof object.parentId === "number")
                message.parentId = object.parentId;
            else if (typeof object.parentId === "object")
                message.parentId = new $util.LongBits(object.parentId.low >>> 0, object.parentId.high >>> 0).toNumber(true);
        if (object.method != null)
            message.method = String(object.method);
        if (object.argument != null) {
            if (typeof object.argument !== "object")
                throw TypeError(".Call.argument: object expected");
            message.argument = $root.google.protobuf.Any.fromObject(object.argument);
        }
        return message;
    };

    /**
     * Creates a plain object from a Call message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Call
     * @static
     * @param {Call} message Call
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Call.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.parentId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.parentId = options.longs === String ? "0" : 0;
            object.method = "";
            object.argument = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.parentId != null && message.hasOwnProperty("parentId"))
            if (typeof message.parentId === "number")
                object.parentId = options.longs === String ? String(message.parentId) : message.parentId;
            else
                object.parentId = options.longs === String ? $util.Long.prototype.toString.call(message.parentId) : options.longs === Number ? new $util.LongBits(message.parentId.low >>> 0, message.parentId.high >>> 0).toNumber(true) : message.parentId;
        if (message.method != null && message.hasOwnProperty("method"))
            object.method = message.method;
        if (message.argument != null && message.hasOwnProperty("argument"))
            object.argument = $root.google.protobuf.Any.toObject(message.argument, options);
        return object;
    };

    /**
     * Converts this Call to JSON.
     * @function toJSON
     * @memberof Call
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Call.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Call;
})();

export const Error = $root.Error = (() => {

    /**
     * Properties of an Error.
     * @exports IError
     * @interface IError
     * @property {string|null} [message] Error message
     */

    /**
     * Constructs a new Error.
     * @exports Error
     * @classdesc Represents an Error.
     * @implements IError
     * @constructor
     * @param {IError=} [properties] Properties to set
     */
    function Error(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Error message.
     * @member {string} message
     * @memberof Error
     * @instance
     */
    Error.prototype.message = "";

    /**
     * Creates a new Error instance using the specified properties.
     * @function create
     * @memberof Error
     * @static
     * @param {IError=} [properties] Properties to set
     * @returns {Error} Error instance
     */
    Error.create = function create(properties) {
        return new Error(properties);
    };

    /**
     * Encodes the specified Error message. Does not implicitly {@link Error.verify|verify} messages.
     * @function encode
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified Error message, length delimited. Does not implicitly {@link Error.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Error message from the specified reader or buffer.
     * @function decode
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Error();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Error message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Error message.
     * @function verify
     * @memberof Error
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Error.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message))
                return "message: string expected";
        return null;
    };

    /**
     * Creates an Error message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Error
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Error} Error
     */
    Error.fromObject = function fromObject(object) {
        if (object instanceof $root.Error)
            return object;
        let message = new $root.Error();
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from an Error message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Error
     * @static
     * @param {Error} message Error
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Error.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.message = "";
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this Error to JSON.
     * @function toJSON
     * @memberof Error
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Error.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Error;
})();

export const Cancel = $root.Cancel = (() => {

    /**
     * Properties of a Cancel.
     * @exports ICancel
     * @interface ICancel
     */

    /**
     * Constructs a new Cancel.
     * @exports Cancel
     * @classdesc Represents a Cancel.
     * @implements ICancel
     * @constructor
     * @param {ICancel=} [properties] Properties to set
     */
    function Cancel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Cancel instance using the specified properties.
     * @function create
     * @memberof Cancel
     * @static
     * @param {ICancel=} [properties] Properties to set
     * @returns {Cancel} Cancel instance
     */
    Cancel.create = function create(properties) {
        return new Cancel(properties);
    };

    /**
     * Encodes the specified Cancel message. Does not implicitly {@link Cancel.verify|verify} messages.
     * @function encode
     * @memberof Cancel
     * @static
     * @param {ICancel} message Cancel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Cancel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Cancel message, length delimited. Does not implicitly {@link Cancel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Cancel
     * @static
     * @param {ICancel} message Cancel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Cancel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Cancel message from the specified reader or buffer.
     * @function decode
     * @memberof Cancel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Cancel} Cancel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Cancel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Cancel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Cancel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Cancel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Cancel} Cancel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Cancel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Cancel message.
     * @function verify
     * @memberof Cancel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Cancel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a Cancel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Cancel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Cancel} Cancel
     */
    Cancel.fromObject = function fromObject(object) {
        if (object instanceof $root.Cancel)
            return object;
        return new $root.Cancel();
    };

    /**
     * Creates a plain object from a Cancel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Cancel
     * @static
     * @param {Cancel} message Cancel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Cancel.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Cancel to JSON.
     * @function toJSON
     * @memberof Cancel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Cancel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Cancel;
})();

export const Undefined = $root.Undefined = (() => {

    /**
     * Properties of an Undefined.
     * @exports IUndefined
     * @interface IUndefined
     */

    /**
     * Constructs a new Undefined.
     * @exports Undefined
     * @classdesc Represents an Undefined.
     * @implements IUndefined
     * @constructor
     * @param {IUndefined=} [properties] Properties to set
     */
    function Undefined(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Undefined instance using the specified properties.
     * @function create
     * @memberof Undefined
     * @static
     * @param {IUndefined=} [properties] Properties to set
     * @returns {Undefined} Undefined instance
     */
    Undefined.create = function create(properties) {
        return new Undefined(properties);
    };

    /**
     * Encodes the specified Undefined message. Does not implicitly {@link Undefined.verify|verify} messages.
     * @function encode
     * @memberof Undefined
     * @static
     * @param {IUndefined} message Undefined message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Undefined.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Undefined message, length delimited. Does not implicitly {@link Undefined.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Undefined
     * @static
     * @param {IUndefined} message Undefined message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Undefined.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Undefined message from the specified reader or buffer.
     * @function decode
     * @memberof Undefined
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Undefined} Undefined
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Undefined.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Undefined();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Undefined message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Undefined
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Undefined} Undefined
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Undefined.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Undefined message.
     * @function verify
     * @memberof Undefined
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Undefined.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an Undefined message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Undefined
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Undefined} Undefined
     */
    Undefined.fromObject = function fromObject(object) {
        if (object instanceof $root.Undefined)
            return object;
        return new $root.Undefined();
    };

    /**
     * Creates a plain object from an Undefined message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Undefined
     * @static
     * @param {Undefined} message Undefined
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Undefined.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Undefined to JSON.
     * @function toJSON
     * @memberof Undefined
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Undefined.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Undefined;
})();

export const Close = $root.Close = (() => {

    /**
     * Properties of a Close.
     * @exports IClose
     * @interface IClose
     */

    /**
     * Constructs a new Close.
     * @exports Close
     * @classdesc Represents a Close.
     * @implements IClose
     * @constructor
     * @param {IClose=} [properties] Properties to set
     */
    function Close(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Close instance using the specified properties.
     * @function create
     * @memberof Close
     * @static
     * @param {IClose=} [properties] Properties to set
     * @returns {Close} Close instance
     */
    Close.create = function create(properties) {
        return new Close(properties);
    };

    /**
     * Encodes the specified Close message. Does not implicitly {@link Close.verify|verify} messages.
     * @function encode
     * @memberof Close
     * @static
     * @param {IClose} message Close message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Close.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Close message, length delimited. Does not implicitly {@link Close.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Close
     * @static
     * @param {IClose} message Close message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Close.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Close message from the specified reader or buffer.
     * @function decode
     * @memberof Close
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Close} Close
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Close.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Close();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Close message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Close
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Close} Close
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Close.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Close message.
     * @function verify
     * @memberof Close
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Close.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a Close message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Close
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Close} Close
     */
    Close.fromObject = function fromObject(object) {
        if (object instanceof $root.Close)
            return object;
        return new $root.Close();
    };

    /**
     * Creates a plain object from a Close message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Close
     * @static
     * @param {Close} message Close
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Close.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Close to JSON.
     * @function toJSON
     * @memberof Close
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Close.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Close;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

export const CreateProfileRequest = $root.CreateProfileRequest = (() => {

    /**
     * Properties of a CreateProfileRequest.
     * @exports ICreateProfileRequest
     * @interface ICreateProfileRequest
     * @property {string|null} [name] CreateProfileRequest name
     * @property {string|null} [password] CreateProfileRequest password
     */

    /**
     * Constructs a new CreateProfileRequest.
     * @exports CreateProfileRequest
     * @classdesc Represents a CreateProfileRequest.
     * @implements ICreateProfileRequest
     * @constructor
     * @param {ICreateProfileRequest=} [properties] Properties to set
     */
    function CreateProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateProfileRequest name.
     * @member {string} name
     * @memberof CreateProfileRequest
     * @instance
     */
    CreateProfileRequest.prototype.name = "";

    /**
     * CreateProfileRequest password.
     * @member {string} password
     * @memberof CreateProfileRequest
     * @instance
     */
    CreateProfileRequest.prototype.password = "";

    /**
     * Creates a new CreateProfileRequest instance using the specified properties.
     * @function create
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest=} [properties] Properties to set
     * @returns {CreateProfileRequest} CreateProfileRequest instance
     */
    CreateProfileRequest.create = function create(properties) {
        return new CreateProfileRequest(properties);
    };

    /**
     * Encodes the specified CreateProfileRequest message. Does not implicitly {@link CreateProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest} message CreateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified CreateProfileRequest message, length delimited. Does not implicitly {@link CreateProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest} message CreateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateProfileRequest} CreateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateProfileRequest} CreateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateProfileRequest message.
     * @function verify
     * @memberof CreateProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates a CreateProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateProfileRequest} CreateProfileRequest
     */
    CreateProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateProfileRequest)
            return object;
        let message = new $root.CreateProfileRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from a CreateProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateProfileRequest
     * @static
     * @param {CreateProfileRequest} message CreateProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.password = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this CreateProfileRequest to JSON.
     * @function toJSON
     * @memberof CreateProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateProfileRequest;
})();

export const CreateProfileResponse = $root.CreateProfileResponse = (() => {

    /**
     * Properties of a CreateProfileResponse.
     * @exports ICreateProfileResponse
     * @interface ICreateProfileResponse
     * @property {string|null} [sessionId] CreateProfileResponse sessionId
     * @property {IProfile|null} [profile] CreateProfileResponse profile
     */

    /**
     * Constructs a new CreateProfileResponse.
     * @exports CreateProfileResponse
     * @classdesc Represents a CreateProfileResponse.
     * @implements ICreateProfileResponse
     * @constructor
     * @param {ICreateProfileResponse=} [properties] Properties to set
     */
    function CreateProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateProfileResponse sessionId.
     * @member {string} sessionId
     * @memberof CreateProfileResponse
     * @instance
     */
    CreateProfileResponse.prototype.sessionId = "";

    /**
     * CreateProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof CreateProfileResponse
     * @instance
     */
    CreateProfileResponse.prototype.profile = null;

    /**
     * Creates a new CreateProfileResponse instance using the specified properties.
     * @function create
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse=} [properties] Properties to set
     * @returns {CreateProfileResponse} CreateProfileResponse instance
     */
    CreateProfileResponse.create = function create(properties) {
        return new CreateProfileResponse(properties);
    };

    /**
     * Encodes the specified CreateProfileResponse message. Does not implicitly {@link CreateProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse} message CreateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateProfileResponse message, length delimited. Does not implicitly {@link CreateProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse} message CreateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateProfileResponse} CreateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateProfileResponse} CreateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateProfileResponse message.
     * @function verify
     * @memberof CreateProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a CreateProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateProfileResponse} CreateProfileResponse
     */
    CreateProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateProfileResponse)
            return object;
        let message = new $root.CreateProfileResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".CreateProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateProfileResponse
     * @static
     * @param {CreateProfileResponse} message CreateProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this CreateProfileResponse to JSON.
     * @function toJSON
     * @memberof CreateProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateProfileResponse;
})();

export const UpdateProfileRequest = $root.UpdateProfileRequest = (() => {

    /**
     * Properties of an UpdateProfileRequest.
     * @exports IUpdateProfileRequest
     * @interface IUpdateProfileRequest
     * @property {string|null} [name] UpdateProfileRequest name
     * @property {string|null} [password] UpdateProfileRequest password
     */

    /**
     * Constructs a new UpdateProfileRequest.
     * @exports UpdateProfileRequest
     * @classdesc Represents an UpdateProfileRequest.
     * @implements IUpdateProfileRequest
     * @constructor
     * @param {IUpdateProfileRequest=} [properties] Properties to set
     */
    function UpdateProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateProfileRequest name.
     * @member {string} name
     * @memberof UpdateProfileRequest
     * @instance
     */
    UpdateProfileRequest.prototype.name = "";

    /**
     * UpdateProfileRequest password.
     * @member {string} password
     * @memberof UpdateProfileRequest
     * @instance
     */
    UpdateProfileRequest.prototype.password = "";

    /**
     * Creates a new UpdateProfileRequest instance using the specified properties.
     * @function create
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest=} [properties] Properties to set
     * @returns {UpdateProfileRequest} UpdateProfileRequest instance
     */
    UpdateProfileRequest.create = function create(properties) {
        return new UpdateProfileRequest(properties);
    };

    /**
     * Encodes the specified UpdateProfileRequest message. Does not implicitly {@link UpdateProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest} message UpdateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified UpdateProfileRequest message, length delimited. Does not implicitly {@link UpdateProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest} message UpdateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateProfileRequest message.
     * @function verify
     * @memberof UpdateProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates an UpdateProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     */
    UpdateProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateProfileRequest)
            return object;
        let message = new $root.UpdateProfileRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from an UpdateProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateProfileRequest
     * @static
     * @param {UpdateProfileRequest} message UpdateProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.password = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this UpdateProfileRequest to JSON.
     * @function toJSON
     * @memberof UpdateProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateProfileRequest;
})();

export const UpdateProfileResponse = $root.UpdateProfileResponse = (() => {

    /**
     * Properties of an UpdateProfileResponse.
     * @exports IUpdateProfileResponse
     * @interface IUpdateProfileResponse
     * @property {IProfile|null} [profile] UpdateProfileResponse profile
     */

    /**
     * Constructs a new UpdateProfileResponse.
     * @exports UpdateProfileResponse
     * @classdesc Represents an UpdateProfileResponse.
     * @implements IUpdateProfileResponse
     * @constructor
     * @param {IUpdateProfileResponse=} [properties] Properties to set
     */
    function UpdateProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof UpdateProfileResponse
     * @instance
     */
    UpdateProfileResponse.prototype.profile = null;

    /**
     * Creates a new UpdateProfileResponse instance using the specified properties.
     * @function create
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse=} [properties] Properties to set
     * @returns {UpdateProfileResponse} UpdateProfileResponse instance
     */
    UpdateProfileResponse.create = function create(properties) {
        return new UpdateProfileResponse(properties);
    };

    /**
     * Encodes the specified UpdateProfileResponse message. Does not implicitly {@link UpdateProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse} message UpdateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateProfileResponse message, length delimited. Does not implicitly {@link UpdateProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse} message UpdateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateProfileResponse message.
     * @function verify
     * @memberof UpdateProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     */
    UpdateProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateProfileResponse)
            return object;
        let message = new $root.UpdateProfileResponse();
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".UpdateProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateProfileResponse
     * @static
     * @param {UpdateProfileResponse} message UpdateProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.profile = null;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this UpdateProfileResponse to JSON.
     * @function toJSON
     * @memberof UpdateProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateProfileResponse;
})();

export const DeleteProfileRequest = $root.DeleteProfileRequest = (() => {

    /**
     * Properties of a DeleteProfileRequest.
     * @exports IDeleteProfileRequest
     * @interface IDeleteProfileRequest
     * @property {number|null} [id] DeleteProfileRequest id
     */

    /**
     * Constructs a new DeleteProfileRequest.
     * @exports DeleteProfileRequest
     * @classdesc Represents a DeleteProfileRequest.
     * @implements IDeleteProfileRequest
     * @constructor
     * @param {IDeleteProfileRequest=} [properties] Properties to set
     */
    function DeleteProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteProfileRequest id.
     * @member {number} id
     * @memberof DeleteProfileRequest
     * @instance
     */
    DeleteProfileRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteProfileRequest instance using the specified properties.
     * @function create
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest=} [properties] Properties to set
     * @returns {DeleteProfileRequest} DeleteProfileRequest instance
     */
    DeleteProfileRequest.create = function create(properties) {
        return new DeleteProfileRequest(properties);
    };

    /**
     * Encodes the specified DeleteProfileRequest message. Does not implicitly {@link DeleteProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest} message DeleteProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteProfileRequest message, length delimited. Does not implicitly {@link DeleteProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest} message DeleteProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteProfileRequest message.
     * @function verify
     * @memberof DeleteProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     */
    DeleteProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteProfileRequest)
            return object;
        let message = new $root.DeleteProfileRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteProfileRequest
     * @static
     * @param {DeleteProfileRequest} message DeleteProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteProfileRequest to JSON.
     * @function toJSON
     * @memberof DeleteProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteProfileRequest;
})();

export const DeleteProfileResponse = $root.DeleteProfileResponse = (() => {

    /**
     * Properties of a DeleteProfileResponse.
     * @exports IDeleteProfileResponse
     * @interface IDeleteProfileResponse
     */

    /**
     * Constructs a new DeleteProfileResponse.
     * @exports DeleteProfileResponse
     * @classdesc Represents a DeleteProfileResponse.
     * @implements IDeleteProfileResponse
     * @constructor
     * @param {IDeleteProfileResponse=} [properties] Properties to set
     */
    function DeleteProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteProfileResponse instance using the specified properties.
     * @function create
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse=} [properties] Properties to set
     * @returns {DeleteProfileResponse} DeleteProfileResponse instance
     */
    DeleteProfileResponse.create = function create(properties) {
        return new DeleteProfileResponse(properties);
    };

    /**
     * Encodes the specified DeleteProfileResponse message. Does not implicitly {@link DeleteProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse} message DeleteProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteProfileResponse message, length delimited. Does not implicitly {@link DeleteProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse} message DeleteProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteProfileResponse message.
     * @function verify
     * @memberof DeleteProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     */
    DeleteProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteProfileResponse)
            return object;
        return new $root.DeleteProfileResponse();
    };

    /**
     * Creates a plain object from a DeleteProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteProfileResponse
     * @static
     * @param {DeleteProfileResponse} message DeleteProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteProfileResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteProfileResponse to JSON.
     * @function toJSON
     * @memberof DeleteProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteProfileResponse;
})();

export const LoadProfileRequest = $root.LoadProfileRequest = (() => {

    /**
     * Properties of a LoadProfileRequest.
     * @exports ILoadProfileRequest
     * @interface ILoadProfileRequest
     * @property {number|null} [id] LoadProfileRequest id
     * @property {string|null} [name] LoadProfileRequest name
     * @property {string|null} [password] LoadProfileRequest password
     */

    /**
     * Constructs a new LoadProfileRequest.
     * @exports LoadProfileRequest
     * @classdesc Represents a LoadProfileRequest.
     * @implements ILoadProfileRequest
     * @constructor
     * @param {ILoadProfileRequest=} [properties] Properties to set
     */
    function LoadProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadProfileRequest id.
     * @member {number} id
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * LoadProfileRequest name.
     * @member {string} name
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.name = "";

    /**
     * LoadProfileRequest password.
     * @member {string} password
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.password = "";

    /**
     * Creates a new LoadProfileRequest instance using the specified properties.
     * @function create
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest=} [properties] Properties to set
     * @returns {LoadProfileRequest} LoadProfileRequest instance
     */
    LoadProfileRequest.create = function create(properties) {
        return new LoadProfileRequest(properties);
    };

    /**
     * Encodes the specified LoadProfileRequest message. Does not implicitly {@link LoadProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest} message LoadProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified LoadProfileRequest message, length delimited. Does not implicitly {@link LoadProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest} message LoadProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LoadProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadProfileRequest} LoadProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadProfileRequest} LoadProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadProfileRequest message.
     * @function verify
     * @memberof LoadProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates a LoadProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadProfileRequest} LoadProfileRequest
     */
    LoadProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadProfileRequest)
            return object;
        let message = new $root.LoadProfileRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from a LoadProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadProfileRequest
     * @static
     * @param {LoadProfileRequest} message LoadProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            object.password = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this LoadProfileRequest to JSON.
     * @function toJSON
     * @memberof LoadProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadProfileRequest;
})();

export const LoadProfileResponse = $root.LoadProfileResponse = (() => {

    /**
     * Properties of a LoadProfileResponse.
     * @exports ILoadProfileResponse
     * @interface ILoadProfileResponse
     * @property {string|null} [sessionId] LoadProfileResponse sessionId
     * @property {IProfile|null} [profile] LoadProfileResponse profile
     */

    /**
     * Constructs a new LoadProfileResponse.
     * @exports LoadProfileResponse
     * @classdesc Represents a LoadProfileResponse.
     * @implements ILoadProfileResponse
     * @constructor
     * @param {ILoadProfileResponse=} [properties] Properties to set
     */
    function LoadProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadProfileResponse sessionId.
     * @member {string} sessionId
     * @memberof LoadProfileResponse
     * @instance
     */
    LoadProfileResponse.prototype.sessionId = "";

    /**
     * LoadProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof LoadProfileResponse
     * @instance
     */
    LoadProfileResponse.prototype.profile = null;

    /**
     * Creates a new LoadProfileResponse instance using the specified properties.
     * @function create
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse=} [properties] Properties to set
     * @returns {LoadProfileResponse} LoadProfileResponse instance
     */
    LoadProfileResponse.create = function create(properties) {
        return new LoadProfileResponse(properties);
    };

    /**
     * Encodes the specified LoadProfileResponse message. Does not implicitly {@link LoadProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse} message LoadProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LoadProfileResponse message, length delimited. Does not implicitly {@link LoadProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse} message LoadProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LoadProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadProfileResponse} LoadProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadProfileResponse} LoadProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadProfileResponse message.
     * @function verify
     * @memberof LoadProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a LoadProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadProfileResponse} LoadProfileResponse
     */
    LoadProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadProfileResponse)
            return object;
        let message = new $root.LoadProfileResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".LoadProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a LoadProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadProfileResponse
     * @static
     * @param {LoadProfileResponse} message LoadProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this LoadProfileResponse to JSON.
     * @function toJSON
     * @memberof LoadProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadProfileResponse;
})();

export const GetProfileRequest = $root.GetProfileRequest = (() => {

    /**
     * Properties of a GetProfileRequest.
     * @exports IGetProfileRequest
     * @interface IGetProfileRequest
     * @property {string|null} [sessionId] GetProfileRequest sessionId
     */

    /**
     * Constructs a new GetProfileRequest.
     * @exports GetProfileRequest
     * @classdesc Represents a GetProfileRequest.
     * @implements IGetProfileRequest
     * @constructor
     * @param {IGetProfileRequest=} [properties] Properties to set
     */
    function GetProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetProfileRequest sessionId.
     * @member {string} sessionId
     * @memberof GetProfileRequest
     * @instance
     */
    GetProfileRequest.prototype.sessionId = "";

    /**
     * Creates a new GetProfileRequest instance using the specified properties.
     * @function create
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest=} [properties] Properties to set
     * @returns {GetProfileRequest} GetProfileRequest instance
     */
    GetProfileRequest.create = function create(properties) {
        return new GetProfileRequest(properties);
    };

    /**
     * Encodes the specified GetProfileRequest message. Does not implicitly {@link GetProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest} message GetProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        return writer;
    };

    /**
     * Encodes the specified GetProfileRequest message, length delimited. Does not implicitly {@link GetProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest} message GetProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfileRequest} GetProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfileRequest} GetProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfileRequest message.
     * @function verify
     * @memberof GetProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        return null;
    };

    /**
     * Creates a GetProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfileRequest} GetProfileRequest
     */
    GetProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfileRequest)
            return object;
        let message = new $root.GetProfileRequest();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        return message;
    };

    /**
     * Creates a plain object from a GetProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfileRequest
     * @static
     * @param {GetProfileRequest} message GetProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.sessionId = "";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        return object;
    };

    /**
     * Converts this GetProfileRequest to JSON.
     * @function toJSON
     * @memberof GetProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfileRequest;
})();

export const GetProfileResponse = $root.GetProfileResponse = (() => {

    /**
     * Properties of a GetProfileResponse.
     * @exports IGetProfileResponse
     * @interface IGetProfileResponse
     * @property {IProfile|null} [profile] GetProfileResponse profile
     */

    /**
     * Constructs a new GetProfileResponse.
     * @exports GetProfileResponse
     * @classdesc Represents a GetProfileResponse.
     * @implements IGetProfileResponse
     * @constructor
     * @param {IGetProfileResponse=} [properties] Properties to set
     */
    function GetProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof GetProfileResponse
     * @instance
     */
    GetProfileResponse.prototype.profile = null;

    /**
     * Creates a new GetProfileResponse instance using the specified properties.
     * @function create
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse=} [properties] Properties to set
     * @returns {GetProfileResponse} GetProfileResponse instance
     */
    GetProfileResponse.create = function create(properties) {
        return new GetProfileResponse(properties);
    };

    /**
     * Encodes the specified GetProfileResponse message. Does not implicitly {@link GetProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse} message GetProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetProfileResponse message, length delimited. Does not implicitly {@link GetProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse} message GetProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfileResponse} GetProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfileResponse} GetProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfileResponse message.
     * @function verify
     * @memberof GetProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a GetProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfileResponse} GetProfileResponse
     */
    GetProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfileResponse)
            return object;
        let message = new $root.GetProfileResponse();
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".GetProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfileResponse
     * @static
     * @param {GetProfileResponse} message GetProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.profile = null;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this GetProfileResponse to JSON.
     * @function toJSON
     * @memberof GetProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfileResponse;
})();

export const GetProfilesRequest = $root.GetProfilesRequest = (() => {

    /**
     * Properties of a GetProfilesRequest.
     * @exports IGetProfilesRequest
     * @interface IGetProfilesRequest
     */

    /**
     * Constructs a new GetProfilesRequest.
     * @exports GetProfilesRequest
     * @classdesc Represents a GetProfilesRequest.
     * @implements IGetProfilesRequest
     * @constructor
     * @param {IGetProfilesRequest=} [properties] Properties to set
     */
    function GetProfilesRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetProfilesRequest instance using the specified properties.
     * @function create
     * @memberof GetProfilesRequest
     * @static
     * @param {IGetProfilesRequest=} [properties] Properties to set
     * @returns {GetProfilesRequest} GetProfilesRequest instance
     */
    GetProfilesRequest.create = function create(properties) {
        return new GetProfilesRequest(properties);
    };

    /**
     * Encodes the specified GetProfilesRequest message. Does not implicitly {@link GetProfilesRequest.verify|verify} messages.
     * @function encode
     * @memberof GetProfilesRequest
     * @static
     * @param {IGetProfilesRequest} message GetProfilesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfilesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetProfilesRequest message, length delimited. Does not implicitly {@link GetProfilesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfilesRequest
     * @static
     * @param {IGetProfilesRequest} message GetProfilesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfilesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfilesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfilesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfilesRequest} GetProfilesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfilesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfilesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfilesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfilesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfilesRequest} GetProfilesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfilesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfilesRequest message.
     * @function verify
     * @memberof GetProfilesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfilesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetProfilesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfilesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfilesRequest} GetProfilesRequest
     */
    GetProfilesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfilesRequest)
            return object;
        return new $root.GetProfilesRequest();
    };

    /**
     * Creates a plain object from a GetProfilesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfilesRequest
     * @static
     * @param {GetProfilesRequest} message GetProfilesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfilesRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetProfilesRequest to JSON.
     * @function toJSON
     * @memberof GetProfilesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfilesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfilesRequest;
})();

export const GetProfilesResponse = $root.GetProfilesResponse = (() => {

    /**
     * Properties of a GetProfilesResponse.
     * @exports IGetProfilesResponse
     * @interface IGetProfilesResponse
     * @property {Array.<IProfileSummary>|null} [profiles] GetProfilesResponse profiles
     */

    /**
     * Constructs a new GetProfilesResponse.
     * @exports GetProfilesResponse
     * @classdesc Represents a GetProfilesResponse.
     * @implements IGetProfilesResponse
     * @constructor
     * @param {IGetProfilesResponse=} [properties] Properties to set
     */
    function GetProfilesResponse(properties) {
        this.profiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetProfilesResponse profiles.
     * @member {Array.<IProfileSummary>} profiles
     * @memberof GetProfilesResponse
     * @instance
     */
    GetProfilesResponse.prototype.profiles = $util.emptyArray;

    /**
     * Creates a new GetProfilesResponse instance using the specified properties.
     * @function create
     * @memberof GetProfilesResponse
     * @static
     * @param {IGetProfilesResponse=} [properties] Properties to set
     * @returns {GetProfilesResponse} GetProfilesResponse instance
     */
    GetProfilesResponse.create = function create(properties) {
        return new GetProfilesResponse(properties);
    };

    /**
     * Encodes the specified GetProfilesResponse message. Does not implicitly {@link GetProfilesResponse.verify|verify} messages.
     * @function encode
     * @memberof GetProfilesResponse
     * @static
     * @param {IGetProfilesResponse} message GetProfilesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfilesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profiles != null && message.profiles.length)
            for (let i = 0; i < message.profiles.length; ++i)
                $root.ProfileSummary.encode(message.profiles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetProfilesResponse message, length delimited. Does not implicitly {@link GetProfilesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfilesResponse
     * @static
     * @param {IGetProfilesResponse} message GetProfilesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfilesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfilesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfilesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfilesResponse} GetProfilesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfilesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfilesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.profiles && message.profiles.length))
                    message.profiles = [];
                message.profiles.push($root.ProfileSummary.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfilesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfilesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfilesResponse} GetProfilesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfilesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfilesResponse message.
     * @function verify
     * @memberof GetProfilesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfilesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profiles != null && message.hasOwnProperty("profiles")) {
            if (!Array.isArray(message.profiles))
                return "profiles: array expected";
            for (let i = 0; i < message.profiles.length; ++i) {
                let error = $root.ProfileSummary.verify(message.profiles[i]);
                if (error)
                    return "profiles." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetProfilesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfilesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfilesResponse} GetProfilesResponse
     */
    GetProfilesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfilesResponse)
            return object;
        let message = new $root.GetProfilesResponse();
        if (object.profiles) {
            if (!Array.isArray(object.profiles))
                throw TypeError(".GetProfilesResponse.profiles: array expected");
            message.profiles = [];
            for (let i = 0; i < object.profiles.length; ++i) {
                if (typeof object.profiles[i] !== "object")
                    throw TypeError(".GetProfilesResponse.profiles: object expected");
                message.profiles[i] = $root.ProfileSummary.fromObject(object.profiles[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetProfilesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfilesResponse
     * @static
     * @param {GetProfilesResponse} message GetProfilesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfilesResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.profiles = [];
        if (message.profiles && message.profiles.length) {
            object.profiles = [];
            for (let j = 0; j < message.profiles.length; ++j)
                object.profiles[j] = $root.ProfileSummary.toObject(message.profiles[j], options);
        }
        return object;
    };

    /**
     * Converts this GetProfilesResponse to JSON.
     * @function toJSON
     * @memberof GetProfilesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfilesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfilesResponse;
})();

export const LoadSessionRequest = $root.LoadSessionRequest = (() => {

    /**
     * Properties of a LoadSessionRequest.
     * @exports ILoadSessionRequest
     * @interface ILoadSessionRequest
     * @property {string|null} [sessionId] LoadSessionRequest sessionId
     */

    /**
     * Constructs a new LoadSessionRequest.
     * @exports LoadSessionRequest
     * @classdesc Represents a LoadSessionRequest.
     * @implements ILoadSessionRequest
     * @constructor
     * @param {ILoadSessionRequest=} [properties] Properties to set
     */
    function LoadSessionRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadSessionRequest sessionId.
     * @member {string} sessionId
     * @memberof LoadSessionRequest
     * @instance
     */
    LoadSessionRequest.prototype.sessionId = "";

    /**
     * Creates a new LoadSessionRequest instance using the specified properties.
     * @function create
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest=} [properties] Properties to set
     * @returns {LoadSessionRequest} LoadSessionRequest instance
     */
    LoadSessionRequest.create = function create(properties) {
        return new LoadSessionRequest(properties);
    };

    /**
     * Encodes the specified LoadSessionRequest message. Does not implicitly {@link LoadSessionRequest.verify|verify} messages.
     * @function encode
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest} message LoadSessionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        return writer;
    };

    /**
     * Encodes the specified LoadSessionRequest message, length delimited. Does not implicitly {@link LoadSessionRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest} message LoadSessionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadSessionRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LoadSessionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadSessionRequest} LoadSessionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadSessionRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadSessionRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadSessionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadSessionRequest} LoadSessionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadSessionRequest message.
     * @function verify
     * @memberof LoadSessionRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadSessionRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        return null;
    };

    /**
     * Creates a LoadSessionRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadSessionRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadSessionRequest} LoadSessionRequest
     */
    LoadSessionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadSessionRequest)
            return object;
        let message = new $root.LoadSessionRequest();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        return message;
    };

    /**
     * Creates a plain object from a LoadSessionRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadSessionRequest
     * @static
     * @param {LoadSessionRequest} message LoadSessionRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadSessionRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.sessionId = "";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        return object;
    };

    /**
     * Converts this LoadSessionRequest to JSON.
     * @function toJSON
     * @memberof LoadSessionRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadSessionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadSessionRequest;
})();

export const LoadSessionResponse = $root.LoadSessionResponse = (() => {

    /**
     * Properties of a LoadSessionResponse.
     * @exports ILoadSessionResponse
     * @interface ILoadSessionResponse
     * @property {string|null} [sessionId] LoadSessionResponse sessionId
     * @property {IProfile|null} [profile] LoadSessionResponse profile
     */

    /**
     * Constructs a new LoadSessionResponse.
     * @exports LoadSessionResponse
     * @classdesc Represents a LoadSessionResponse.
     * @implements ILoadSessionResponse
     * @constructor
     * @param {ILoadSessionResponse=} [properties] Properties to set
     */
    function LoadSessionResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadSessionResponse sessionId.
     * @member {string} sessionId
     * @memberof LoadSessionResponse
     * @instance
     */
    LoadSessionResponse.prototype.sessionId = "";

    /**
     * LoadSessionResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof LoadSessionResponse
     * @instance
     */
    LoadSessionResponse.prototype.profile = null;

    /**
     * Creates a new LoadSessionResponse instance using the specified properties.
     * @function create
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse=} [properties] Properties to set
     * @returns {LoadSessionResponse} LoadSessionResponse instance
     */
    LoadSessionResponse.create = function create(properties) {
        return new LoadSessionResponse(properties);
    };

    /**
     * Encodes the specified LoadSessionResponse message. Does not implicitly {@link LoadSessionResponse.verify|verify} messages.
     * @function encode
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse} message LoadSessionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LoadSessionResponse message, length delimited. Does not implicitly {@link LoadSessionResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse} message LoadSessionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadSessionResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LoadSessionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadSessionResponse} LoadSessionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadSessionResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadSessionResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadSessionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadSessionResponse} LoadSessionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadSessionResponse message.
     * @function verify
     * @memberof LoadSessionResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadSessionResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a LoadSessionResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadSessionResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadSessionResponse} LoadSessionResponse
     */
    LoadSessionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadSessionResponse)
            return object;
        let message = new $root.LoadSessionResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".LoadSessionResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a LoadSessionResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadSessionResponse
     * @static
     * @param {LoadSessionResponse} message LoadSessionResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadSessionResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this LoadSessionResponse to JSON.
     * @function toJSON
     * @memberof LoadSessionResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadSessionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadSessionResponse;
})();

export const CreateNetworkRequest = $root.CreateNetworkRequest = (() => {

    /**
     * Properties of a CreateNetworkRequest.
     * @exports ICreateNetworkRequest
     * @interface ICreateNetworkRequest
     * @property {string|null} [name] CreateNetworkRequest name
     */

    /**
     * Constructs a new CreateNetworkRequest.
     * @exports CreateNetworkRequest
     * @classdesc Represents a CreateNetworkRequest.
     * @implements ICreateNetworkRequest
     * @constructor
     * @param {ICreateNetworkRequest=} [properties] Properties to set
     */
    function CreateNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkRequest name.
     * @member {string} name
     * @memberof CreateNetworkRequest
     * @instance
     */
    CreateNetworkRequest.prototype.name = "";

    /**
     * Creates a new CreateNetworkRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest=} [properties] Properties to set
     * @returns {CreateNetworkRequest} CreateNetworkRequest instance
     */
    CreateNetworkRequest.create = function create(properties) {
        return new CreateNetworkRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkRequest message. Does not implicitly {@link CreateNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkRequest message, length delimited. Does not implicitly {@link CreateNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkRequest message.
     * @function verify
     * @memberof CreateNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates a CreateNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     */
    CreateNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkRequest)
            return object;
        let message = new $root.CreateNetworkRequest();
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkRequest
     * @static
     * @param {CreateNetworkRequest} message CreateNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.name = "";
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this CreateNetworkRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkRequest;
})();

export const CreateNetworkResponse = $root.CreateNetworkResponse = (() => {

    /**
     * Properties of a CreateNetworkResponse.
     * @exports ICreateNetworkResponse
     * @interface ICreateNetworkResponse
     * @property {INetwork|null} [network] CreateNetworkResponse network
     */

    /**
     * Constructs a new CreateNetworkResponse.
     * @exports CreateNetworkResponse
     * @classdesc Represents a CreateNetworkResponse.
     * @implements ICreateNetworkResponse
     * @constructor
     * @param {ICreateNetworkResponse=} [properties] Properties to set
     */
    function CreateNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof CreateNetworkResponse
     * @instance
     */
    CreateNetworkResponse.prototype.network = null;

    /**
     * Creates a new CreateNetworkResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse=} [properties] Properties to set
     * @returns {CreateNetworkResponse} CreateNetworkResponse instance
     */
    CreateNetworkResponse.create = function create(properties) {
        return new CreateNetworkResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkResponse message. Does not implicitly {@link CreateNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse} message CreateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkResponse message, length delimited. Does not implicitly {@link CreateNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse} message CreateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkResponse message.
     * @function verify
     * @memberof CreateNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a CreateNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     */
    CreateNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkResponse)
            return object;
        let message = new $root.CreateNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".CreateNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkResponse
     * @static
     * @param {CreateNetworkResponse} message CreateNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this CreateNetworkResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkResponse;
})();

export const UpdateNetworkRequest = $root.UpdateNetworkRequest = (() => {

    /**
     * Properties of an UpdateNetworkRequest.
     * @exports IUpdateNetworkRequest
     * @interface IUpdateNetworkRequest
     * @property {number|null} [id] UpdateNetworkRequest id
     * @property {string|null} [name] UpdateNetworkRequest name
     */

    /**
     * Constructs a new UpdateNetworkRequest.
     * @exports UpdateNetworkRequest
     * @classdesc Represents an UpdateNetworkRequest.
     * @implements IUpdateNetworkRequest
     * @constructor
     * @param {IUpdateNetworkRequest=} [properties] Properties to set
     */
    function UpdateNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateNetworkRequest id.
     * @member {number} id
     * @memberof UpdateNetworkRequest
     * @instance
     */
    UpdateNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateNetworkRequest name.
     * @member {string} name
     * @memberof UpdateNetworkRequest
     * @instance
     */
    UpdateNetworkRequest.prototype.name = "";

    /**
     * Creates a new UpdateNetworkRequest instance using the specified properties.
     * @function create
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest=} [properties] Properties to set
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest instance
     */
    UpdateNetworkRequest.create = function create(properties) {
        return new UpdateNetworkRequest(properties);
    };

    /**
     * Encodes the specified UpdateNetworkRequest message. Does not implicitly {@link UpdateNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest} message UpdateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified UpdateNetworkRequest message, length delimited. Does not implicitly {@link UpdateNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest} message UpdateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateNetworkRequest message.
     * @function verify
     * @memberof UpdateNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates an UpdateNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     */
    UpdateNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateNetworkRequest)
            return object;
        let message = new $root.UpdateNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from an UpdateNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateNetworkRequest
     * @static
     * @param {UpdateNetworkRequest} message UpdateNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this UpdateNetworkRequest to JSON.
     * @function toJSON
     * @memberof UpdateNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateNetworkRequest;
})();

export const UpdateNetworkResponse = $root.UpdateNetworkResponse = (() => {

    /**
     * Properties of an UpdateNetworkResponse.
     * @exports IUpdateNetworkResponse
     * @interface IUpdateNetworkResponse
     * @property {INetwork|null} [network] UpdateNetworkResponse network
     */

    /**
     * Constructs a new UpdateNetworkResponse.
     * @exports UpdateNetworkResponse
     * @classdesc Represents an UpdateNetworkResponse.
     * @implements IUpdateNetworkResponse
     * @constructor
     * @param {IUpdateNetworkResponse=} [properties] Properties to set
     */
    function UpdateNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof UpdateNetworkResponse
     * @instance
     */
    UpdateNetworkResponse.prototype.network = null;

    /**
     * Creates a new UpdateNetworkResponse instance using the specified properties.
     * @function create
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse=} [properties] Properties to set
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse instance
     */
    UpdateNetworkResponse.create = function create(properties) {
        return new UpdateNetworkResponse(properties);
    };

    /**
     * Encodes the specified UpdateNetworkResponse message. Does not implicitly {@link UpdateNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse} message UpdateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateNetworkResponse message, length delimited. Does not implicitly {@link UpdateNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse} message UpdateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateNetworkResponse message.
     * @function verify
     * @memberof UpdateNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     */
    UpdateNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateNetworkResponse)
            return object;
        let message = new $root.UpdateNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".UpdateNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateNetworkResponse
     * @static
     * @param {UpdateNetworkResponse} message UpdateNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this UpdateNetworkResponse to JSON.
     * @function toJSON
     * @memberof UpdateNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateNetworkResponse;
})();

export const DeleteNetworkRequest = $root.DeleteNetworkRequest = (() => {

    /**
     * Properties of a DeleteNetworkRequest.
     * @exports IDeleteNetworkRequest
     * @interface IDeleteNetworkRequest
     * @property {number|null} [id] DeleteNetworkRequest id
     */

    /**
     * Constructs a new DeleteNetworkRequest.
     * @exports DeleteNetworkRequest
     * @classdesc Represents a DeleteNetworkRequest.
     * @implements IDeleteNetworkRequest
     * @constructor
     * @param {IDeleteNetworkRequest=} [properties] Properties to set
     */
    function DeleteNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteNetworkRequest id.
     * @member {number} id
     * @memberof DeleteNetworkRequest
     * @instance
     */
    DeleteNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteNetworkRequest instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest=} [properties] Properties to set
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest instance
     */
    DeleteNetworkRequest.create = function create(properties) {
        return new DeleteNetworkRequest(properties);
    };

    /**
     * Encodes the specified DeleteNetworkRequest message. Does not implicitly {@link DeleteNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest} message DeleteNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkRequest message, length delimited. Does not implicitly {@link DeleteNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest} message DeleteNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkRequest message.
     * @function verify
     * @memberof DeleteNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     */
    DeleteNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkRequest)
            return object;
        let message = new $root.DeleteNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkRequest
     * @static
     * @param {DeleteNetworkRequest} message DeleteNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteNetworkRequest to JSON.
     * @function toJSON
     * @memberof DeleteNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkRequest;
})();

export const DeleteNetworkResponse = $root.DeleteNetworkResponse = (() => {

    /**
     * Properties of a DeleteNetworkResponse.
     * @exports IDeleteNetworkResponse
     * @interface IDeleteNetworkResponse
     */

    /**
     * Constructs a new DeleteNetworkResponse.
     * @exports DeleteNetworkResponse
     * @classdesc Represents a DeleteNetworkResponse.
     * @implements IDeleteNetworkResponse
     * @constructor
     * @param {IDeleteNetworkResponse=} [properties] Properties to set
     */
    function DeleteNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteNetworkResponse instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse=} [properties] Properties to set
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse instance
     */
    DeleteNetworkResponse.create = function create(properties) {
        return new DeleteNetworkResponse(properties);
    };

    /**
     * Encodes the specified DeleteNetworkResponse message. Does not implicitly {@link DeleteNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse} message DeleteNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkResponse message, length delimited. Does not implicitly {@link DeleteNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse} message DeleteNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkResponse message.
     * @function verify
     * @memberof DeleteNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     */
    DeleteNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkResponse)
            return object;
        return new $root.DeleteNetworkResponse();
    };

    /**
     * Creates a plain object from a DeleteNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkResponse
     * @static
     * @param {DeleteNetworkResponse} message DeleteNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteNetworkResponse to JSON.
     * @function toJSON
     * @memberof DeleteNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkResponse;
})();

export const GetNetworkRequest = $root.GetNetworkRequest = (() => {

    /**
     * Properties of a GetNetworkRequest.
     * @exports IGetNetworkRequest
     * @interface IGetNetworkRequest
     * @property {number|null} [id] GetNetworkRequest id
     */

    /**
     * Constructs a new GetNetworkRequest.
     * @exports GetNetworkRequest
     * @classdesc Represents a GetNetworkRequest.
     * @implements IGetNetworkRequest
     * @constructor
     * @param {IGetNetworkRequest=} [properties] Properties to set
     */
    function GetNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworkRequest id.
     * @member {number} id
     * @memberof GetNetworkRequest
     * @instance
     */
    GetNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetNetworkRequest instance using the specified properties.
     * @function create
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest=} [properties] Properties to set
     * @returns {GetNetworkRequest} GetNetworkRequest instance
     */
    GetNetworkRequest.create = function create(properties) {
        return new GetNetworkRequest(properties);
    };

    /**
     * Encodes the specified GetNetworkRequest message. Does not implicitly {@link GetNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest} message GetNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetNetworkRequest message, length delimited. Does not implicitly {@link GetNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest} message GetNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkRequest} GetNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkRequest} GetNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkRequest message.
     * @function verify
     * @memberof GetNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkRequest} GetNetworkRequest
     */
    GetNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkRequest)
            return object;
        let message = new $root.GetNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkRequest
     * @static
     * @param {GetNetworkRequest} message GetNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetNetworkRequest to JSON.
     * @function toJSON
     * @memberof GetNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkRequest;
})();

export const GetNetworkResponse = $root.GetNetworkResponse = (() => {

    /**
     * Properties of a GetNetworkResponse.
     * @exports IGetNetworkResponse
     * @interface IGetNetworkResponse
     * @property {INetwork|null} [network] GetNetworkResponse network
     */

    /**
     * Constructs a new GetNetworkResponse.
     * @exports GetNetworkResponse
     * @classdesc Represents a GetNetworkResponse.
     * @implements IGetNetworkResponse
     * @constructor
     * @param {IGetNetworkResponse=} [properties] Properties to set
     */
    function GetNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof GetNetworkResponse
     * @instance
     */
    GetNetworkResponse.prototype.network = null;

    /**
     * Creates a new GetNetworkResponse instance using the specified properties.
     * @function create
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse=} [properties] Properties to set
     * @returns {GetNetworkResponse} GetNetworkResponse instance
     */
    GetNetworkResponse.create = function create(properties) {
        return new GetNetworkResponse(properties);
    };

    /**
     * Encodes the specified GetNetworkResponse message. Does not implicitly {@link GetNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse} message GetNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetNetworkResponse message, length delimited. Does not implicitly {@link GetNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse} message GetNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkResponse} GetNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkResponse} GetNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkResponse message.
     * @function verify
     * @memberof GetNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a GetNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkResponse} GetNetworkResponse
     */
    GetNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkResponse)
            return object;
        let message = new $root.GetNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".GetNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkResponse
     * @static
     * @param {GetNetworkResponse} message GetNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this GetNetworkResponse to JSON.
     * @function toJSON
     * @memberof GetNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkResponse;
})();

export const GetNetworksRequest = $root.GetNetworksRequest = (() => {

    /**
     * Properties of a GetNetworksRequest.
     * @exports IGetNetworksRequest
     * @interface IGetNetworksRequest
     */

    /**
     * Constructs a new GetNetworksRequest.
     * @exports GetNetworksRequest
     * @classdesc Represents a GetNetworksRequest.
     * @implements IGetNetworksRequest
     * @constructor
     * @param {IGetNetworksRequest=} [properties] Properties to set
     */
    function GetNetworksRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetNetworksRequest instance using the specified properties.
     * @function create
     * @memberof GetNetworksRequest
     * @static
     * @param {IGetNetworksRequest=} [properties] Properties to set
     * @returns {GetNetworksRequest} GetNetworksRequest instance
     */
    GetNetworksRequest.create = function create(properties) {
        return new GetNetworksRequest(properties);
    };

    /**
     * Encodes the specified GetNetworksRequest message. Does not implicitly {@link GetNetworksRequest.verify|verify} messages.
     * @function encode
     * @memberof GetNetworksRequest
     * @static
     * @param {IGetNetworksRequest} message GetNetworksRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworksRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetNetworksRequest message, length delimited. Does not implicitly {@link GetNetworksRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworksRequest
     * @static
     * @param {IGetNetworksRequest} message GetNetworksRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworksRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworksRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworksRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworksRequest} GetNetworksRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworksRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworksRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworksRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworksRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworksRequest} GetNetworksRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworksRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworksRequest message.
     * @function verify
     * @memberof GetNetworksRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworksRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetNetworksRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworksRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworksRequest} GetNetworksRequest
     */
    GetNetworksRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworksRequest)
            return object;
        return new $root.GetNetworksRequest();
    };

    /**
     * Creates a plain object from a GetNetworksRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworksRequest
     * @static
     * @param {GetNetworksRequest} message GetNetworksRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworksRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetNetworksRequest to JSON.
     * @function toJSON
     * @memberof GetNetworksRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworksRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworksRequest;
})();

export const GetNetworksResponse = $root.GetNetworksResponse = (() => {

    /**
     * Properties of a GetNetworksResponse.
     * @exports IGetNetworksResponse
     * @interface IGetNetworksResponse
     * @property {Array.<INetwork>|null} [networks] GetNetworksResponse networks
     */

    /**
     * Constructs a new GetNetworksResponse.
     * @exports GetNetworksResponse
     * @classdesc Represents a GetNetworksResponse.
     * @implements IGetNetworksResponse
     * @constructor
     * @param {IGetNetworksResponse=} [properties] Properties to set
     */
    function GetNetworksResponse(properties) {
        this.networks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworksResponse networks.
     * @member {Array.<INetwork>} networks
     * @memberof GetNetworksResponse
     * @instance
     */
    GetNetworksResponse.prototype.networks = $util.emptyArray;

    /**
     * Creates a new GetNetworksResponse instance using the specified properties.
     * @function create
     * @memberof GetNetworksResponse
     * @static
     * @param {IGetNetworksResponse=} [properties] Properties to set
     * @returns {GetNetworksResponse} GetNetworksResponse instance
     */
    GetNetworksResponse.create = function create(properties) {
        return new GetNetworksResponse(properties);
    };

    /**
     * Encodes the specified GetNetworksResponse message. Does not implicitly {@link GetNetworksResponse.verify|verify} messages.
     * @function encode
     * @memberof GetNetworksResponse
     * @static
     * @param {IGetNetworksResponse} message GetNetworksResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworksResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networks != null && message.networks.length)
            for (let i = 0; i < message.networks.length; ++i)
                $root.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetNetworksResponse message, length delimited. Does not implicitly {@link GetNetworksResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworksResponse
     * @static
     * @param {IGetNetworksResponse} message GetNetworksResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworksResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworksResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworksResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworksResponse} GetNetworksResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworksResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworksResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.networks && message.networks.length))
                    message.networks = [];
                message.networks.push($root.Network.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworksResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworksResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworksResponse} GetNetworksResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworksResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworksResponse message.
     * @function verify
     * @memberof GetNetworksResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworksResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networks != null && message.hasOwnProperty("networks")) {
            if (!Array.isArray(message.networks))
                return "networks: array expected";
            for (let i = 0; i < message.networks.length; ++i) {
                let error = $root.Network.verify(message.networks[i]);
                if (error)
                    return "networks." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetNetworksResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworksResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworksResponse} GetNetworksResponse
     */
    GetNetworksResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworksResponse)
            return object;
        let message = new $root.GetNetworksResponse();
        if (object.networks) {
            if (!Array.isArray(object.networks))
                throw TypeError(".GetNetworksResponse.networks: array expected");
            message.networks = [];
            for (let i = 0; i < object.networks.length; ++i) {
                if (typeof object.networks[i] !== "object")
                    throw TypeError(".GetNetworksResponse.networks: object expected");
                message.networks[i] = $root.Network.fromObject(object.networks[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetNetworksResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworksResponse
     * @static
     * @param {GetNetworksResponse} message GetNetworksResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworksResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.networks = [];
        if (message.networks && message.networks.length) {
            object.networks = [];
            for (let j = 0; j < message.networks.length; ++j)
                object.networks[j] = $root.Network.toObject(message.networks[j], options);
        }
        return object;
    };

    /**
     * Converts this GetNetworksResponse to JSON.
     * @function toJSON
     * @memberof GetNetworksResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworksResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworksResponse;
})();

export const GetNetworkMembershipsRequest = $root.GetNetworkMembershipsRequest = (() => {

    /**
     * Properties of a GetNetworkMembershipsRequest.
     * @exports IGetNetworkMembershipsRequest
     * @interface IGetNetworkMembershipsRequest
     */

    /**
     * Constructs a new GetNetworkMembershipsRequest.
     * @exports GetNetworkMembershipsRequest
     * @classdesc Represents a GetNetworkMembershipsRequest.
     * @implements IGetNetworkMembershipsRequest
     * @constructor
     * @param {IGetNetworkMembershipsRequest=} [properties] Properties to set
     */
    function GetNetworkMembershipsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetNetworkMembershipsRequest instance using the specified properties.
     * @function create
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {IGetNetworkMembershipsRequest=} [properties] Properties to set
     * @returns {GetNetworkMembershipsRequest} GetNetworkMembershipsRequest instance
     */
    GetNetworkMembershipsRequest.create = function create(properties) {
        return new GetNetworkMembershipsRequest(properties);
    };

    /**
     * Encodes the specified GetNetworkMembershipsRequest message. Does not implicitly {@link GetNetworkMembershipsRequest.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {IGetNetworkMembershipsRequest} message GetNetworkMembershipsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkMembershipsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetNetworkMembershipsRequest message, length delimited. Does not implicitly {@link GetNetworkMembershipsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {IGetNetworkMembershipsRequest} message GetNetworkMembershipsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkMembershipsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkMembershipsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkMembershipsRequest} GetNetworkMembershipsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkMembershipsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkMembershipsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkMembershipsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkMembershipsRequest} GetNetworkMembershipsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkMembershipsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkMembershipsRequest message.
     * @function verify
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkMembershipsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetNetworkMembershipsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkMembershipsRequest} GetNetworkMembershipsRequest
     */
    GetNetworkMembershipsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkMembershipsRequest)
            return object;
        return new $root.GetNetworkMembershipsRequest();
    };

    /**
     * Creates a plain object from a GetNetworkMembershipsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkMembershipsRequest
     * @static
     * @param {GetNetworkMembershipsRequest} message GetNetworkMembershipsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkMembershipsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetNetworkMembershipsRequest to JSON.
     * @function toJSON
     * @memberof GetNetworkMembershipsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkMembershipsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkMembershipsRequest;
})();

export const GetNetworkMembershipsResponse = $root.GetNetworkMembershipsResponse = (() => {

    /**
     * Properties of a GetNetworkMembershipsResponse.
     * @exports IGetNetworkMembershipsResponse
     * @interface IGetNetworkMembershipsResponse
     * @property {Array.<INetworkMembership>|null} [networkMemberships] GetNetworkMembershipsResponse networkMemberships
     */

    /**
     * Constructs a new GetNetworkMembershipsResponse.
     * @exports GetNetworkMembershipsResponse
     * @classdesc Represents a GetNetworkMembershipsResponse.
     * @implements IGetNetworkMembershipsResponse
     * @constructor
     * @param {IGetNetworkMembershipsResponse=} [properties] Properties to set
     */
    function GetNetworkMembershipsResponse(properties) {
        this.networkMemberships = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworkMembershipsResponse networkMemberships.
     * @member {Array.<INetworkMembership>} networkMemberships
     * @memberof GetNetworkMembershipsResponse
     * @instance
     */
    GetNetworkMembershipsResponse.prototype.networkMemberships = $util.emptyArray;

    /**
     * Creates a new GetNetworkMembershipsResponse instance using the specified properties.
     * @function create
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {IGetNetworkMembershipsResponse=} [properties] Properties to set
     * @returns {GetNetworkMembershipsResponse} GetNetworkMembershipsResponse instance
     */
    GetNetworkMembershipsResponse.create = function create(properties) {
        return new GetNetworkMembershipsResponse(properties);
    };

    /**
     * Encodes the specified GetNetworkMembershipsResponse message. Does not implicitly {@link GetNetworkMembershipsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {IGetNetworkMembershipsResponse} message GetNetworkMembershipsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkMembershipsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkMemberships != null && message.networkMemberships.length)
            for (let i = 0; i < message.networkMemberships.length; ++i)
                $root.NetworkMembership.encode(message.networkMemberships[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetNetworkMembershipsResponse message, length delimited. Does not implicitly {@link GetNetworkMembershipsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {IGetNetworkMembershipsResponse} message GetNetworkMembershipsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkMembershipsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkMembershipsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkMembershipsResponse} GetNetworkMembershipsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkMembershipsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkMembershipsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.networkMemberships && message.networkMemberships.length))
                    message.networkMemberships = [];
                message.networkMemberships.push($root.NetworkMembership.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkMembershipsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkMembershipsResponse} GetNetworkMembershipsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkMembershipsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkMembershipsResponse message.
     * @function verify
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkMembershipsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkMemberships != null && message.hasOwnProperty("networkMemberships")) {
            if (!Array.isArray(message.networkMemberships))
                return "networkMemberships: array expected";
            for (let i = 0; i < message.networkMemberships.length; ++i) {
                let error = $root.NetworkMembership.verify(message.networkMemberships[i]);
                if (error)
                    return "networkMemberships." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetNetworkMembershipsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkMembershipsResponse} GetNetworkMembershipsResponse
     */
    GetNetworkMembershipsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkMembershipsResponse)
            return object;
        let message = new $root.GetNetworkMembershipsResponse();
        if (object.networkMemberships) {
            if (!Array.isArray(object.networkMemberships))
                throw TypeError(".GetNetworkMembershipsResponse.networkMemberships: array expected");
            message.networkMemberships = [];
            for (let i = 0; i < object.networkMemberships.length; ++i) {
                if (typeof object.networkMemberships[i] !== "object")
                    throw TypeError(".GetNetworkMembershipsResponse.networkMemberships: object expected");
                message.networkMemberships[i] = $root.NetworkMembership.fromObject(object.networkMemberships[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetNetworkMembershipsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkMembershipsResponse
     * @static
     * @param {GetNetworkMembershipsResponse} message GetNetworkMembershipsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkMembershipsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.networkMemberships = [];
        if (message.networkMemberships && message.networkMemberships.length) {
            object.networkMemberships = [];
            for (let j = 0; j < message.networkMemberships.length; ++j)
                object.networkMemberships[j] = $root.NetworkMembership.toObject(message.networkMemberships[j], options);
        }
        return object;
    };

    /**
     * Converts this GetNetworkMembershipsResponse to JSON.
     * @function toJSON
     * @memberof GetNetworkMembershipsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkMembershipsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkMembershipsResponse;
})();

export const DeleteNetworkMembershipRequest = $root.DeleteNetworkMembershipRequest = (() => {

    /**
     * Properties of a DeleteNetworkMembershipRequest.
     * @exports IDeleteNetworkMembershipRequest
     * @interface IDeleteNetworkMembershipRequest
     * @property {number|null} [id] DeleteNetworkMembershipRequest id
     */

    /**
     * Constructs a new DeleteNetworkMembershipRequest.
     * @exports DeleteNetworkMembershipRequest
     * @classdesc Represents a DeleteNetworkMembershipRequest.
     * @implements IDeleteNetworkMembershipRequest
     * @constructor
     * @param {IDeleteNetworkMembershipRequest=} [properties] Properties to set
     */
    function DeleteNetworkMembershipRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteNetworkMembershipRequest id.
     * @member {number} id
     * @memberof DeleteNetworkMembershipRequest
     * @instance
     */
    DeleteNetworkMembershipRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteNetworkMembershipRequest instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {IDeleteNetworkMembershipRequest=} [properties] Properties to set
     * @returns {DeleteNetworkMembershipRequest} DeleteNetworkMembershipRequest instance
     */
    DeleteNetworkMembershipRequest.create = function create(properties) {
        return new DeleteNetworkMembershipRequest(properties);
    };

    /**
     * Encodes the specified DeleteNetworkMembershipRequest message. Does not implicitly {@link DeleteNetworkMembershipRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {IDeleteNetworkMembershipRequest} message DeleteNetworkMembershipRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkMembershipRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkMembershipRequest message, length delimited. Does not implicitly {@link DeleteNetworkMembershipRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {IDeleteNetworkMembershipRequest} message DeleteNetworkMembershipRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkMembershipRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkMembershipRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkMembershipRequest} DeleteNetworkMembershipRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkMembershipRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkMembershipRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkMembershipRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkMembershipRequest} DeleteNetworkMembershipRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkMembershipRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkMembershipRequest message.
     * @function verify
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkMembershipRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkMembershipRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkMembershipRequest} DeleteNetworkMembershipRequest
     */
    DeleteNetworkMembershipRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkMembershipRequest)
            return object;
        let message = new $root.DeleteNetworkMembershipRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteNetworkMembershipRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkMembershipRequest
     * @static
     * @param {DeleteNetworkMembershipRequest} message DeleteNetworkMembershipRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkMembershipRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteNetworkMembershipRequest to JSON.
     * @function toJSON
     * @memberof DeleteNetworkMembershipRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkMembershipRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkMembershipRequest;
})();

export const DeleteNetworkMembershipResponse = $root.DeleteNetworkMembershipResponse = (() => {

    /**
     * Properties of a DeleteNetworkMembershipResponse.
     * @exports IDeleteNetworkMembershipResponse
     * @interface IDeleteNetworkMembershipResponse
     */

    /**
     * Constructs a new DeleteNetworkMembershipResponse.
     * @exports DeleteNetworkMembershipResponse
     * @classdesc Represents a DeleteNetworkMembershipResponse.
     * @implements IDeleteNetworkMembershipResponse
     * @constructor
     * @param {IDeleteNetworkMembershipResponse=} [properties] Properties to set
     */
    function DeleteNetworkMembershipResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteNetworkMembershipResponse instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {IDeleteNetworkMembershipResponse=} [properties] Properties to set
     * @returns {DeleteNetworkMembershipResponse} DeleteNetworkMembershipResponse instance
     */
    DeleteNetworkMembershipResponse.create = function create(properties) {
        return new DeleteNetworkMembershipResponse(properties);
    };

    /**
     * Encodes the specified DeleteNetworkMembershipResponse message. Does not implicitly {@link DeleteNetworkMembershipResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {IDeleteNetworkMembershipResponse} message DeleteNetworkMembershipResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkMembershipResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkMembershipResponse message, length delimited. Does not implicitly {@link DeleteNetworkMembershipResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {IDeleteNetworkMembershipResponse} message DeleteNetworkMembershipResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkMembershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkMembershipResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkMembershipResponse} DeleteNetworkMembershipResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkMembershipResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkMembershipResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkMembershipResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkMembershipResponse} DeleteNetworkMembershipResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkMembershipResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkMembershipResponse message.
     * @function verify
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkMembershipResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkMembershipResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkMembershipResponse} DeleteNetworkMembershipResponse
     */
    DeleteNetworkMembershipResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkMembershipResponse)
            return object;
        return new $root.DeleteNetworkMembershipResponse();
    };

    /**
     * Creates a plain object from a DeleteNetworkMembershipResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkMembershipResponse
     * @static
     * @param {DeleteNetworkMembershipResponse} message DeleteNetworkMembershipResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkMembershipResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteNetworkMembershipResponse to JSON.
     * @function toJSON
     * @memberof DeleteNetworkMembershipResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkMembershipResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkMembershipResponse;
})();

export const CreateBootstrapClientRequest = $root.CreateBootstrapClientRequest = (() => {

    /**
     * Properties of a CreateBootstrapClientRequest.
     * @exports ICreateBootstrapClientRequest
     * @interface ICreateBootstrapClientRequest
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] CreateBootstrapClientRequest websocketOptions
     */

    /**
     * Constructs a new CreateBootstrapClientRequest.
     * @exports CreateBootstrapClientRequest
     * @classdesc Represents a CreateBootstrapClientRequest.
     * @implements ICreateBootstrapClientRequest
     * @constructor
     * @param {ICreateBootstrapClientRequest=} [properties] Properties to set
     */
    function CreateBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateBootstrapClientRequest websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof CreateBootstrapClientRequest
     * @instance
     */
    CreateBootstrapClientRequest.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CreateBootstrapClientRequest clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof CreateBootstrapClientRequest
     * @instance
     */
    Object.defineProperty(CreateBootstrapClientRequest.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CreateBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest=} [properties] Properties to set
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest instance
     */
    CreateBootstrapClientRequest.create = function create(properties) {
        return new CreateBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified CreateBootstrapClientRequest message. Does not implicitly {@link CreateBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest} message CreateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateBootstrapClientRequest message, length delimited. Does not implicitly {@link CreateBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest} message CreateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateBootstrapClientRequest message.
     * @function verify
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CreateBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     */
    CreateBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateBootstrapClientRequest)
            return object;
        let message = new $root.CreateBootstrapClientRequest();
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".CreateBootstrapClientRequest.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {CreateBootstrapClientRequest} message CreateBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this CreateBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof CreateBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateBootstrapClientRequest;
})();

export const CreateBootstrapClientResponse = $root.CreateBootstrapClientResponse = (() => {

    /**
     * Properties of a CreateBootstrapClientResponse.
     * @exports ICreateBootstrapClientResponse
     * @interface ICreateBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] CreateBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new CreateBootstrapClientResponse.
     * @exports CreateBootstrapClientResponse
     * @classdesc Represents a CreateBootstrapClientResponse.
     * @implements ICreateBootstrapClientResponse
     * @constructor
     * @param {ICreateBootstrapClientResponse=} [properties] Properties to set
     */
    function CreateBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof CreateBootstrapClientResponse
     * @instance
     */
    CreateBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new CreateBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse=} [properties] Properties to set
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse instance
     */
    CreateBootstrapClientResponse.create = function create(properties) {
        return new CreateBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified CreateBootstrapClientResponse message. Does not implicitly {@link CreateBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse} message CreateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateBootstrapClientResponse message, length delimited. Does not implicitly {@link CreateBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse} message CreateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateBootstrapClientResponse message.
     * @function verify
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates a CreateBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     */
    CreateBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateBootstrapClientResponse)
            return object;
        let message = new $root.CreateBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".CreateBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {CreateBootstrapClientResponse} message CreateBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this CreateBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof CreateBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateBootstrapClientResponse;
})();

export const UpdateBootstrapClientRequest = $root.UpdateBootstrapClientRequest = (() => {

    /**
     * Properties of an UpdateBootstrapClientRequest.
     * @exports IUpdateBootstrapClientRequest
     * @interface IUpdateBootstrapClientRequest
     * @property {number|null} [id] UpdateBootstrapClientRequest id
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] UpdateBootstrapClientRequest websocketOptions
     */

    /**
     * Constructs a new UpdateBootstrapClientRequest.
     * @exports UpdateBootstrapClientRequest
     * @classdesc Represents an UpdateBootstrapClientRequest.
     * @implements IUpdateBootstrapClientRequest
     * @constructor
     * @param {IUpdateBootstrapClientRequest=} [properties] Properties to set
     */
    function UpdateBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateBootstrapClientRequest id.
     * @member {number} id
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    UpdateBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateBootstrapClientRequest websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    UpdateBootstrapClientRequest.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * UpdateBootstrapClientRequest clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    Object.defineProperty(UpdateBootstrapClientRequest.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new UpdateBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest=} [properties] Properties to set
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest instance
     */
    UpdateBootstrapClientRequest.create = function create(properties) {
        return new UpdateBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified UpdateBootstrapClientRequest message. Does not implicitly {@link UpdateBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest} message UpdateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateBootstrapClientRequest message, length delimited. Does not implicitly {@link UpdateBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest} message UpdateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateBootstrapClientRequest message.
     * @function verify
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates an UpdateBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     */
    UpdateBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateBootstrapClientRequest)
            return object;
        let message = new $root.UpdateBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".UpdateBootstrapClientRequest.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {UpdateBootstrapClientRequest} message UpdateBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this UpdateBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof UpdateBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateBootstrapClientRequest;
})();

export const UpdateBootstrapClientResponse = $root.UpdateBootstrapClientResponse = (() => {

    /**
     * Properties of an UpdateBootstrapClientResponse.
     * @exports IUpdateBootstrapClientResponse
     * @interface IUpdateBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] UpdateBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new UpdateBootstrapClientResponse.
     * @exports UpdateBootstrapClientResponse
     * @classdesc Represents an UpdateBootstrapClientResponse.
     * @implements IUpdateBootstrapClientResponse
     * @constructor
     * @param {IUpdateBootstrapClientResponse=} [properties] Properties to set
     */
    function UpdateBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof UpdateBootstrapClientResponse
     * @instance
     */
    UpdateBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new UpdateBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse=} [properties] Properties to set
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse instance
     */
    UpdateBootstrapClientResponse.create = function create(properties) {
        return new UpdateBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified UpdateBootstrapClientResponse message. Does not implicitly {@link UpdateBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse} message UpdateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateBootstrapClientResponse message, length delimited. Does not implicitly {@link UpdateBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse} message UpdateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateBootstrapClientResponse message.
     * @function verify
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     */
    UpdateBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateBootstrapClientResponse)
            return object;
        let message = new $root.UpdateBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".UpdateBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {UpdateBootstrapClientResponse} message UpdateBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this UpdateBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof UpdateBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateBootstrapClientResponse;
})();

export const DeleteBootstrapClientRequest = $root.DeleteBootstrapClientRequest = (() => {

    /**
     * Properties of a DeleteBootstrapClientRequest.
     * @exports IDeleteBootstrapClientRequest
     * @interface IDeleteBootstrapClientRequest
     * @property {number|null} [id] DeleteBootstrapClientRequest id
     */

    /**
     * Constructs a new DeleteBootstrapClientRequest.
     * @exports DeleteBootstrapClientRequest
     * @classdesc Represents a DeleteBootstrapClientRequest.
     * @implements IDeleteBootstrapClientRequest
     * @constructor
     * @param {IDeleteBootstrapClientRequest=} [properties] Properties to set
     */
    function DeleteBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteBootstrapClientRequest id.
     * @member {number} id
     * @memberof DeleteBootstrapClientRequest
     * @instance
     */
    DeleteBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest=} [properties] Properties to set
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest instance
     */
    DeleteBootstrapClientRequest.create = function create(properties) {
        return new DeleteBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified DeleteBootstrapClientRequest message. Does not implicitly {@link DeleteBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest} message DeleteBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteBootstrapClientRequest message, length delimited. Does not implicitly {@link DeleteBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest} message DeleteBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteBootstrapClientRequest message.
     * @function verify
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     */
    DeleteBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteBootstrapClientRequest)
            return object;
        let message = new $root.DeleteBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {DeleteBootstrapClientRequest} message DeleteBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof DeleteBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteBootstrapClientRequest;
})();

export const DeleteBootstrapClientResponse = $root.DeleteBootstrapClientResponse = (() => {

    /**
     * Properties of a DeleteBootstrapClientResponse.
     * @exports IDeleteBootstrapClientResponse
     * @interface IDeleteBootstrapClientResponse
     */

    /**
     * Constructs a new DeleteBootstrapClientResponse.
     * @exports DeleteBootstrapClientResponse
     * @classdesc Represents a DeleteBootstrapClientResponse.
     * @implements IDeleteBootstrapClientResponse
     * @constructor
     * @param {IDeleteBootstrapClientResponse=} [properties] Properties to set
     */
    function DeleteBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse=} [properties] Properties to set
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse instance
     */
    DeleteBootstrapClientResponse.create = function create(properties) {
        return new DeleteBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified DeleteBootstrapClientResponse message. Does not implicitly {@link DeleteBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse} message DeleteBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteBootstrapClientResponse message, length delimited. Does not implicitly {@link DeleteBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse} message DeleteBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteBootstrapClientResponse message.
     * @function verify
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     */
    DeleteBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteBootstrapClientResponse)
            return object;
        return new $root.DeleteBootstrapClientResponse();
    };

    /**
     * Creates a plain object from a DeleteBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {DeleteBootstrapClientResponse} message DeleteBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteBootstrapClientResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof DeleteBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteBootstrapClientResponse;
})();

export const GetBootstrapClientRequest = $root.GetBootstrapClientRequest = (() => {

    /**
     * Properties of a GetBootstrapClientRequest.
     * @exports IGetBootstrapClientRequest
     * @interface IGetBootstrapClientRequest
     * @property {number|null} [id] GetBootstrapClientRequest id
     */

    /**
     * Constructs a new GetBootstrapClientRequest.
     * @exports GetBootstrapClientRequest
     * @classdesc Represents a GetBootstrapClientRequest.
     * @implements IGetBootstrapClientRequest
     * @constructor
     * @param {IGetBootstrapClientRequest=} [properties] Properties to set
     */
    function GetBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapClientRequest id.
     * @member {number} id
     * @memberof GetBootstrapClientRequest
     * @instance
     */
    GetBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest=} [properties] Properties to set
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest instance
     */
    GetBootstrapClientRequest.create = function create(properties) {
        return new GetBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientRequest message. Does not implicitly {@link GetBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest} message GetBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientRequest message, length delimited. Does not implicitly {@link GetBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest} message GetBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientRequest message.
     * @function verify
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     */
    GetBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientRequest)
            return object;
        let message = new $root.GetBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {GetBootstrapClientRequest} message GetBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientRequest;
})();

export const GetBootstrapClientResponse = $root.GetBootstrapClientResponse = (() => {

    /**
     * Properties of a GetBootstrapClientResponse.
     * @exports IGetBootstrapClientResponse
     * @interface IGetBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] GetBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new GetBootstrapClientResponse.
     * @exports GetBootstrapClientResponse
     * @classdesc Represents a GetBootstrapClientResponse.
     * @implements IGetBootstrapClientResponse
     * @constructor
     * @param {IGetBootstrapClientResponse=} [properties] Properties to set
     */
    function GetBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof GetBootstrapClientResponse
     * @instance
     */
    GetBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new GetBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse=} [properties] Properties to set
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse instance
     */
    GetBootstrapClientResponse.create = function create(properties) {
        return new GetBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientResponse message. Does not implicitly {@link GetBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse} message GetBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientResponse message, length delimited. Does not implicitly {@link GetBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse} message GetBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientResponse message.
     * @function verify
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates a GetBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     */
    GetBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientResponse)
            return object;
        let message = new $root.GetBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".GetBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {GetBootstrapClientResponse} message GetBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this GetBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientResponse;
})();

export const GetBootstrapClientsRequest = $root.GetBootstrapClientsRequest = (() => {

    /**
     * Properties of a GetBootstrapClientsRequest.
     * @exports IGetBootstrapClientsRequest
     * @interface IGetBootstrapClientsRequest
     */

    /**
     * Constructs a new GetBootstrapClientsRequest.
     * @exports GetBootstrapClientsRequest
     * @classdesc Represents a GetBootstrapClientsRequest.
     * @implements IGetBootstrapClientsRequest
     * @constructor
     * @param {IGetBootstrapClientsRequest=} [properties] Properties to set
     */
    function GetBootstrapClientsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetBootstrapClientsRequest instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {IGetBootstrapClientsRequest=} [properties] Properties to set
     * @returns {GetBootstrapClientsRequest} GetBootstrapClientsRequest instance
     */
    GetBootstrapClientsRequest.create = function create(properties) {
        return new GetBootstrapClientsRequest(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientsRequest message. Does not implicitly {@link GetBootstrapClientsRequest.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {IGetBootstrapClientsRequest} message GetBootstrapClientsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientsRequest message, length delimited. Does not implicitly {@link GetBootstrapClientsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {IGetBootstrapClientsRequest} message GetBootstrapClientsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientsRequest} GetBootstrapClientsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientsRequest} GetBootstrapClientsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientsRequest message.
     * @function verify
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetBootstrapClientsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientsRequest} GetBootstrapClientsRequest
     */
    GetBootstrapClientsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientsRequest)
            return object;
        return new $root.GetBootstrapClientsRequest();
    };

    /**
     * Creates a plain object from a GetBootstrapClientsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientsRequest
     * @static
     * @param {GetBootstrapClientsRequest} message GetBootstrapClientsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetBootstrapClientsRequest to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientsRequest;
})();

export const GetBootstrapClientsResponse = $root.GetBootstrapClientsResponse = (() => {

    /**
     * Properties of a GetBootstrapClientsResponse.
     * @exports IGetBootstrapClientsResponse
     * @interface IGetBootstrapClientsResponse
     * @property {Array.<IBootstrapClient>|null} [bootstrapClients] GetBootstrapClientsResponse bootstrapClients
     */

    /**
     * Constructs a new GetBootstrapClientsResponse.
     * @exports GetBootstrapClientsResponse
     * @classdesc Represents a GetBootstrapClientsResponse.
     * @implements IGetBootstrapClientsResponse
     * @constructor
     * @param {IGetBootstrapClientsResponse=} [properties] Properties to set
     */
    function GetBootstrapClientsResponse(properties) {
        this.bootstrapClients = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapClientsResponse bootstrapClients.
     * @member {Array.<IBootstrapClient>} bootstrapClients
     * @memberof GetBootstrapClientsResponse
     * @instance
     */
    GetBootstrapClientsResponse.prototype.bootstrapClients = $util.emptyArray;

    /**
     * Creates a new GetBootstrapClientsResponse instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {IGetBootstrapClientsResponse=} [properties] Properties to set
     * @returns {GetBootstrapClientsResponse} GetBootstrapClientsResponse instance
     */
    GetBootstrapClientsResponse.create = function create(properties) {
        return new GetBootstrapClientsResponse(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientsResponse message. Does not implicitly {@link GetBootstrapClientsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {IGetBootstrapClientsResponse} message GetBootstrapClientsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClients != null && message.bootstrapClients.length)
            for (let i = 0; i < message.bootstrapClients.length; ++i)
                $root.BootstrapClient.encode(message.bootstrapClients[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientsResponse message, length delimited. Does not implicitly {@link GetBootstrapClientsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {IGetBootstrapClientsResponse} message GetBootstrapClientsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientsResponse} GetBootstrapClientsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.bootstrapClients && message.bootstrapClients.length))
                    message.bootstrapClients = [];
                message.bootstrapClients.push($root.BootstrapClient.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientsResponse} GetBootstrapClientsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientsResponse message.
     * @function verify
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClients != null && message.hasOwnProperty("bootstrapClients")) {
            if (!Array.isArray(message.bootstrapClients))
                return "bootstrapClients: array expected";
            for (let i = 0; i < message.bootstrapClients.length; ++i) {
                let error = $root.BootstrapClient.verify(message.bootstrapClients[i]);
                if (error)
                    return "bootstrapClients." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetBootstrapClientsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientsResponse} GetBootstrapClientsResponse
     */
    GetBootstrapClientsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientsResponse)
            return object;
        let message = new $root.GetBootstrapClientsResponse();
        if (object.bootstrapClients) {
            if (!Array.isArray(object.bootstrapClients))
                throw TypeError(".GetBootstrapClientsResponse.bootstrapClients: array expected");
            message.bootstrapClients = [];
            for (let i = 0; i < object.bootstrapClients.length; ++i) {
                if (typeof object.bootstrapClients[i] !== "object")
                    throw TypeError(".GetBootstrapClientsResponse.bootstrapClients: object expected");
                message.bootstrapClients[i] = $root.BootstrapClient.fromObject(object.bootstrapClients[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapClientsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientsResponse
     * @static
     * @param {GetBootstrapClientsResponse} message GetBootstrapClientsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.bootstrapClients = [];
        if (message.bootstrapClients && message.bootstrapClients.length) {
            object.bootstrapClients = [];
            for (let j = 0; j < message.bootstrapClients.length; ++j)
                object.bootstrapClients[j] = $root.BootstrapClient.toObject(message.bootstrapClients[j], options);
        }
        return object;
    };

    /**
     * Converts this GetBootstrapClientsResponse to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientsResponse;
})();

export const GetBootstrapPeersRequest = $root.GetBootstrapPeersRequest = (() => {

    /**
     * Properties of a GetBootstrapPeersRequest.
     * @exports IGetBootstrapPeersRequest
     * @interface IGetBootstrapPeersRequest
     */

    /**
     * Constructs a new GetBootstrapPeersRequest.
     * @exports GetBootstrapPeersRequest
     * @classdesc Represents a GetBootstrapPeersRequest.
     * @implements IGetBootstrapPeersRequest
     * @constructor
     * @param {IGetBootstrapPeersRequest=} [properties] Properties to set
     */
    function GetBootstrapPeersRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetBootstrapPeersRequest instance using the specified properties.
     * @function create
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {IGetBootstrapPeersRequest=} [properties] Properties to set
     * @returns {GetBootstrapPeersRequest} GetBootstrapPeersRequest instance
     */
    GetBootstrapPeersRequest.create = function create(properties) {
        return new GetBootstrapPeersRequest(properties);
    };

    /**
     * Encodes the specified GetBootstrapPeersRequest message. Does not implicitly {@link GetBootstrapPeersRequest.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {IGetBootstrapPeersRequest} message GetBootstrapPeersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapPeersRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapPeersRequest message, length delimited. Does not implicitly {@link GetBootstrapPeersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {IGetBootstrapPeersRequest} message GetBootstrapPeersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapPeersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapPeersRequest} GetBootstrapPeersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapPeersRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapPeersRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapPeersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapPeersRequest} GetBootstrapPeersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapPeersRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapPeersRequest message.
     * @function verify
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapPeersRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetBootstrapPeersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapPeersRequest} GetBootstrapPeersRequest
     */
    GetBootstrapPeersRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapPeersRequest)
            return object;
        return new $root.GetBootstrapPeersRequest();
    };

    /**
     * Creates a plain object from a GetBootstrapPeersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapPeersRequest
     * @static
     * @param {GetBootstrapPeersRequest} message GetBootstrapPeersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapPeersRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetBootstrapPeersRequest to JSON.
     * @function toJSON
     * @memberof GetBootstrapPeersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapPeersRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapPeersRequest;
})();

export const GetBootstrapPeersResponse = $root.GetBootstrapPeersResponse = (() => {

    /**
     * Properties of a GetBootstrapPeersResponse.
     * @exports IGetBootstrapPeersResponse
     * @interface IGetBootstrapPeersResponse
     * @property {Array.<IBootstrapPeer>|null} [peers] GetBootstrapPeersResponse peers
     */

    /**
     * Constructs a new GetBootstrapPeersResponse.
     * @exports GetBootstrapPeersResponse
     * @classdesc Represents a GetBootstrapPeersResponse.
     * @implements IGetBootstrapPeersResponse
     * @constructor
     * @param {IGetBootstrapPeersResponse=} [properties] Properties to set
     */
    function GetBootstrapPeersResponse(properties) {
        this.peers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapPeersResponse peers.
     * @member {Array.<IBootstrapPeer>} peers
     * @memberof GetBootstrapPeersResponse
     * @instance
     */
    GetBootstrapPeersResponse.prototype.peers = $util.emptyArray;

    /**
     * Creates a new GetBootstrapPeersResponse instance using the specified properties.
     * @function create
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {IGetBootstrapPeersResponse=} [properties] Properties to set
     * @returns {GetBootstrapPeersResponse} GetBootstrapPeersResponse instance
     */
    GetBootstrapPeersResponse.create = function create(properties) {
        return new GetBootstrapPeersResponse(properties);
    };

    /**
     * Encodes the specified GetBootstrapPeersResponse message. Does not implicitly {@link GetBootstrapPeersResponse.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {IGetBootstrapPeersResponse} message GetBootstrapPeersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapPeersResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peers != null && message.peers.length)
            for (let i = 0; i < message.peers.length; ++i)
                $root.BootstrapPeer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapPeersResponse message, length delimited. Does not implicitly {@link GetBootstrapPeersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {IGetBootstrapPeersResponse} message GetBootstrapPeersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapPeersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapPeersResponse} GetBootstrapPeersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapPeersResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapPeersResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.peers && message.peers.length))
                    message.peers = [];
                message.peers.push($root.BootstrapPeer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapPeersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapPeersResponse} GetBootstrapPeersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapPeersResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapPeersResponse message.
     * @function verify
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapPeersResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peers != null && message.hasOwnProperty("peers")) {
            if (!Array.isArray(message.peers))
                return "peers: array expected";
            for (let i = 0; i < message.peers.length; ++i) {
                let error = $root.BootstrapPeer.verify(message.peers[i]);
                if (error)
                    return "peers." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetBootstrapPeersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapPeersResponse} GetBootstrapPeersResponse
     */
    GetBootstrapPeersResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapPeersResponse)
            return object;
        let message = new $root.GetBootstrapPeersResponse();
        if (object.peers) {
            if (!Array.isArray(object.peers))
                throw TypeError(".GetBootstrapPeersResponse.peers: array expected");
            message.peers = [];
            for (let i = 0; i < object.peers.length; ++i) {
                if (typeof object.peers[i] !== "object")
                    throw TypeError(".GetBootstrapPeersResponse.peers: object expected");
                message.peers[i] = $root.BootstrapPeer.fromObject(object.peers[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapPeersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapPeersResponse
     * @static
     * @param {GetBootstrapPeersResponse} message GetBootstrapPeersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapPeersResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.peers = [];
        if (message.peers && message.peers.length) {
            object.peers = [];
            for (let j = 0; j < message.peers.length; ++j)
                object.peers[j] = $root.BootstrapPeer.toObject(message.peers[j], options);
        }
        return object;
    };

    /**
     * Converts this GetBootstrapPeersResponse to JSON.
     * @function toJSON
     * @memberof GetBootstrapPeersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapPeersResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapPeersResponse;
})();

export const BootstrapPeer = $root.BootstrapPeer = (() => {

    /**
     * Properties of a BootstrapPeer.
     * @exports IBootstrapPeer
     * @interface IBootstrapPeer
     * @property {Uint8Array|null} [key] BootstrapPeer key
     * @property {string|null} [label] BootstrapPeer label
     */

    /**
     * Constructs a new BootstrapPeer.
     * @exports BootstrapPeer
     * @classdesc Represents a BootstrapPeer.
     * @implements IBootstrapPeer
     * @constructor
     * @param {IBootstrapPeer=} [properties] Properties to set
     */
    function BootstrapPeer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapPeer key.
     * @member {Uint8Array} key
     * @memberof BootstrapPeer
     * @instance
     */
    BootstrapPeer.prototype.key = $util.newBuffer([]);

    /**
     * BootstrapPeer label.
     * @member {string} label
     * @memberof BootstrapPeer
     * @instance
     */
    BootstrapPeer.prototype.label = "";

    /**
     * Creates a new BootstrapPeer instance using the specified properties.
     * @function create
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer=} [properties] Properties to set
     * @returns {BootstrapPeer} BootstrapPeer instance
     */
    BootstrapPeer.create = function create(properties) {
        return new BootstrapPeer(properties);
    };

    /**
     * Encodes the specified BootstrapPeer message. Does not implicitly {@link BootstrapPeer.verify|verify} messages.
     * @function encode
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer} message BootstrapPeer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapPeer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
        return writer;
    };

    /**
     * Encodes the specified BootstrapPeer message, length delimited. Does not implicitly {@link BootstrapPeer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer} message BootstrapPeer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapPeer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapPeer message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapPeer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapPeer} BootstrapPeer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapPeer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapPeer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.label = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapPeer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapPeer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapPeer} BootstrapPeer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapPeer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapPeer message.
     * @function verify
     * @memberof BootstrapPeer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapPeer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        return null;
    };

    /**
     * Creates a BootstrapPeer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapPeer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapPeer} BootstrapPeer
     */
    BootstrapPeer.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapPeer)
            return object;
        let message = new $root.BootstrapPeer();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        if (object.label != null)
            message.label = String(object.label);
        return message;
    };

    /**
     * Creates a plain object from a BootstrapPeer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapPeer
     * @static
     * @param {BootstrapPeer} message BootstrapPeer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapPeer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.label = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        return object;
    };

    /**
     * Converts this BootstrapPeer to JSON.
     * @function toJSON
     * @memberof BootstrapPeer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapPeer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapPeer;
})();

export const PublishNetworkToBootstrapPeerRequest = $root.PublishNetworkToBootstrapPeerRequest = (() => {

    /**
     * Properties of a PublishNetworkToBootstrapPeerRequest.
     * @exports IPublishNetworkToBootstrapPeerRequest
     * @interface IPublishNetworkToBootstrapPeerRequest
     * @property {Uint8Array|null} [key] PublishNetworkToBootstrapPeerRequest key
     * @property {INetwork|null} [network] PublishNetworkToBootstrapPeerRequest network
     */

    /**
     * Constructs a new PublishNetworkToBootstrapPeerRequest.
     * @exports PublishNetworkToBootstrapPeerRequest
     * @classdesc Represents a PublishNetworkToBootstrapPeerRequest.
     * @implements IPublishNetworkToBootstrapPeerRequest
     * @constructor
     * @param {IPublishNetworkToBootstrapPeerRequest=} [properties] Properties to set
     */
    function PublishNetworkToBootstrapPeerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PublishNetworkToBootstrapPeerRequest key.
     * @member {Uint8Array} key
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     */
    PublishNetworkToBootstrapPeerRequest.prototype.key = $util.newBuffer([]);

    /**
     * PublishNetworkToBootstrapPeerRequest network.
     * @member {INetwork|null|undefined} network
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     */
    PublishNetworkToBootstrapPeerRequest.prototype.network = null;

    /**
     * Creates a new PublishNetworkToBootstrapPeerRequest instance using the specified properties.
     * @function create
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest=} [properties] Properties to set
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest instance
     */
    PublishNetworkToBootstrapPeerRequest.create = function create(properties) {
        return new PublishNetworkToBootstrapPeerRequest(properties);
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerRequest message. Does not implicitly {@link PublishNetworkToBootstrapPeerRequest.verify|verify} messages.
     * @function encode
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerRequest message, length delimited. Does not implicitly {@link PublishNetworkToBootstrapPeerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishNetworkToBootstrapPeerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishNetworkToBootstrapPeerRequest message.
     * @function verify
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishNetworkToBootstrapPeerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a PublishNetworkToBootstrapPeerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     */
    PublishNetworkToBootstrapPeerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishNetworkToBootstrapPeerRequest)
            return object;
        let message = new $root.PublishNetworkToBootstrapPeerRequest();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".PublishNetworkToBootstrapPeerRequest.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a PublishNetworkToBootstrapPeerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {PublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishNetworkToBootstrapPeerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.network = null;
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this PublishNetworkToBootstrapPeerRequest to JSON.
     * @function toJSON
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishNetworkToBootstrapPeerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishNetworkToBootstrapPeerRequest;
})();

export const PublishNetworkToBootstrapPeerResponse = $root.PublishNetworkToBootstrapPeerResponse = (() => {

    /**
     * Properties of a PublishNetworkToBootstrapPeerResponse.
     * @exports IPublishNetworkToBootstrapPeerResponse
     * @interface IPublishNetworkToBootstrapPeerResponse
     */

    /**
     * Constructs a new PublishNetworkToBootstrapPeerResponse.
     * @exports PublishNetworkToBootstrapPeerResponse
     * @classdesc Represents a PublishNetworkToBootstrapPeerResponse.
     * @implements IPublishNetworkToBootstrapPeerResponse
     * @constructor
     * @param {IPublishNetworkToBootstrapPeerResponse=} [properties] Properties to set
     */
    function PublishNetworkToBootstrapPeerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new PublishNetworkToBootstrapPeerResponse instance using the specified properties.
     * @function create
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse=} [properties] Properties to set
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse instance
     */
    PublishNetworkToBootstrapPeerResponse.create = function create(properties) {
        return new PublishNetworkToBootstrapPeerResponse(properties);
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerResponse message. Does not implicitly {@link PublishNetworkToBootstrapPeerResponse.verify|verify} messages.
     * @function encode
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerResponse message, length delimited. Does not implicitly {@link PublishNetworkToBootstrapPeerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishNetworkToBootstrapPeerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishNetworkToBootstrapPeerResponse message.
     * @function verify
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishNetworkToBootstrapPeerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a PublishNetworkToBootstrapPeerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     */
    PublishNetworkToBootstrapPeerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishNetworkToBootstrapPeerResponse)
            return object;
        return new $root.PublishNetworkToBootstrapPeerResponse();
    };

    /**
     * Creates a plain object from a PublishNetworkToBootstrapPeerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {PublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishNetworkToBootstrapPeerResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this PublishNetworkToBootstrapPeerResponse to JSON.
     * @function toJSON
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishNetworkToBootstrapPeerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishNetworkToBootstrapPeerResponse;
})();

export const PeerIndexMessage = $root.PeerIndexMessage = (() => {

    /**
     * Properties of a PeerIndexMessage.
     * @exports IPeerIndexMessage
     * @interface IPeerIndexMessage
     * @property {PeerIndexMessage.IPublish|null} [publish] PeerIndexMessage publish
     * @property {PeerIndexMessage.IUnpublish|null} [unpublish] PeerIndexMessage unpublish
     * @property {PeerIndexMessage.ISearchRequest|null} [searchRequest] PeerIndexMessage searchRequest
     * @property {PeerIndexMessage.ISearchResponse|null} [searchResponse] PeerIndexMessage searchResponse
     */

    /**
     * Constructs a new PeerIndexMessage.
     * @exports PeerIndexMessage
     * @classdesc Represents a PeerIndexMessage.
     * @implements IPeerIndexMessage
     * @constructor
     * @param {IPeerIndexMessage=} [properties] Properties to set
     */
    function PeerIndexMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerIndexMessage publish.
     * @member {PeerIndexMessage.IPublish|null|undefined} publish
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.publish = null;

    /**
     * PeerIndexMessage unpublish.
     * @member {PeerIndexMessage.IUnpublish|null|undefined} unpublish
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.unpublish = null;

    /**
     * PeerIndexMessage searchRequest.
     * @member {PeerIndexMessage.ISearchRequest|null|undefined} searchRequest
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.searchRequest = null;

    /**
     * PeerIndexMessage searchResponse.
     * @member {PeerIndexMessage.ISearchResponse|null|undefined} searchResponse
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.searchResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PeerIndexMessage body.
     * @member {"publish"|"unpublish"|"searchRequest"|"searchResponse"|undefined} body
     * @memberof PeerIndexMessage
     * @instance
     */
    Object.defineProperty(PeerIndexMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "searchRequest", "searchResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PeerIndexMessage instance using the specified properties.
     * @function create
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage=} [properties] Properties to set
     * @returns {PeerIndexMessage} PeerIndexMessage instance
     */
    PeerIndexMessage.create = function create(properties) {
        return new PeerIndexMessage(properties);
    };

    /**
     * Encodes the specified PeerIndexMessage message. Does not implicitly {@link PeerIndexMessage.verify|verify} messages.
     * @function encode
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage} message PeerIndexMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerIndexMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.PeerIndexMessage.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.PeerIndexMessage.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.searchRequest != null && Object.hasOwnProperty.call(message, "searchRequest"))
            $root.PeerIndexMessage.SearchRequest.encode(message.searchRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.searchResponse != null && Object.hasOwnProperty.call(message, "searchResponse"))
            $root.PeerIndexMessage.SearchResponse.encode(message.searchResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerIndexMessage message, length delimited. Does not implicitly {@link PeerIndexMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage} message PeerIndexMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerIndexMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerIndexMessage message from the specified reader or buffer.
     * @function decode
     * @memberof PeerIndexMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerIndexMessage} PeerIndexMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerIndexMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.PeerIndexMessage.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.PeerIndexMessage.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.searchRequest = $root.PeerIndexMessage.SearchRequest.decode(reader, reader.uint32());
                break;
            case 4:
                message.searchResponse = $root.PeerIndexMessage.SearchResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerIndexMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerIndexMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerIndexMessage} PeerIndexMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerIndexMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerIndexMessage message.
     * @function verify
     * @memberof PeerIndexMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerIndexMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.SearchRequest.verify(message.searchRequest);
                if (error)
                    return "searchRequest." + error;
            }
        }
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.SearchResponse.verify(message.searchResponse);
                if (error)
                    return "searchResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PeerIndexMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerIndexMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerIndexMessage} PeerIndexMessage
     */
    PeerIndexMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerIndexMessage)
            return object;
        let message = new $root.PeerIndexMessage();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".PeerIndexMessage.publish: object expected");
            message.publish = $root.PeerIndexMessage.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".PeerIndexMessage.unpublish: object expected");
            message.unpublish = $root.PeerIndexMessage.Unpublish.fromObject(object.unpublish);
        }
        if (object.searchRequest != null) {
            if (typeof object.searchRequest !== "object")
                throw TypeError(".PeerIndexMessage.searchRequest: object expected");
            message.searchRequest = $root.PeerIndexMessage.SearchRequest.fromObject(object.searchRequest);
        }
        if (object.searchResponse != null) {
            if (typeof object.searchResponse !== "object")
                throw TypeError(".PeerIndexMessage.searchResponse: object expected");
            message.searchResponse = $root.PeerIndexMessage.SearchResponse.fromObject(object.searchResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerIndexMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerIndexMessage
     * @static
     * @param {PeerIndexMessage} message PeerIndexMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerIndexMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.PeerIndexMessage.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.PeerIndexMessage.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
            object.searchRequest = $root.PeerIndexMessage.SearchRequest.toObject(message.searchRequest, options);
            if (options.oneofs)
                object.body = "searchRequest";
        }
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
            object.searchResponse = $root.PeerIndexMessage.SearchResponse.toObject(message.searchResponse, options);
            if (options.oneofs)
                object.body = "searchResponse";
        }
        return object;
    };

    /**
     * Converts this PeerIndexMessage to JSON.
     * @function toJSON
     * @memberof PeerIndexMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerIndexMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PeerIndexMessage.Record = (function() {

        /**
         * Properties of a Record.
         * @memberof PeerIndexMessage
         * @interface IRecord
         * @property {Uint8Array|null} [hash] Record hash
         * @property {Uint8Array|null} [key] Record key
         * @property {Uint8Array|null} [hostId] Record hostId
         * @property {number|null} [port] Record port
         * @property {number|null} [timestamp] Record timestamp
         * @property {Uint8Array|null} [signature] Record signature
         */

        /**
         * Constructs a new Record.
         * @memberof PeerIndexMessage
         * @classdesc Represents a Record.
         * @implements IRecord
         * @constructor
         * @param {PeerIndexMessage.IRecord=} [properties] Properties to set
         */
        function Record(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Record hash.
         * @member {Uint8Array} hash
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.hash = $util.newBuffer([]);

        /**
         * Record key.
         * @member {Uint8Array} key
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.key = $util.newBuffer([]);

        /**
         * Record hostId.
         * @member {Uint8Array} hostId
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.hostId = $util.newBuffer([]);

        /**
         * Record port.
         * @member {number} port
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.port = 0;

        /**
         * Record timestamp.
         * @member {number} timestamp
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Record signature.
         * @member {Uint8Array} signature
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Record instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord=} [properties] Properties to set
         * @returns {PeerIndexMessage.Record} Record instance
         */
        Record.create = function create(properties) {
            return new Record(properties);
        };

        /**
         * Encodes the specified Record message. Does not implicitly {@link PeerIndexMessage.Record.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hostId);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.port);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified Record message, length delimited. Does not implicitly {@link PeerIndexMessage.Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Record message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Record();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                case 3:
                    message.hostId = reader.bytes();
                    break;
                case 4:
                    message.port = reader.uint32();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Record message.
         * @function verify
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Record.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.hostId != null && message.hasOwnProperty("hostId"))
                if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                    return "hostId: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Record} Record
         */
        Record.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Record)
                return object;
            let message = new $root.PeerIndexMessage.Record();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.hostId != null)
                if (typeof object.hostId === "string")
                    $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
                else if (object.hostId.length)
                    message.hostId = object.hostId;
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.Record} message Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.hostId = "";
                else {
                    object.hostId = [];
                    if (options.bytes !== Array)
                        object.hostId = $util.newBuffer(object.hostId);
                }
                object.port = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.hostId != null && message.hasOwnProperty("hostId"))
                object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this Record to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Record;
    })();

    PeerIndexMessage.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof PeerIndexMessage
         * @interface IPublish
         * @property {PeerIndexMessage.IRecord|null} [record] Publish record
         */

        /**
         * Constructs a new Publish.
         * @memberof PeerIndexMessage
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {PeerIndexMessage.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish record.
         * @member {PeerIndexMessage.IRecord|null|undefined} record
         * @memberof PeerIndexMessage.Publish
         * @instance
         */
        Publish.prototype.record = null;

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish=} [properties] Properties to set
         * @returns {PeerIndexMessage.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link PeerIndexMessage.Publish.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.PeerIndexMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link PeerIndexMessage.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.PeerIndexMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.PeerIndexMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Publish)
                return object;
            let message = new $root.PeerIndexMessage.Publish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".PeerIndexMessage.Publish.record: object expected");
                message.record = $root.PeerIndexMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.PeerIndexMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    PeerIndexMessage.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof PeerIndexMessage
         * @interface IUnpublish
         * @property {PeerIndexMessage.IRecord|null} [record] Unpublish record
         */

        /**
         * Constructs a new Unpublish.
         * @memberof PeerIndexMessage
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {PeerIndexMessage.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish record.
         * @member {PeerIndexMessage.IRecord|null|undefined} record
         * @memberof PeerIndexMessage.Unpublish
         * @instance
         */
        Unpublish.prototype.record = null;

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish=} [properties] Properties to set
         * @returns {PeerIndexMessage.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link PeerIndexMessage.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.PeerIndexMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link PeerIndexMessage.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.PeerIndexMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.PeerIndexMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Unpublish)
                return object;
            let message = new $root.PeerIndexMessage.Unpublish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".PeerIndexMessage.Unpublish.record: object expected");
                message.record = $root.PeerIndexMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.PeerIndexMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    PeerIndexMessage.SearchRequest = (function() {

        /**
         * Properties of a SearchRequest.
         * @memberof PeerIndexMessage
         * @interface ISearchRequest
         * @property {number|null} [requestId] SearchRequest requestId
         * @property {Uint8Array|null} [hash] SearchRequest hash
         */

        /**
         * Constructs a new SearchRequest.
         * @memberof PeerIndexMessage
         * @classdesc Represents a SearchRequest.
         * @implements ISearchRequest
         * @constructor
         * @param {PeerIndexMessage.ISearchRequest=} [properties] Properties to set
         */
        function SearchRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchRequest requestId.
         * @member {number} requestId
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         */
        SearchRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SearchRequest hash.
         * @member {Uint8Array} hash
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         */
        SearchRequest.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new SearchRequest instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest=} [properties] Properties to set
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest instance
         */
        SearchRequest.create = function create(properties) {
            return new SearchRequest(properties);
        };

        /**
         * Encodes the specified SearchRequest message. Does not implicitly {@link PeerIndexMessage.SearchRequest.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified SearchRequest message, length delimited. Does not implicitly {@link PeerIndexMessage.SearchRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.SearchRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchRequest message.
         * @function verify
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         */
        SearchRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.SearchRequest)
                return object;
            let message = new $root.PeerIndexMessage.SearchRequest();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.SearchRequest} message SearchRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this SearchRequest to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchRequest;
    })();

    PeerIndexMessage.SearchResponse = (function() {

        /**
         * Properties of a SearchResponse.
         * @memberof PeerIndexMessage
         * @interface ISearchResponse
         * @property {number|null} [requestId] SearchResponse requestId
         * @property {Array.<PeerIndexMessage.IRecord>|null} [records] SearchResponse records
         */

        /**
         * Constructs a new SearchResponse.
         * @memberof PeerIndexMessage
         * @classdesc Represents a SearchResponse.
         * @implements ISearchResponse
         * @constructor
         * @param {PeerIndexMessage.ISearchResponse=} [properties] Properties to set
         */
        function SearchResponse(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchResponse requestId.
         * @member {number} requestId
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         */
        SearchResponse.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SearchResponse records.
         * @member {Array.<PeerIndexMessage.IRecord>} records
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         */
        SearchResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new SearchResponse instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse=} [properties] Properties to set
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse instance
         */
        SearchResponse.create = function create(properties) {
            return new SearchResponse(properties);
        };

        /**
         * Encodes the specified SearchResponse message. Does not implicitly {@link PeerIndexMessage.SearchResponse.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    $root.PeerIndexMessage.Record.encode(message.records[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link PeerIndexMessage.SearchResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.SearchResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.PeerIndexMessage.Record.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchResponse message.
         * @function verify
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i) {
                    let error = $root.PeerIndexMessage.Record.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         */
        SearchResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.SearchResponse)
                return object;
            let message = new $root.PeerIndexMessage.SearchResponse();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".PeerIndexMessage.SearchResponse.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".PeerIndexMessage.SearchResponse.records: object expected");
                    message.records[i] = $root.PeerIndexMessage.Record.fromObject(object.records[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.SearchResponse} message SearchResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.PeerIndexMessage.Record.toObject(message.records[j], options);
            }
            return object;
        };

        /**
         * Converts this SearchResponse to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchResponse;
    })();

    return PeerIndexMessage;
})();

export const ChatMessage = $root.ChatMessage = (() => {

    /**
     * Properties of a ChatMessage.
     * @exports IChatMessage
     * @interface IChatMessage
     * @property {ChatMessage.IMessageRequest|null} [message] ChatMessage message
     */

    /**
     * Constructs a new ChatMessage.
     * @exports ChatMessage
     * @classdesc Represents a ChatMessage.
     * @implements IChatMessage
     * @constructor
     * @param {IChatMessage=} [properties] Properties to set
     */
    function ChatMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatMessage message.
     * @member {ChatMessage.IMessageRequest|null|undefined} message
     * @memberof ChatMessage
     * @instance
     */
    ChatMessage.prototype.message = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * ChatMessage body.
     * @member {"message"|undefined} body
     * @memberof ChatMessage
     * @instance
     */
    Object.defineProperty(ChatMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["message"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new ChatMessage instance using the specified properties.
     * @function create
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage=} [properties] Properties to set
     * @returns {ChatMessage} ChatMessage instance
     */
    ChatMessage.create = function create(properties) {
        return new ChatMessage(properties);
    };

    /**
     * Encodes the specified ChatMessage message. Does not implicitly {@link ChatMessage.verify|verify} messages.
     * @function encode
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage} message ChatMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.ChatMessage.MessageRequest.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatMessage message, length delimited. Does not implicitly {@link ChatMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage} message ChatMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatMessage message from the specified reader or buffer.
     * @function decode
     * @memberof ChatMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatMessage} ChatMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = $root.ChatMessage.MessageRequest.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatMessage} ChatMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatMessage message.
     * @function verify
     * @memberof ChatMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.message != null && message.hasOwnProperty("message")) {
            properties.body = 1;
            {
                let error = $root.ChatMessage.MessageRequest.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatMessage} ChatMessage
     */
    ChatMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatMessage)
            return object;
        let message = new $root.ChatMessage();
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".ChatMessage.message: object expected");
            message.message = $root.ChatMessage.MessageRequest.fromObject(object.message);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatMessage
     * @static
     * @param {ChatMessage} message ChatMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.ChatMessage.MessageRequest.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        return object;
    };

    /**
     * Converts this ChatMessage to JSON.
     * @function toJSON
     * @memberof ChatMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ChatMessage.MessageRequest = (function() {

        /**
         * Properties of a MessageRequest.
         * @memberof ChatMessage
         * @interface IMessageRequest
         * @property {string|null} [body] MessageRequest body
         */

        /**
         * Constructs a new MessageRequest.
         * @memberof ChatMessage
         * @classdesc Represents a MessageRequest.
         * @implements IMessageRequest
         * @constructor
         * @param {ChatMessage.IMessageRequest=} [properties] Properties to set
         */
        function MessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageRequest body.
         * @member {string} body
         * @memberof ChatMessage.MessageRequest
         * @instance
         */
        MessageRequest.prototype.body = "";

        /**
         * Creates a new MessageRequest instance using the specified properties.
         * @function create
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {ChatMessage.IMessageRequest=} [properties] Properties to set
         * @returns {ChatMessage.MessageRequest} MessageRequest instance
         */
        MessageRequest.create = function create(properties) {
            return new MessageRequest(properties);
        };

        /**
         * Encodes the specified MessageRequest message. Does not implicitly {@link ChatMessage.MessageRequest.verify|verify} messages.
         * @function encode
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {ChatMessage.IMessageRequest} message MessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.body);
            return writer;
        };

        /**
         * Encodes the specified MessageRequest message, length delimited. Does not implicitly {@link ChatMessage.MessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {ChatMessage.IMessageRequest} message MessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatMessage.MessageRequest} MessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessage.MessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatMessage.MessageRequest} MessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageRequest message.
         * @function verify
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            return null;
        };

        /**
         * Creates a MessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatMessage.MessageRequest} MessageRequest
         */
        MessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatMessage.MessageRequest)
                return object;
            let message = new $root.ChatMessage.MessageRequest();
            if (object.body != null)
                message.body = String(object.body);
            return message;
        };

        /**
         * Creates a plain object from a MessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatMessage.MessageRequest
         * @static
         * @param {ChatMessage.MessageRequest} message MessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.body = "";
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            return object;
        };

        /**
         * Converts this MessageRequest to JSON.
         * @function toJSON
         * @memberof ChatMessage.MessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageRequest;
    })();

    return ChatMessage;
})();

export const ChatRoom = $root.ChatRoom = (() => {

    /**
     * Properties of a ChatRoom.
     * @exports IChatRoom
     * @interface IChatRoom
     * @property {string|null} [name] ChatRoom name
     */

    /**
     * Constructs a new ChatRoom.
     * @exports ChatRoom
     * @classdesc Represents a ChatRoom.
     * @implements IChatRoom
     * @constructor
     * @param {IChatRoom=} [properties] Properties to set
     */
    function ChatRoom(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatRoom name.
     * @member {string} name
     * @memberof ChatRoom
     * @instance
     */
    ChatRoom.prototype.name = "";

    /**
     * Creates a new ChatRoom instance using the specified properties.
     * @function create
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom=} [properties] Properties to set
     * @returns {ChatRoom} ChatRoom instance
     */
    ChatRoom.create = function create(properties) {
        return new ChatRoom(properties);
    };

    /**
     * Encodes the specified ChatRoom message. Does not implicitly {@link ChatRoom.verify|verify} messages.
     * @function encode
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom} message ChatRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatRoom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified ChatRoom message, length delimited. Does not implicitly {@link ChatRoom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom} message ChatRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatRoom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatRoom message from the specified reader or buffer.
     * @function decode
     * @memberof ChatRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatRoom} ChatRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatRoom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatRoom();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatRoom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatRoom} ChatRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatRoom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatRoom message.
     * @function verify
     * @memberof ChatRoom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatRoom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates a ChatRoom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatRoom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatRoom} ChatRoom
     */
    ChatRoom.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatRoom)
            return object;
        let message = new $root.ChatRoom();
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from a ChatRoom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatRoom
     * @static
     * @param {ChatRoom} message ChatRoom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatRoom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.name = "";
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this ChatRoom to JSON.
     * @function toJSON
     * @memberof ChatRoom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatRoom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatRoom;
})();

export const ChatServer = $root.ChatServer = (() => {

    /**
     * Properties of a ChatServer.
     * @exports IChatServer
     * @interface IChatServer
     * @property {number|null} [id] ChatServer id
     * @property {Uint8Array|null} [networkKey] ChatServer networkKey
     * @property {IChatRoom|null} [chatRoom] ChatServer chatRoom
     */

    /**
     * Constructs a new ChatServer.
     * @exports ChatServer
     * @classdesc Represents a ChatServer.
     * @implements IChatServer
     * @constructor
     * @param {IChatServer=} [properties] Properties to set
     */
    function ChatServer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatServer id.
     * @member {number} id
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ChatServer networkKey.
     * @member {Uint8Array} networkKey
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.networkKey = $util.newBuffer([]);

    /**
     * ChatServer chatRoom.
     * @member {IChatRoom|null|undefined} chatRoom
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.chatRoom = null;

    /**
     * Creates a new ChatServer instance using the specified properties.
     * @function create
     * @memberof ChatServer
     * @static
     * @param {IChatServer=} [properties] Properties to set
     * @returns {ChatServer} ChatServer instance
     */
    ChatServer.create = function create(properties) {
        return new ChatServer(properties);
    };

    /**
     * Encodes the specified ChatServer message. Does not implicitly {@link ChatServer.verify|verify} messages.
     * @function encode
     * @memberof ChatServer
     * @static
     * @param {IChatServer} message ChatServer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.chatRoom != null && Object.hasOwnProperty.call(message, "chatRoom"))
            $root.ChatRoom.encode(message.chatRoom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatServer message, length delimited. Does not implicitly {@link ChatServer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatServer
     * @static
     * @param {IChatServer} message ChatServer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatServer message from the specified reader or buffer.
     * @function decode
     * @memberof ChatServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatServer} ChatServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatServer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.chatRoom = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatServer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatServer} ChatServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatServer message.
     * @function verify
     * @memberof ChatServer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatServer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom")) {
            let error = $root.ChatRoom.verify(message.chatRoom);
            if (error)
                return "chatRoom." + error;
        }
        return null;
    };

    /**
     * Creates a ChatServer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatServer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatServer} ChatServer
     */
    ChatServer.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatServer)
            return object;
        let message = new $root.ChatServer();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.chatRoom != null) {
            if (typeof object.chatRoom !== "object")
                throw TypeError(".ChatServer.chatRoom: object expected");
            message.chatRoom = $root.ChatRoom.fromObject(object.chatRoom);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatServer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatServer
     * @static
     * @param {ChatServer} message ChatServer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatServer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.chatRoom = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom"))
            object.chatRoom = $root.ChatRoom.toObject(message.chatRoom, options);
        return object;
    };

    /**
     * Converts this ChatServer to JSON.
     * @function toJSON
     * @memberof ChatServer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatServer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatServer;
})();

export const CreateChatServerRequest = $root.CreateChatServerRequest = (() => {

    /**
     * Properties of a CreateChatServerRequest.
     * @exports ICreateChatServerRequest
     * @interface ICreateChatServerRequest
     * @property {Uint8Array|null} [networkKey] CreateChatServerRequest networkKey
     * @property {IChatRoom|null} [chatRoom] CreateChatServerRequest chatRoom
     */

    /**
     * Constructs a new CreateChatServerRequest.
     * @exports CreateChatServerRequest
     * @classdesc Represents a CreateChatServerRequest.
     * @implements ICreateChatServerRequest
     * @constructor
     * @param {ICreateChatServerRequest=} [properties] Properties to set
     */
    function CreateChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateChatServerRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof CreateChatServerRequest
     * @instance
     */
    CreateChatServerRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * CreateChatServerRequest chatRoom.
     * @member {IChatRoom|null|undefined} chatRoom
     * @memberof CreateChatServerRequest
     * @instance
     */
    CreateChatServerRequest.prototype.chatRoom = null;

    /**
     * Creates a new CreateChatServerRequest instance using the specified properties.
     * @function create
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest=} [properties] Properties to set
     * @returns {CreateChatServerRequest} CreateChatServerRequest instance
     */
    CreateChatServerRequest.create = function create(properties) {
        return new CreateChatServerRequest(properties);
    };

    /**
     * Encodes the specified CreateChatServerRequest message. Does not implicitly {@link CreateChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest} message CreateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.chatRoom != null && Object.hasOwnProperty.call(message, "chatRoom"))
            $root.ChatRoom.encode(message.chatRoom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateChatServerRequest message, length delimited. Does not implicitly {@link CreateChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest} message CreateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.chatRoom = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateChatServerRequest message.
     * @function verify
     * @memberof CreateChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom")) {
            let error = $root.ChatRoom.verify(message.chatRoom);
            if (error)
                return "chatRoom." + error;
        }
        return null;
    };

    /**
     * Creates a CreateChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     */
    CreateChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateChatServerRequest)
            return object;
        let message = new $root.CreateChatServerRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.chatRoom != null) {
            if (typeof object.chatRoom !== "object")
                throw TypeError(".CreateChatServerRequest.chatRoom: object expected");
            message.chatRoom = $root.ChatRoom.fromObject(object.chatRoom);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateChatServerRequest
     * @static
     * @param {CreateChatServerRequest} message CreateChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.chatRoom = null;
        }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom"))
            object.chatRoom = $root.ChatRoom.toObject(message.chatRoom, options);
        return object;
    };

    /**
     * Converts this CreateChatServerRequest to JSON.
     * @function toJSON
     * @memberof CreateChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateChatServerRequest;
})();

export const CreateChatServerResponse = $root.CreateChatServerResponse = (() => {

    /**
     * Properties of a CreateChatServerResponse.
     * @exports ICreateChatServerResponse
     * @interface ICreateChatServerResponse
     * @property {IChatServer|null} [chatServer] CreateChatServerResponse chatServer
     */

    /**
     * Constructs a new CreateChatServerResponse.
     * @exports CreateChatServerResponse
     * @classdesc Represents a CreateChatServerResponse.
     * @implements ICreateChatServerResponse
     * @constructor
     * @param {ICreateChatServerResponse=} [properties] Properties to set
     */
    function CreateChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof CreateChatServerResponse
     * @instance
     */
    CreateChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new CreateChatServerResponse instance using the specified properties.
     * @function create
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse=} [properties] Properties to set
     * @returns {CreateChatServerResponse} CreateChatServerResponse instance
     */
    CreateChatServerResponse.create = function create(properties) {
        return new CreateChatServerResponse(properties);
    };

    /**
     * Encodes the specified CreateChatServerResponse message. Does not implicitly {@link CreateChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse} message CreateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateChatServerResponse message, length delimited. Does not implicitly {@link CreateChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse} message CreateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateChatServerResponse message.
     * @function verify
     * @memberof CreateChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates a CreateChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     */
    CreateChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateChatServerResponse)
            return object;
        let message = new $root.CreateChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".CreateChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateChatServerResponse
     * @static
     * @param {CreateChatServerResponse} message CreateChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this CreateChatServerResponse to JSON.
     * @function toJSON
     * @memberof CreateChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateChatServerResponse;
})();

export const UpdateChatServerRequest = $root.UpdateChatServerRequest = (() => {

    /**
     * Properties of an UpdateChatServerRequest.
     * @exports IUpdateChatServerRequest
     * @interface IUpdateChatServerRequest
     * @property {number|null} [id] UpdateChatServerRequest id
     * @property {Uint8Array|null} [networkKey] UpdateChatServerRequest networkKey
     * @property {IChatRoom|null} [chatRoom] UpdateChatServerRequest chatRoom
     */

    /**
     * Constructs a new UpdateChatServerRequest.
     * @exports UpdateChatServerRequest
     * @classdesc Represents an UpdateChatServerRequest.
     * @implements IUpdateChatServerRequest
     * @constructor
     * @param {IUpdateChatServerRequest=} [properties] Properties to set
     */
    function UpdateChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateChatServerRequest id.
     * @member {number} id
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateChatServerRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * UpdateChatServerRequest chatRoom.
     * @member {IChatRoom|null|undefined} chatRoom
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.chatRoom = null;

    /**
     * Creates a new UpdateChatServerRequest instance using the specified properties.
     * @function create
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest=} [properties] Properties to set
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest instance
     */
    UpdateChatServerRequest.create = function create(properties) {
        return new UpdateChatServerRequest(properties);
    };

    /**
     * Encodes the specified UpdateChatServerRequest message. Does not implicitly {@link UpdateChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest} message UpdateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.chatRoom != null && Object.hasOwnProperty.call(message, "chatRoom"))
            $root.ChatRoom.encode(message.chatRoom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateChatServerRequest message, length delimited. Does not implicitly {@link UpdateChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest} message UpdateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.chatRoom = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateChatServerRequest message.
     * @function verify
     * @memberof UpdateChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom")) {
            let error = $root.ChatRoom.verify(message.chatRoom);
            if (error)
                return "chatRoom." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     */
    UpdateChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateChatServerRequest)
            return object;
        let message = new $root.UpdateChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.chatRoom != null) {
            if (typeof object.chatRoom !== "object")
                throw TypeError(".UpdateChatServerRequest.chatRoom: object expected");
            message.chatRoom = $root.ChatRoom.fromObject(object.chatRoom);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateChatServerRequest
     * @static
     * @param {UpdateChatServerRequest} message UpdateChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.chatRoom = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom"))
            object.chatRoom = $root.ChatRoom.toObject(message.chatRoom, options);
        return object;
    };

    /**
     * Converts this UpdateChatServerRequest to JSON.
     * @function toJSON
     * @memberof UpdateChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateChatServerRequest;
})();

export const UpdateChatServerResponse = $root.UpdateChatServerResponse = (() => {

    /**
     * Properties of an UpdateChatServerResponse.
     * @exports IUpdateChatServerResponse
     * @interface IUpdateChatServerResponse
     * @property {IChatServer|null} [chatServer] UpdateChatServerResponse chatServer
     */

    /**
     * Constructs a new UpdateChatServerResponse.
     * @exports UpdateChatServerResponse
     * @classdesc Represents an UpdateChatServerResponse.
     * @implements IUpdateChatServerResponse
     * @constructor
     * @param {IUpdateChatServerResponse=} [properties] Properties to set
     */
    function UpdateChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof UpdateChatServerResponse
     * @instance
     */
    UpdateChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new UpdateChatServerResponse instance using the specified properties.
     * @function create
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse=} [properties] Properties to set
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse instance
     */
    UpdateChatServerResponse.create = function create(properties) {
        return new UpdateChatServerResponse(properties);
    };

    /**
     * Encodes the specified UpdateChatServerResponse message. Does not implicitly {@link UpdateChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse} message UpdateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateChatServerResponse message, length delimited. Does not implicitly {@link UpdateChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse} message UpdateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateChatServerResponse message.
     * @function verify
     * @memberof UpdateChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     */
    UpdateChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateChatServerResponse)
            return object;
        let message = new $root.UpdateChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".UpdateChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateChatServerResponse
     * @static
     * @param {UpdateChatServerResponse} message UpdateChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this UpdateChatServerResponse to JSON.
     * @function toJSON
     * @memberof UpdateChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateChatServerResponse;
})();

export const DeleteChatServerRequest = $root.DeleteChatServerRequest = (() => {

    /**
     * Properties of a DeleteChatServerRequest.
     * @exports IDeleteChatServerRequest
     * @interface IDeleteChatServerRequest
     * @property {number|null} [id] DeleteChatServerRequest id
     */

    /**
     * Constructs a new DeleteChatServerRequest.
     * @exports DeleteChatServerRequest
     * @classdesc Represents a DeleteChatServerRequest.
     * @implements IDeleteChatServerRequest
     * @constructor
     * @param {IDeleteChatServerRequest=} [properties] Properties to set
     */
    function DeleteChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteChatServerRequest id.
     * @member {number} id
     * @memberof DeleteChatServerRequest
     * @instance
     */
    DeleteChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteChatServerRequest instance using the specified properties.
     * @function create
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest=} [properties] Properties to set
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest instance
     */
    DeleteChatServerRequest.create = function create(properties) {
        return new DeleteChatServerRequest(properties);
    };

    /**
     * Encodes the specified DeleteChatServerRequest message. Does not implicitly {@link DeleteChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest} message DeleteChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteChatServerRequest message, length delimited. Does not implicitly {@link DeleteChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest} message DeleteChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteChatServerRequest message.
     * @function verify
     * @memberof DeleteChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     */
    DeleteChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteChatServerRequest)
            return object;
        let message = new $root.DeleteChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteChatServerRequest
     * @static
     * @param {DeleteChatServerRequest} message DeleteChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteChatServerRequest to JSON.
     * @function toJSON
     * @memberof DeleteChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteChatServerRequest;
})();

export const DeleteChatServerResponse = $root.DeleteChatServerResponse = (() => {

    /**
     * Properties of a DeleteChatServerResponse.
     * @exports IDeleteChatServerResponse
     * @interface IDeleteChatServerResponse
     */

    /**
     * Constructs a new DeleteChatServerResponse.
     * @exports DeleteChatServerResponse
     * @classdesc Represents a DeleteChatServerResponse.
     * @implements IDeleteChatServerResponse
     * @constructor
     * @param {IDeleteChatServerResponse=} [properties] Properties to set
     */
    function DeleteChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteChatServerResponse instance using the specified properties.
     * @function create
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse=} [properties] Properties to set
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse instance
     */
    DeleteChatServerResponse.create = function create(properties) {
        return new DeleteChatServerResponse(properties);
    };

    /**
     * Encodes the specified DeleteChatServerResponse message. Does not implicitly {@link DeleteChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse} message DeleteChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteChatServerResponse message, length delimited. Does not implicitly {@link DeleteChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse} message DeleteChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteChatServerResponse message.
     * @function verify
     * @memberof DeleteChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     */
    DeleteChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteChatServerResponse)
            return object;
        return new $root.DeleteChatServerResponse();
    };

    /**
     * Creates a plain object from a DeleteChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteChatServerResponse
     * @static
     * @param {DeleteChatServerResponse} message DeleteChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteChatServerResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteChatServerResponse to JSON.
     * @function toJSON
     * @memberof DeleteChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteChatServerResponse;
})();

export const GetChatServerRequest = $root.GetChatServerRequest = (() => {

    /**
     * Properties of a GetChatServerRequest.
     * @exports IGetChatServerRequest
     * @interface IGetChatServerRequest
     * @property {number|null} [id] GetChatServerRequest id
     */

    /**
     * Constructs a new GetChatServerRequest.
     * @exports GetChatServerRequest
     * @classdesc Represents a GetChatServerRequest.
     * @implements IGetChatServerRequest
     * @constructor
     * @param {IGetChatServerRequest=} [properties] Properties to set
     */
    function GetChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetChatServerRequest id.
     * @member {number} id
     * @memberof GetChatServerRequest
     * @instance
     */
    GetChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetChatServerRequest instance using the specified properties.
     * @function create
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest=} [properties] Properties to set
     * @returns {GetChatServerRequest} GetChatServerRequest instance
     */
    GetChatServerRequest.create = function create(properties) {
        return new GetChatServerRequest(properties);
    };

    /**
     * Encodes the specified GetChatServerRequest message. Does not implicitly {@link GetChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest} message GetChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetChatServerRequest message, length delimited. Does not implicitly {@link GetChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest} message GetChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServerRequest} GetChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServerRequest} GetChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServerRequest message.
     * @function verify
     * @memberof GetChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServerRequest} GetChatServerRequest
     */
    GetChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServerRequest)
            return object;
        let message = new $root.GetChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServerRequest
     * @static
     * @param {GetChatServerRequest} message GetChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetChatServerRequest to JSON.
     * @function toJSON
     * @memberof GetChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServerRequest;
})();

export const GetChatServerResponse = $root.GetChatServerResponse = (() => {

    /**
     * Properties of a GetChatServerResponse.
     * @exports IGetChatServerResponse
     * @interface IGetChatServerResponse
     * @property {IChatServer|null} [chatServer] GetChatServerResponse chatServer
     */

    /**
     * Constructs a new GetChatServerResponse.
     * @exports GetChatServerResponse
     * @classdesc Represents a GetChatServerResponse.
     * @implements IGetChatServerResponse
     * @constructor
     * @param {IGetChatServerResponse=} [properties] Properties to set
     */
    function GetChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof GetChatServerResponse
     * @instance
     */
    GetChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new GetChatServerResponse instance using the specified properties.
     * @function create
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse=} [properties] Properties to set
     * @returns {GetChatServerResponse} GetChatServerResponse instance
     */
    GetChatServerResponse.create = function create(properties) {
        return new GetChatServerResponse(properties);
    };

    /**
     * Encodes the specified GetChatServerResponse message. Does not implicitly {@link GetChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse} message GetChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetChatServerResponse message, length delimited. Does not implicitly {@link GetChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse} message GetChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServerResponse} GetChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServerResponse} GetChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServerResponse message.
     * @function verify
     * @memberof GetChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates a GetChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServerResponse} GetChatServerResponse
     */
    GetChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServerResponse)
            return object;
        let message = new $root.GetChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".GetChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServerResponse
     * @static
     * @param {GetChatServerResponse} message GetChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this GetChatServerResponse to JSON.
     * @function toJSON
     * @memberof GetChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServerResponse;
})();

export const GetChatServersRequest = $root.GetChatServersRequest = (() => {

    /**
     * Properties of a GetChatServersRequest.
     * @exports IGetChatServersRequest
     * @interface IGetChatServersRequest
     */

    /**
     * Constructs a new GetChatServersRequest.
     * @exports GetChatServersRequest
     * @classdesc Represents a GetChatServersRequest.
     * @implements IGetChatServersRequest
     * @constructor
     * @param {IGetChatServersRequest=} [properties] Properties to set
     */
    function GetChatServersRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetChatServersRequest instance using the specified properties.
     * @function create
     * @memberof GetChatServersRequest
     * @static
     * @param {IGetChatServersRequest=} [properties] Properties to set
     * @returns {GetChatServersRequest} GetChatServersRequest instance
     */
    GetChatServersRequest.create = function create(properties) {
        return new GetChatServersRequest(properties);
    };

    /**
     * Encodes the specified GetChatServersRequest message. Does not implicitly {@link GetChatServersRequest.verify|verify} messages.
     * @function encode
     * @memberof GetChatServersRequest
     * @static
     * @param {IGetChatServersRequest} message GetChatServersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServersRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetChatServersRequest message, length delimited. Does not implicitly {@link GetChatServersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServersRequest
     * @static
     * @param {IGetChatServersRequest} message GetChatServersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServersRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServersRequest} GetChatServersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServersRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServersRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServersRequest} GetChatServersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServersRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServersRequest message.
     * @function verify
     * @memberof GetChatServersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServersRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetChatServersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServersRequest} GetChatServersRequest
     */
    GetChatServersRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServersRequest)
            return object;
        return new $root.GetChatServersRequest();
    };

    /**
     * Creates a plain object from a GetChatServersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServersRequest
     * @static
     * @param {GetChatServersRequest} message GetChatServersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServersRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetChatServersRequest to JSON.
     * @function toJSON
     * @memberof GetChatServersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServersRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServersRequest;
})();

export const GetChatServersResponse = $root.GetChatServersResponse = (() => {

    /**
     * Properties of a GetChatServersResponse.
     * @exports IGetChatServersResponse
     * @interface IGetChatServersResponse
     * @property {Array.<IChatServer>|null} [chatServers] GetChatServersResponse chatServers
     */

    /**
     * Constructs a new GetChatServersResponse.
     * @exports GetChatServersResponse
     * @classdesc Represents a GetChatServersResponse.
     * @implements IGetChatServersResponse
     * @constructor
     * @param {IGetChatServersResponse=} [properties] Properties to set
     */
    function GetChatServersResponse(properties) {
        this.chatServers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetChatServersResponse chatServers.
     * @member {Array.<IChatServer>} chatServers
     * @memberof GetChatServersResponse
     * @instance
     */
    GetChatServersResponse.prototype.chatServers = $util.emptyArray;

    /**
     * Creates a new GetChatServersResponse instance using the specified properties.
     * @function create
     * @memberof GetChatServersResponse
     * @static
     * @param {IGetChatServersResponse=} [properties] Properties to set
     * @returns {GetChatServersResponse} GetChatServersResponse instance
     */
    GetChatServersResponse.create = function create(properties) {
        return new GetChatServersResponse(properties);
    };

    /**
     * Encodes the specified GetChatServersResponse message. Does not implicitly {@link GetChatServersResponse.verify|verify} messages.
     * @function encode
     * @memberof GetChatServersResponse
     * @static
     * @param {IGetChatServersResponse} message GetChatServersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServersResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServers != null && message.chatServers.length)
            for (let i = 0; i < message.chatServers.length; ++i)
                $root.ChatServer.encode(message.chatServers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetChatServersResponse message, length delimited. Does not implicitly {@link GetChatServersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServersResponse
     * @static
     * @param {IGetChatServersResponse} message GetChatServersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServersResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServersResponse} GetChatServersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServersResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServersResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.chatServers && message.chatServers.length))
                    message.chatServers = [];
                message.chatServers.push($root.ChatServer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServersResponse} GetChatServersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServersResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServersResponse message.
     * @function verify
     * @memberof GetChatServersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServersResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServers != null && message.hasOwnProperty("chatServers")) {
            if (!Array.isArray(message.chatServers))
                return "chatServers: array expected";
            for (let i = 0; i < message.chatServers.length; ++i) {
                let error = $root.ChatServer.verify(message.chatServers[i]);
                if (error)
                    return "chatServers." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetChatServersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServersResponse} GetChatServersResponse
     */
    GetChatServersResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServersResponse)
            return object;
        let message = new $root.GetChatServersResponse();
        if (object.chatServers) {
            if (!Array.isArray(object.chatServers))
                throw TypeError(".GetChatServersResponse.chatServers: array expected");
            message.chatServers = [];
            for (let i = 0; i < object.chatServers.length; ++i) {
                if (typeof object.chatServers[i] !== "object")
                    throw TypeError(".GetChatServersResponse.chatServers: object expected");
                message.chatServers[i] = $root.ChatServer.fromObject(object.chatServers[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetChatServersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServersResponse
     * @static
     * @param {GetChatServersResponse} message GetChatServersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServersResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.chatServers = [];
        if (message.chatServers && message.chatServers.length) {
            object.chatServers = [];
            for (let j = 0; j < message.chatServers.length; ++j)
                object.chatServers[j] = $root.ChatServer.toObject(message.chatServers[j], options);
        }
        return object;
    };

    /**
     * Converts this GetChatServersResponse to JSON.
     * @function toJSON
     * @memberof GetChatServersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServersResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServersResponse;
})();

export const ChatClientOpenRequest = $root.ChatClientOpenRequest = (() => {

    /**
     * Properties of a ChatClientOpenRequest.
     * @exports IChatClientOpenRequest
     * @interface IChatClientOpenRequest
     * @property {number|null} [networkId] ChatClientOpenRequest networkId
     * @property {Uint8Array|null} [hostId] ChatClientOpenRequest hostId
     * @property {number|null} [port] ChatClientOpenRequest port
     */

    /**
     * Constructs a new ChatClientOpenRequest.
     * @exports ChatClientOpenRequest
     * @classdesc Represents a ChatClientOpenRequest.
     * @implements IChatClientOpenRequest
     * @constructor
     * @param {IChatClientOpenRequest=} [properties] Properties to set
     */
    function ChatClientOpenRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatClientOpenRequest networkId.
     * @member {number} networkId
     * @memberof ChatClientOpenRequest
     * @instance
     */
    ChatClientOpenRequest.prototype.networkId = 0;

    /**
     * ChatClientOpenRequest hostId.
     * @member {Uint8Array} hostId
     * @memberof ChatClientOpenRequest
     * @instance
     */
    ChatClientOpenRequest.prototype.hostId = $util.newBuffer([]);

    /**
     * ChatClientOpenRequest port.
     * @member {number} port
     * @memberof ChatClientOpenRequest
     * @instance
     */
    ChatClientOpenRequest.prototype.port = 0;

    /**
     * Creates a new ChatClientOpenRequest instance using the specified properties.
     * @function create
     * @memberof ChatClientOpenRequest
     * @static
     * @param {IChatClientOpenRequest=} [properties] Properties to set
     * @returns {ChatClientOpenRequest} ChatClientOpenRequest instance
     */
    ChatClientOpenRequest.create = function create(properties) {
        return new ChatClientOpenRequest(properties);
    };

    /**
     * Encodes the specified ChatClientOpenRequest message. Does not implicitly {@link ChatClientOpenRequest.verify|verify} messages.
     * @function encode
     * @memberof ChatClientOpenRequest
     * @static
     * @param {IChatClientOpenRequest} message ChatClientOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientOpenRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.networkId);
        if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hostId);
        if (message.port != null && Object.hasOwnProperty.call(message, "port"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.port);
        return writer;
    };

    /**
     * Encodes the specified ChatClientOpenRequest message, length delimited. Does not implicitly {@link ChatClientOpenRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatClientOpenRequest
     * @static
     * @param {IChatClientOpenRequest} message ChatClientOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientOpenRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatClientOpenRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ChatClientOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatClientOpenRequest} ChatClientOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientOpenRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientOpenRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkId = reader.uint32();
                break;
            case 2:
                message.hostId = reader.bytes();
                break;
            case 3:
                message.port = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatClientOpenRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatClientOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatClientOpenRequest} ChatClientOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientOpenRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatClientOpenRequest message.
     * @function verify
     * @memberof ChatClientOpenRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatClientOpenRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkId != null && message.hasOwnProperty("networkId"))
            if (!$util.isInteger(message.networkId))
                return "networkId: integer expected";
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                return "hostId: buffer expected";
        if (message.port != null && message.hasOwnProperty("port"))
            if (!$util.isInteger(message.port))
                return "port: integer expected";
        return null;
    };

    /**
     * Creates a ChatClientOpenRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatClientOpenRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatClientOpenRequest} ChatClientOpenRequest
     */
    ChatClientOpenRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatClientOpenRequest)
            return object;
        let message = new $root.ChatClientOpenRequest();
        if (object.networkId != null)
            message.networkId = object.networkId >>> 0;
        if (object.hostId != null)
            if (typeof object.hostId === "string")
                $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
            else if (object.hostId.length)
                message.hostId = object.hostId;
        if (object.port != null)
            message.port = object.port >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a ChatClientOpenRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatClientOpenRequest
     * @static
     * @param {ChatClientOpenRequest} message ChatClientOpenRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatClientOpenRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.networkId = 0;
            if (options.bytes === String)
                object.hostId = "";
            else {
                object.hostId = [];
                if (options.bytes !== Array)
                    object.hostId = $util.newBuffer(object.hostId);
            }
            object.port = 0;
        }
        if (message.networkId != null && message.hasOwnProperty("networkId"))
            object.networkId = message.networkId;
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
        if (message.port != null && message.hasOwnProperty("port"))
            object.port = message.port;
        return object;
    };

    /**
     * Converts this ChatClientOpenRequest to JSON.
     * @function toJSON
     * @memberof ChatClientOpenRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatClientOpenRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatClientOpenRequest;
})();

export const ChatClientEvent = $root.ChatClientEvent = (() => {

    /**
     * Properties of a ChatClientEvent.
     * @exports IChatClientEvent
     * @interface IChatClientEvent
     * @property {ChatClientEvent.IOpen|null} [open] ChatClientEvent open
     * @property {ChatClientEvent.IMessage|null} [message] ChatClientEvent message
     * @property {ChatClientEvent.IClose|null} [close] ChatClientEvent close
     * @property {ChatClientEvent.IPadding|null} [padding] ChatClientEvent padding
     */

    /**
     * Constructs a new ChatClientEvent.
     * @exports ChatClientEvent
     * @classdesc Represents a ChatClientEvent.
     * @implements IChatClientEvent
     * @constructor
     * @param {IChatClientEvent=} [properties] Properties to set
     */
    function ChatClientEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatClientEvent open.
     * @member {ChatClientEvent.IOpen|null|undefined} open
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.open = null;

    /**
     * ChatClientEvent message.
     * @member {ChatClientEvent.IMessage|null|undefined} message
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.message = null;

    /**
     * ChatClientEvent close.
     * @member {ChatClientEvent.IClose|null|undefined} close
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.close = null;

    /**
     * ChatClientEvent padding.
     * @member {ChatClientEvent.IPadding|null|undefined} padding
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.padding = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * ChatClientEvent body.
     * @member {"open"|"message"|"close"|"padding"|undefined} body
     * @memberof ChatClientEvent
     * @instance
     */
    Object.defineProperty(ChatClientEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "message", "close", "padding"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new ChatClientEvent instance using the specified properties.
     * @function create
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent=} [properties] Properties to set
     * @returns {ChatClientEvent} ChatClientEvent instance
     */
    ChatClientEvent.create = function create(properties) {
        return new ChatClientEvent(properties);
    };

    /**
     * Encodes the specified ChatClientEvent message. Does not implicitly {@link ChatClientEvent.verify|verify} messages.
     * @function encode
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent} message ChatClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.ChatClientEvent.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.ChatClientEvent.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.ChatClientEvent.Close.encode(message.close, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
            $root.ChatClientEvent.Padding.encode(message.padding, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatClientEvent message, length delimited. Does not implicitly {@link ChatClientEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent} message ChatClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatClientEvent message from the specified reader or buffer.
     * @function decode
     * @memberof ChatClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatClientEvent} ChatClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.ChatClientEvent.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.message = $root.ChatClientEvent.Message.decode(reader, reader.uint32());
                break;
            case 3:
                message.close = $root.ChatClientEvent.Close.decode(reader, reader.uint32());
                break;
            case 4:
                message.padding = $root.ChatClientEvent.Padding.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatClientEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatClientEvent} ChatClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatClientEvent message.
     * @function verify
     * @memberof ChatClientEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatClientEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.message != null && message.hasOwnProperty("message")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        if (message.padding != null && message.hasOwnProperty("padding")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Padding.verify(message.padding);
                if (error)
                    return "padding." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ChatClientEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatClientEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatClientEvent} ChatClientEvent
     */
    ChatClientEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatClientEvent)
            return object;
        let message = new $root.ChatClientEvent();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".ChatClientEvent.open: object expected");
            message.open = $root.ChatClientEvent.Open.fromObject(object.open);
        }
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".ChatClientEvent.message: object expected");
            message.message = $root.ChatClientEvent.Message.fromObject(object.message);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".ChatClientEvent.close: object expected");
            message.close = $root.ChatClientEvent.Close.fromObject(object.close);
        }
        if (object.padding != null) {
            if (typeof object.padding !== "object")
                throw TypeError(".ChatClientEvent.padding: object expected");
            message.padding = $root.ChatClientEvent.Padding.fromObject(object.padding);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatClientEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatClientEvent
     * @static
     * @param {ChatClientEvent} message ChatClientEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatClientEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.ChatClientEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.ChatClientEvent.Message.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.ChatClientEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        if (message.padding != null && message.hasOwnProperty("padding")) {
            object.padding = $root.ChatClientEvent.Padding.toObject(message.padding, options);
            if (options.oneofs)
                object.body = "padding";
        }
        return object;
    };

    /**
     * Converts this ChatClientEvent to JSON.
     * @function toJSON
     * @memberof ChatClientEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatClientEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ChatClientEvent.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof ChatClientEvent
         * @interface IMessage
         * @property {number|null} [sentTime] Message sentTime
         * @property {number|null} [serverTime] Message serverTime
         * @property {string|null} [body] Message body
         */

        /**
         * Constructs a new Message.
         * @memberof ChatClientEvent
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {ChatClientEvent.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message sentTime.
         * @member {number} sentTime
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.sentTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message serverTime.
         * @member {number} serverTime
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message body.
         * @member {string} body
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.body = "";

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage=} [properties] Properties to set
         * @returns {ChatClientEvent.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link ChatClientEvent.Message.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sentTime);
            if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverTime);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link ChatClientEvent.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sentTime = reader.int64();
                    break;
                case 2:
                    message.serverTime = reader.int64();
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof ChatClientEvent.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
                if (!$util.isInteger(message.sentTime) && !(message.sentTime && $util.isInteger(message.sentTime.low) && $util.isInteger(message.sentTime.high)))
                    return "sentTime: integer|Long expected";
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                    return "serverTime: integer|Long expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Message)
                return object;
            let message = new $root.ChatClientEvent.Message();
            if (object.sentTime != null)
                if ($util.Long)
                    (message.sentTime = $util.Long.fromValue(object.sentTime)).unsigned = false;
                else if (typeof object.sentTime === "string")
                    message.sentTime = parseInt(object.sentTime, 10);
                else if (typeof object.sentTime === "number")
                    message.sentTime = object.sentTime;
                else if (typeof object.sentTime === "object")
                    message.sentTime = new $util.LongBits(object.sentTime.low >>> 0, object.sentTime.high >>> 0).toNumber();
            if (object.serverTime != null)
                if ($util.Long)
                    (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                else if (typeof object.serverTime === "string")
                    message.serverTime = parseInt(object.serverTime, 10);
                else if (typeof object.serverTime === "number")
                    message.serverTime = object.serverTime;
                else if (typeof object.serverTime === "object")
                    message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
            if (object.body != null)
                message.body = String(object.body);
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sentTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sentTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTime = options.longs === String ? "0" : 0;
                object.body = "";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
                if (typeof message.sentTime === "number")
                    object.sentTime = options.longs === String ? String(message.sentTime) : message.sentTime;
                else
                    object.sentTime = options.longs === String ? $util.Long.prototype.toString.call(message.sentTime) : options.longs === Number ? new $util.LongBits(message.sentTime.low >>> 0, message.sentTime.high >>> 0).toNumber() : message.sentTime;
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (typeof message.serverTime === "number")
                    object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                else
                    object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    ChatClientEvent.Padding = (function() {

        /**
         * Properties of a Padding.
         * @memberof ChatClientEvent
         * @interface IPadding
         * @property {Uint8Array|null} [body] Padding body
         */

        /**
         * Constructs a new Padding.
         * @memberof ChatClientEvent
         * @classdesc Represents a Padding.
         * @implements IPadding
         * @constructor
         * @param {ChatClientEvent.IPadding=} [properties] Properties to set
         */
        function Padding(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Padding body.
         * @member {Uint8Array} body
         * @memberof ChatClientEvent.Padding
         * @instance
         */
        Padding.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new Padding instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {ChatClientEvent.IPadding=} [properties] Properties to set
         * @returns {ChatClientEvent.Padding} Padding instance
         */
        Padding.create = function create(properties) {
            return new Padding(properties);
        };

        /**
         * Encodes the specified Padding message. Does not implicitly {@link ChatClientEvent.Padding.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {ChatClientEvent.IPadding} message Padding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Padding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified Padding message, length delimited. Does not implicitly {@link ChatClientEvent.Padding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {ChatClientEvent.IPadding} message Padding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Padding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Padding message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Padding} Padding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Padding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Padding();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Padding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Padding} Padding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Padding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Padding message.
         * @function verify
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Padding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a Padding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Padding} Padding
         */
        Padding.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Padding)
                return object;
            let message = new $root.ChatClientEvent.Padding();
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a Padding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Padding
         * @static
         * @param {ChatClientEvent.Padding} message Padding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Padding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this Padding to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Padding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Padding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Padding;
    })();

    ChatClientEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof ChatClientEvent
         * @interface IOpen
         * @property {number|null} [clientId] Open clientId
         */

        /**
         * Constructs a new Open.
         * @memberof ChatClientEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {ChatClientEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open clientId.
         * @member {number} clientId
         * @memberof ChatClientEvent.Open
         * @instance
         */
        Open.prototype.clientId = 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen=} [properties] Properties to set
         * @returns {ChatClientEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link ChatClientEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.clientId);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link ChatClientEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof ChatClientEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                if (!$util.isInteger(message.clientId))
                    return "clientId: integer expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Open)
                return object;
            let message = new $root.ChatClientEvent.Open();
            if (object.clientId != null)
                message.clientId = object.clientId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.clientId = 0;
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                object.clientId = message.clientId;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    ChatClientEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof ChatClientEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof ChatClientEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {ChatClientEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose=} [properties] Properties to set
         * @returns {ChatClientEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link ChatClientEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link ChatClientEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof ChatClientEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Close)
                return object;
            return new $root.ChatClientEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return ChatClientEvent;
})();

export const ChatClientCallRequest = $root.ChatClientCallRequest = (() => {

    /**
     * Properties of a ChatClientCallRequest.
     * @exports IChatClientCallRequest
     * @interface IChatClientCallRequest
     * @property {number|null} [clientId] ChatClientCallRequest clientId
     * @property {ChatClientCallRequest.IMessage|null} [message] ChatClientCallRequest message
     * @property {ChatClientCallRequest.IRunClient|null} [runClient] ChatClientCallRequest runClient
     * @property {ChatClientCallRequest.IRunServer|null} [runServer] ChatClientCallRequest runServer
     */

    /**
     * Constructs a new ChatClientCallRequest.
     * @exports ChatClientCallRequest
     * @classdesc Represents a ChatClientCallRequest.
     * @implements IChatClientCallRequest
     * @constructor
     * @param {IChatClientCallRequest=} [properties] Properties to set
     */
    function ChatClientCallRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatClientCallRequest clientId.
     * @member {number} clientId
     * @memberof ChatClientCallRequest
     * @instance
     */
    ChatClientCallRequest.prototype.clientId = 0;

    /**
     * ChatClientCallRequest message.
     * @member {ChatClientCallRequest.IMessage|null|undefined} message
     * @memberof ChatClientCallRequest
     * @instance
     */
    ChatClientCallRequest.prototype.message = null;

    /**
     * ChatClientCallRequest runClient.
     * @member {ChatClientCallRequest.IRunClient|null|undefined} runClient
     * @memberof ChatClientCallRequest
     * @instance
     */
    ChatClientCallRequest.prototype.runClient = null;

    /**
     * ChatClientCallRequest runServer.
     * @member {ChatClientCallRequest.IRunServer|null|undefined} runServer
     * @memberof ChatClientCallRequest
     * @instance
     */
    ChatClientCallRequest.prototype.runServer = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * ChatClientCallRequest body.
     * @member {"message"|"runClient"|"runServer"|undefined} body
     * @memberof ChatClientCallRequest
     * @instance
     */
    Object.defineProperty(ChatClientCallRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["message", "runClient", "runServer"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new ChatClientCallRequest instance using the specified properties.
     * @function create
     * @memberof ChatClientCallRequest
     * @static
     * @param {IChatClientCallRequest=} [properties] Properties to set
     * @returns {ChatClientCallRequest} ChatClientCallRequest instance
     */
    ChatClientCallRequest.create = function create(properties) {
        return new ChatClientCallRequest(properties);
    };

    /**
     * Encodes the specified ChatClientCallRequest message. Does not implicitly {@link ChatClientCallRequest.verify|verify} messages.
     * @function encode
     * @memberof ChatClientCallRequest
     * @static
     * @param {IChatClientCallRequest} message ChatClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientCallRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.clientId);
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.ChatClientCallRequest.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.runClient != null && Object.hasOwnProperty.call(message, "runClient"))
            $root.ChatClientCallRequest.RunClient.encode(message.runClient, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.runServer != null && Object.hasOwnProperty.call(message, "runServer"))
            $root.ChatClientCallRequest.RunServer.encode(message.runServer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatClientCallRequest message, length delimited. Does not implicitly {@link ChatClientCallRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatClientCallRequest
     * @static
     * @param {IChatClientCallRequest} message ChatClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientCallRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatClientCallRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ChatClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatClientCallRequest} ChatClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientCallRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientCallRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clientId = reader.uint32();
                break;
            case 2:
                message.message = $root.ChatClientCallRequest.Message.decode(reader, reader.uint32());
                break;
            case 3:
                message.runClient = $root.ChatClientCallRequest.RunClient.decode(reader, reader.uint32());
                break;
            case 4:
                message.runServer = $root.ChatClientCallRequest.RunServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatClientCallRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatClientCallRequest} ChatClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientCallRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatClientCallRequest message.
     * @function verify
     * @memberof ChatClientCallRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatClientCallRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            if (!$util.isInteger(message.clientId))
                return "clientId: integer expected";
        if (message.message != null && message.hasOwnProperty("message")) {
            properties.body = 1;
            {
                let error = $root.ChatClientCallRequest.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientCallRequest.RunClient.verify(message.runClient);
                if (error)
                    return "runClient." + error;
            }
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientCallRequest.RunServer.verify(message.runServer);
                if (error)
                    return "runServer." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ChatClientCallRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatClientCallRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatClientCallRequest} ChatClientCallRequest
     */
    ChatClientCallRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatClientCallRequest)
            return object;
        let message = new $root.ChatClientCallRequest();
        if (object.clientId != null)
            message.clientId = object.clientId >>> 0;
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".ChatClientCallRequest.message: object expected");
            message.message = $root.ChatClientCallRequest.Message.fromObject(object.message);
        }
        if (object.runClient != null) {
            if (typeof object.runClient !== "object")
                throw TypeError(".ChatClientCallRequest.runClient: object expected");
            message.runClient = $root.ChatClientCallRequest.RunClient.fromObject(object.runClient);
        }
        if (object.runServer != null) {
            if (typeof object.runServer !== "object")
                throw TypeError(".ChatClientCallRequest.runServer: object expected");
            message.runServer = $root.ChatClientCallRequest.RunServer.fromObject(object.runServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatClientCallRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatClientCallRequest
     * @static
     * @param {ChatClientCallRequest} message ChatClientCallRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatClientCallRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.clientId = 0;
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            object.clientId = message.clientId;
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.ChatClientCallRequest.Message.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            object.runClient = $root.ChatClientCallRequest.RunClient.toObject(message.runClient, options);
            if (options.oneofs)
                object.body = "runClient";
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            object.runServer = $root.ChatClientCallRequest.RunServer.toObject(message.runServer, options);
            if (options.oneofs)
                object.body = "runServer";
        }
        return object;
    };

    /**
     * Converts this ChatClientCallRequest to JSON.
     * @function toJSON
     * @memberof ChatClientCallRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatClientCallRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ChatClientCallRequest.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof ChatClientCallRequest
         * @interface IMessage
         * @property {number|null} [time] Message time
         * @property {string|null} [body] Message body
         */

        /**
         * Constructs a new Message.
         * @memberof ChatClientCallRequest
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {ChatClientCallRequest.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message time.
         * @member {number} time
         * @memberof ChatClientCallRequest.Message
         * @instance
         */
        Message.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message body.
         * @member {string} body
         * @memberof ChatClientCallRequest.Message
         * @instance
         */
        Message.prototype.body = "";

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {ChatClientCallRequest.IMessage=} [properties] Properties to set
         * @returns {ChatClientCallRequest.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link ChatClientCallRequest.Message.verify|verify} messages.
         * @function encode
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {ChatClientCallRequest.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link ChatClientCallRequest.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {ChatClientCallRequest.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientCallRequest.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientCallRequest.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientCallRequest.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientCallRequest.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientCallRequest.Message)
                return object;
            let message = new $root.ChatClientCallRequest.Message();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.body != null)
                message.body = String(object.body);
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientCallRequest.Message
         * @static
         * @param {ChatClientCallRequest.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.body = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof ChatClientCallRequest.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    ChatClientCallRequest.RunServer = (function() {

        /**
         * Properties of a RunServer.
         * @memberof ChatClientCallRequest
         * @interface IRunServer
         */

        /**
         * Constructs a new RunServer.
         * @memberof ChatClientCallRequest
         * @classdesc Represents a RunServer.
         * @implements IRunServer
         * @constructor
         * @param {ChatClientCallRequest.IRunServer=} [properties] Properties to set
         */
        function RunServer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunServer instance using the specified properties.
         * @function create
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {ChatClientCallRequest.IRunServer=} [properties] Properties to set
         * @returns {ChatClientCallRequest.RunServer} RunServer instance
         */
        RunServer.create = function create(properties) {
            return new RunServer(properties);
        };

        /**
         * Encodes the specified RunServer message. Does not implicitly {@link ChatClientCallRequest.RunServer.verify|verify} messages.
         * @function encode
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {ChatClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunServer message, length delimited. Does not implicitly {@link ChatClientCallRequest.RunServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {ChatClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientCallRequest.RunServer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunServer message.
         * @function verify
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientCallRequest.RunServer} RunServer
         */
        RunServer.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientCallRequest.RunServer)
                return object;
            return new $root.ChatClientCallRequest.RunServer();
        };

        /**
         * Creates a plain object from a RunServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientCallRequest.RunServer
         * @static
         * @param {ChatClientCallRequest.RunServer} message RunServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunServer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunServer to JSON.
         * @function toJSON
         * @memberof ChatClientCallRequest.RunServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunServer;
    })();

    ChatClientCallRequest.RunClient = (function() {

        /**
         * Properties of a RunClient.
         * @memberof ChatClientCallRequest
         * @interface IRunClient
         */

        /**
         * Constructs a new RunClient.
         * @memberof ChatClientCallRequest
         * @classdesc Represents a RunClient.
         * @implements IRunClient
         * @constructor
         * @param {ChatClientCallRequest.IRunClient=} [properties] Properties to set
         */
        function RunClient(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunClient instance using the specified properties.
         * @function create
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {ChatClientCallRequest.IRunClient=} [properties] Properties to set
         * @returns {ChatClientCallRequest.RunClient} RunClient instance
         */
        RunClient.create = function create(properties) {
            return new RunClient(properties);
        };

        /**
         * Encodes the specified RunClient message. Does not implicitly {@link ChatClientCallRequest.RunClient.verify|verify} messages.
         * @function encode
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {ChatClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunClient message, length delimited. Does not implicitly {@link ChatClientCallRequest.RunClient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {ChatClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientCallRequest.RunClient();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunClient message.
         * @function verify
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunClient.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunClient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientCallRequest.RunClient} RunClient
         */
        RunClient.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientCallRequest.RunClient)
                return object;
            return new $root.ChatClientCallRequest.RunClient();
        };

        /**
         * Creates a plain object from a RunClient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientCallRequest.RunClient
         * @static
         * @param {ChatClientCallRequest.RunClient} message RunClient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunClient.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunClient to JSON.
         * @function toJSON
         * @memberof ChatClientCallRequest.RunClient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunClient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunClient;
    })();

    return ChatClientCallRequest;
})();

export const NetworkAddress = $root.NetworkAddress = (() => {

    /**
     * Properties of a NetworkAddress.
     * @exports INetworkAddress
     * @interface INetworkAddress
     * @property {Uint8Array|null} [hostId] NetworkAddress hostId
     * @property {number|null} [port] NetworkAddress port
     */

    /**
     * Constructs a new NetworkAddress.
     * @exports NetworkAddress
     * @classdesc Represents a NetworkAddress.
     * @implements INetworkAddress
     * @constructor
     * @param {INetworkAddress=} [properties] Properties to set
     */
    function NetworkAddress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkAddress hostId.
     * @member {Uint8Array} hostId
     * @memberof NetworkAddress
     * @instance
     */
    NetworkAddress.prototype.hostId = $util.newBuffer([]);

    /**
     * NetworkAddress port.
     * @member {number} port
     * @memberof NetworkAddress
     * @instance
     */
    NetworkAddress.prototype.port = 0;

    /**
     * Creates a new NetworkAddress instance using the specified properties.
     * @function create
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress=} [properties] Properties to set
     * @returns {NetworkAddress} NetworkAddress instance
     */
    NetworkAddress.create = function create(properties) {
        return new NetworkAddress(properties);
    };

    /**
     * Encodes the specified NetworkAddress message. Does not implicitly {@link NetworkAddress.verify|verify} messages.
     * @function encode
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress} message NetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkAddress.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hostId);
        if (message.port != null && Object.hasOwnProperty.call(message, "port"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
        return writer;
    };

    /**
     * Encodes the specified NetworkAddress message, length delimited. Does not implicitly {@link NetworkAddress.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress} message NetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkAddress message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkAddress} NetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkAddress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hostId = reader.bytes();
                break;
            case 2:
                message.port = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkAddress message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkAddress} NetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkAddress message.
     * @function verify
     * @memberof NetworkAddress
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                return "hostId: buffer expected";
        if (message.port != null && message.hasOwnProperty("port"))
            if (!$util.isInteger(message.port))
                return "port: integer expected";
        return null;
    };

    /**
     * Creates a NetworkAddress message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkAddress
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkAddress} NetworkAddress
     */
    NetworkAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkAddress)
            return object;
        let message = new $root.NetworkAddress();
        if (object.hostId != null)
            if (typeof object.hostId === "string")
                $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
            else if (object.hostId.length)
                message.hostId = object.hostId;
        if (object.port != null)
            message.port = object.port >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a NetworkAddress message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkAddress
     * @static
     * @param {NetworkAddress} message NetworkAddress
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkAddress.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.hostId = "";
            else {
                object.hostId = [];
                if (options.bytes !== Array)
                    object.hostId = $util.newBuffer(object.hostId);
            }
            object.port = 0;
        }
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
        if (message.port != null && message.hasOwnProperty("port"))
            object.port = message.port;
        return object;
    };

    /**
     * Converts this NetworkAddress to JSON.
     * @function toJSON
     * @memberof NetworkAddress
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NetworkAddress;
})();

export const VideoServerOpenRequest = $root.VideoServerOpenRequest = (() => {

    /**
     * Properties of a VideoServerOpenRequest.
     * @exports IVideoServerOpenRequest
     * @interface IVideoServerOpenRequest
     */

    /**
     * Constructs a new VideoServerOpenRequest.
     * @exports VideoServerOpenRequest
     * @classdesc Represents a VideoServerOpenRequest.
     * @implements IVideoServerOpenRequest
     * @constructor
     * @param {IVideoServerOpenRequest=} [properties] Properties to set
     */
    function VideoServerOpenRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new VideoServerOpenRequest instance using the specified properties.
     * @function create
     * @memberof VideoServerOpenRequest
     * @static
     * @param {IVideoServerOpenRequest=} [properties] Properties to set
     * @returns {VideoServerOpenRequest} VideoServerOpenRequest instance
     */
    VideoServerOpenRequest.create = function create(properties) {
        return new VideoServerOpenRequest(properties);
    };

    /**
     * Encodes the specified VideoServerOpenRequest message. Does not implicitly {@link VideoServerOpenRequest.verify|verify} messages.
     * @function encode
     * @memberof VideoServerOpenRequest
     * @static
     * @param {IVideoServerOpenRequest} message VideoServerOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified VideoServerOpenRequest message, length delimited. Does not implicitly {@link VideoServerOpenRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoServerOpenRequest
     * @static
     * @param {IVideoServerOpenRequest} message VideoServerOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoServerOpenRequest message from the specified reader or buffer.
     * @function decode
     * @memberof VideoServerOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoServerOpenRequest} VideoServerOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoServerOpenRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoServerOpenRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoServerOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoServerOpenRequest} VideoServerOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoServerOpenRequest message.
     * @function verify
     * @memberof VideoServerOpenRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoServerOpenRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a VideoServerOpenRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoServerOpenRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoServerOpenRequest} VideoServerOpenRequest
     */
    VideoServerOpenRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoServerOpenRequest)
            return object;
        return new $root.VideoServerOpenRequest();
    };

    /**
     * Creates a plain object from a VideoServerOpenRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoServerOpenRequest
     * @static
     * @param {VideoServerOpenRequest} message VideoServerOpenRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoServerOpenRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this VideoServerOpenRequest to JSON.
     * @function toJSON
     * @memberof VideoServerOpenRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoServerOpenRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoServerOpenRequest;
})();

export const VideoServerOpenResponse = $root.VideoServerOpenResponse = (() => {

    /**
     * Properties of a VideoServerOpenResponse.
     * @exports IVideoServerOpenResponse
     * @interface IVideoServerOpenResponse
     * @property {number|null} [id] VideoServerOpenResponse id
     */

    /**
     * Constructs a new VideoServerOpenResponse.
     * @exports VideoServerOpenResponse
     * @classdesc Represents a VideoServerOpenResponse.
     * @implements IVideoServerOpenResponse
     * @constructor
     * @param {IVideoServerOpenResponse=} [properties] Properties to set
     */
    function VideoServerOpenResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoServerOpenResponse id.
     * @member {number} id
     * @memberof VideoServerOpenResponse
     * @instance
     */
    VideoServerOpenResponse.prototype.id = 0;

    /**
     * Creates a new VideoServerOpenResponse instance using the specified properties.
     * @function create
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse=} [properties] Properties to set
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse instance
     */
    VideoServerOpenResponse.create = function create(properties) {
        return new VideoServerOpenResponse(properties);
    };

    /**
     * Encodes the specified VideoServerOpenResponse message. Does not implicitly {@link VideoServerOpenResponse.verify|verify} messages.
     * @function encode
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse} message VideoServerOpenResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        return writer;
    };

    /**
     * Encodes the specified VideoServerOpenResponse message, length delimited. Does not implicitly {@link VideoServerOpenResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse} message VideoServerOpenResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoServerOpenResponse message from the specified reader or buffer.
     * @function decode
     * @memberof VideoServerOpenResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoServerOpenResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoServerOpenResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoServerOpenResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoServerOpenResponse message.
     * @function verify
     * @memberof VideoServerOpenResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoServerOpenResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a VideoServerOpenResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoServerOpenResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     */
    VideoServerOpenResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoServerOpenResponse)
            return object;
        let message = new $root.VideoServerOpenResponse();
        if (object.id != null)
            message.id = object.id >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a VideoServerOpenResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoServerOpenResponse
     * @static
     * @param {VideoServerOpenResponse} message VideoServerOpenResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoServerOpenResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this VideoServerOpenResponse to JSON.
     * @function toJSON
     * @memberof VideoServerOpenResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoServerOpenResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoServerOpenResponse;
})();

export const VideoServerWriteRequest = $root.VideoServerWriteRequest = (() => {

    /**
     * Properties of a VideoServerWriteRequest.
     * @exports IVideoServerWriteRequest
     * @interface IVideoServerWriteRequest
     * @property {number|null} [id] VideoServerWriteRequest id
     * @property {Uint8Array|null} [data] VideoServerWriteRequest data
     * @property {boolean|null} [flush] VideoServerWriteRequest flush
     */

    /**
     * Constructs a new VideoServerWriteRequest.
     * @exports VideoServerWriteRequest
     * @classdesc Represents a VideoServerWriteRequest.
     * @implements IVideoServerWriteRequest
     * @constructor
     * @param {IVideoServerWriteRequest=} [properties] Properties to set
     */
    function VideoServerWriteRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoServerWriteRequest id.
     * @member {number} id
     * @memberof VideoServerWriteRequest
     * @instance
     */
    VideoServerWriteRequest.prototype.id = 0;

    /**
     * VideoServerWriteRequest data.
     * @member {Uint8Array} data
     * @memberof VideoServerWriteRequest
     * @instance
     */
    VideoServerWriteRequest.prototype.data = $util.newBuffer([]);

    /**
     * VideoServerWriteRequest flush.
     * @member {boolean} flush
     * @memberof VideoServerWriteRequest
     * @instance
     */
    VideoServerWriteRequest.prototype.flush = false;

    /**
     * Creates a new VideoServerWriteRequest instance using the specified properties.
     * @function create
     * @memberof VideoServerWriteRequest
     * @static
     * @param {IVideoServerWriteRequest=} [properties] Properties to set
     * @returns {VideoServerWriteRequest} VideoServerWriteRequest instance
     */
    VideoServerWriteRequest.create = function create(properties) {
        return new VideoServerWriteRequest(properties);
    };

    /**
     * Encodes the specified VideoServerWriteRequest message. Does not implicitly {@link VideoServerWriteRequest.verify|verify} messages.
     * @function encode
     * @memberof VideoServerWriteRequest
     * @static
     * @param {IVideoServerWriteRequest} message VideoServerWriteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerWriteRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.flush);
        return writer;
    };

    /**
     * Encodes the specified VideoServerWriteRequest message, length delimited. Does not implicitly {@link VideoServerWriteRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoServerWriteRequest
     * @static
     * @param {IVideoServerWriteRequest} message VideoServerWriteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerWriteRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoServerWriteRequest message from the specified reader or buffer.
     * @function decode
     * @memberof VideoServerWriteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoServerWriteRequest} VideoServerWriteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerWriteRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoServerWriteRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            case 3:
                message.flush = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoServerWriteRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoServerWriteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoServerWriteRequest} VideoServerWriteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerWriteRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoServerWriteRequest message.
     * @function verify
     * @memberof VideoServerWriteRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoServerWriteRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        if (message.flush != null && message.hasOwnProperty("flush"))
            if (typeof message.flush !== "boolean")
                return "flush: boolean expected";
        return null;
    };

    /**
     * Creates a VideoServerWriteRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoServerWriteRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoServerWriteRequest} VideoServerWriteRequest
     */
    VideoServerWriteRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoServerWriteRequest)
            return object;
        let message = new $root.VideoServerWriteRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        if (object.flush != null)
            message.flush = Boolean(object.flush);
        return message;
    };

    /**
     * Creates a plain object from a VideoServerWriteRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoServerWriteRequest
     * @static
     * @param {VideoServerWriteRequest} message VideoServerWriteRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoServerWriteRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
            object.flush = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        if (message.flush != null && message.hasOwnProperty("flush"))
            object.flush = message.flush;
        return object;
    };

    /**
     * Converts this VideoServerWriteRequest to JSON.
     * @function toJSON
     * @memberof VideoServerWriteRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoServerWriteRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoServerWriteRequest;
})();

export const VideoServerWriteResponse = $root.VideoServerWriteResponse = (() => {

    /**
     * Properties of a VideoServerWriteResponse.
     * @exports IVideoServerWriteResponse
     * @interface IVideoServerWriteResponse
     */

    /**
     * Constructs a new VideoServerWriteResponse.
     * @exports VideoServerWriteResponse
     * @classdesc Represents a VideoServerWriteResponse.
     * @implements IVideoServerWriteResponse
     * @constructor
     * @param {IVideoServerWriteResponse=} [properties] Properties to set
     */
    function VideoServerWriteResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new VideoServerWriteResponse instance using the specified properties.
     * @function create
     * @memberof VideoServerWriteResponse
     * @static
     * @param {IVideoServerWriteResponse=} [properties] Properties to set
     * @returns {VideoServerWriteResponse} VideoServerWriteResponse instance
     */
    VideoServerWriteResponse.create = function create(properties) {
        return new VideoServerWriteResponse(properties);
    };

    /**
     * Encodes the specified VideoServerWriteResponse message. Does not implicitly {@link VideoServerWriteResponse.verify|verify} messages.
     * @function encode
     * @memberof VideoServerWriteResponse
     * @static
     * @param {IVideoServerWriteResponse} message VideoServerWriteResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerWriteResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified VideoServerWriteResponse message, length delimited. Does not implicitly {@link VideoServerWriteResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoServerWriteResponse
     * @static
     * @param {IVideoServerWriteResponse} message VideoServerWriteResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerWriteResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoServerWriteResponse message from the specified reader or buffer.
     * @function decode
     * @memberof VideoServerWriteResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoServerWriteResponse} VideoServerWriteResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerWriteResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoServerWriteResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoServerWriteResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoServerWriteResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoServerWriteResponse} VideoServerWriteResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerWriteResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoServerWriteResponse message.
     * @function verify
     * @memberof VideoServerWriteResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoServerWriteResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a VideoServerWriteResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoServerWriteResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoServerWriteResponse} VideoServerWriteResponse
     */
    VideoServerWriteResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoServerWriteResponse)
            return object;
        return new $root.VideoServerWriteResponse();
    };

    /**
     * Creates a plain object from a VideoServerWriteResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoServerWriteResponse
     * @static
     * @param {VideoServerWriteResponse} message VideoServerWriteResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoServerWriteResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this VideoServerWriteResponse to JSON.
     * @function toJSON
     * @memberof VideoServerWriteResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoServerWriteResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoServerWriteResponse;
})();

export const VideoClientOpenRequest = $root.VideoClientOpenRequest = (() => {

    /**
     * Properties of a VideoClientOpenRequest.
     * @exports IVideoClientOpenRequest
     * @interface IVideoClientOpenRequest
     */

    /**
     * Constructs a new VideoClientOpenRequest.
     * @exports VideoClientOpenRequest
     * @classdesc Represents a VideoClientOpenRequest.
     * @implements IVideoClientOpenRequest
     * @constructor
     * @param {IVideoClientOpenRequest=} [properties] Properties to set
     */
    function VideoClientOpenRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new VideoClientOpenRequest instance using the specified properties.
     * @function create
     * @memberof VideoClientOpenRequest
     * @static
     * @param {IVideoClientOpenRequest=} [properties] Properties to set
     * @returns {VideoClientOpenRequest} VideoClientOpenRequest instance
     */
    VideoClientOpenRequest.create = function create(properties) {
        return new VideoClientOpenRequest(properties);
    };

    /**
     * Encodes the specified VideoClientOpenRequest message. Does not implicitly {@link VideoClientOpenRequest.verify|verify} messages.
     * @function encode
     * @memberof VideoClientOpenRequest
     * @static
     * @param {IVideoClientOpenRequest} message VideoClientOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientOpenRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified VideoClientOpenRequest message, length delimited. Does not implicitly {@link VideoClientOpenRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoClientOpenRequest
     * @static
     * @param {IVideoClientOpenRequest} message VideoClientOpenRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientOpenRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoClientOpenRequest message from the specified reader or buffer.
     * @function decode
     * @memberof VideoClientOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoClientOpenRequest} VideoClientOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientOpenRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientOpenRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoClientOpenRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoClientOpenRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoClientOpenRequest} VideoClientOpenRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientOpenRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoClientOpenRequest message.
     * @function verify
     * @memberof VideoClientOpenRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoClientOpenRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a VideoClientOpenRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoClientOpenRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoClientOpenRequest} VideoClientOpenRequest
     */
    VideoClientOpenRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoClientOpenRequest)
            return object;
        return new $root.VideoClientOpenRequest();
    };

    /**
     * Creates a plain object from a VideoClientOpenRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoClientOpenRequest
     * @static
     * @param {VideoClientOpenRequest} message VideoClientOpenRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoClientOpenRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this VideoClientOpenRequest to JSON.
     * @function toJSON
     * @memberof VideoClientOpenRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoClientOpenRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoClientOpenRequest;
})();

export const VideoClientEvent = $root.VideoClientEvent = (() => {

    /**
     * Properties of a VideoClientEvent.
     * @exports IVideoClientEvent
     * @interface IVideoClientEvent
     * @property {VideoClientEvent.IData|null} [data] VideoClientEvent data
     * @property {VideoClientEvent.IOpen|null} [open] VideoClientEvent open
     * @property {VideoClientEvent.IClose|null} [close] VideoClientEvent close
     */

    /**
     * Constructs a new VideoClientEvent.
     * @exports VideoClientEvent
     * @classdesc Represents a VideoClientEvent.
     * @implements IVideoClientEvent
     * @constructor
     * @param {IVideoClientEvent=} [properties] Properties to set
     */
    function VideoClientEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoClientEvent data.
     * @member {VideoClientEvent.IData|null|undefined} data
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.data = null;

    /**
     * VideoClientEvent open.
     * @member {VideoClientEvent.IOpen|null|undefined} open
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.open = null;

    /**
     * VideoClientEvent close.
     * @member {VideoClientEvent.IClose|null|undefined} close
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * VideoClientEvent body.
     * @member {"data"|"open"|"close"|undefined} body
     * @memberof VideoClientEvent
     * @instance
     */
    Object.defineProperty(VideoClientEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["data", "open", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new VideoClientEvent instance using the specified properties.
     * @function create
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent=} [properties] Properties to set
     * @returns {VideoClientEvent} VideoClientEvent instance
     */
    VideoClientEvent.create = function create(properties) {
        return new VideoClientEvent(properties);
    };

    /**
     * Encodes the specified VideoClientEvent message. Does not implicitly {@link VideoClientEvent.verify|verify} messages.
     * @function encode
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent} message VideoClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.VideoClientEvent.Data.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.VideoClientEvent.Open.encode(message.open, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.VideoClientEvent.Close.encode(message.close, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VideoClientEvent message, length delimited. Does not implicitly {@link VideoClientEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent} message VideoClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoClientEvent message from the specified reader or buffer.
     * @function decode
     * @memberof VideoClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoClientEvent} VideoClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = $root.VideoClientEvent.Data.decode(reader, reader.uint32());
                break;
            case 2:
                message.open = $root.VideoClientEvent.Open.decode(reader, reader.uint32());
                break;
            case 3:
                message.close = $root.VideoClientEvent.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoClientEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoClientEvent} VideoClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoClientEvent message.
     * @function verify
     * @memberof VideoClientEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoClientEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.data != null && message.hasOwnProperty("data")) {
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VideoClientEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoClientEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoClientEvent} VideoClientEvent
     */
    VideoClientEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoClientEvent)
            return object;
        let message = new $root.VideoClientEvent();
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".VideoClientEvent.data: object expected");
            message.data = $root.VideoClientEvent.Data.fromObject(object.data);
        }
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".VideoClientEvent.open: object expected");
            message.open = $root.VideoClientEvent.Open.fromObject(object.open);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".VideoClientEvent.close: object expected");
            message.close = $root.VideoClientEvent.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a VideoClientEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoClientEvent
     * @static
     * @param {VideoClientEvent} message VideoClientEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoClientEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.VideoClientEvent.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.VideoClientEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.VideoClientEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this VideoClientEvent to JSON.
     * @function toJSON
     * @memberof VideoClientEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoClientEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    VideoClientEvent.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof VideoClientEvent
         * @interface IData
         * @property {Uint8Array|null} [data] Data data
         * @property {boolean|null} [flush] Data flush
         */

        /**
         * Constructs a new Data.
         * @memberof VideoClientEvent
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {VideoClientEvent.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data data.
         * @member {Uint8Array} data
         * @memberof VideoClientEvent.Data
         * @instance
         */
        Data.prototype.data = $util.newBuffer([]);

        /**
         * Data flush.
         * @member {boolean} flush
         * @memberof VideoClientEvent.Data
         * @instance
         */
        Data.prototype.flush = false;

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData=} [properties] Properties to set
         * @returns {VideoClientEvent.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link VideoClientEvent.Data.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.flush);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link VideoClientEvent.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.flush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof VideoClientEvent.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.flush != null && message.hasOwnProperty("flush"))
                if (typeof message.flush !== "boolean")
                    return "flush: boolean expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Data)
                return object;
            let message = new $root.VideoClientEvent.Data();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.flush != null)
                message.flush = Boolean(object.flush);
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.flush = false;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.flush != null && message.hasOwnProperty("flush"))
                object.flush = message.flush;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    VideoClientEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof VideoClientEvent
         * @interface IOpen
         * @property {number|null} [id] Open id
         */

        /**
         * Constructs a new Open.
         * @memberof VideoClientEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {VideoClientEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open id.
         * @member {number} id
         * @memberof VideoClientEvent.Open
         * @instance
         */
        Open.prototype.id = 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen=} [properties] Properties to set
         * @returns {VideoClientEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link VideoClientEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link VideoClientEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof VideoClientEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Open)
                return object;
            let message = new $root.VideoClientEvent.Open();
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    VideoClientEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof VideoClientEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof VideoClientEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {VideoClientEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose=} [properties] Properties to set
         * @returns {VideoClientEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link VideoClientEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link VideoClientEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof VideoClientEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Close)
                return object;
            return new $root.VideoClientEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return VideoClientEvent;
})();

export const VideoClientCallRequest = $root.VideoClientCallRequest = (() => {

    /**
     * Properties of a VideoClientCallRequest.
     * @exports IVideoClientCallRequest
     * @interface IVideoClientCallRequest
     * @property {number|null} [id] VideoClientCallRequest id
     * @property {VideoClientCallRequest.IData|null} [data] VideoClientCallRequest data
     * @property {VideoClientCallRequest.IRunClient|null} [runClient] VideoClientCallRequest runClient
     * @property {VideoClientCallRequest.IRunServer|null} [runServer] VideoClientCallRequest runServer
     */

    /**
     * Constructs a new VideoClientCallRequest.
     * @exports VideoClientCallRequest
     * @classdesc Represents a VideoClientCallRequest.
     * @implements IVideoClientCallRequest
     * @constructor
     * @param {IVideoClientCallRequest=} [properties] Properties to set
     */
    function VideoClientCallRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoClientCallRequest id.
     * @member {number} id
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.id = 0;

    /**
     * VideoClientCallRequest data.
     * @member {VideoClientCallRequest.IData|null|undefined} data
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.data = null;

    /**
     * VideoClientCallRequest runClient.
     * @member {VideoClientCallRequest.IRunClient|null|undefined} runClient
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.runClient = null;

    /**
     * VideoClientCallRequest runServer.
     * @member {VideoClientCallRequest.IRunServer|null|undefined} runServer
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.runServer = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * VideoClientCallRequest body.
     * @member {"data"|"runClient"|"runServer"|undefined} body
     * @memberof VideoClientCallRequest
     * @instance
     */
    Object.defineProperty(VideoClientCallRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["data", "runClient", "runServer"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new VideoClientCallRequest instance using the specified properties.
     * @function create
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest=} [properties] Properties to set
     * @returns {VideoClientCallRequest} VideoClientCallRequest instance
     */
    VideoClientCallRequest.create = function create(properties) {
        return new VideoClientCallRequest(properties);
    };

    /**
     * Encodes the specified VideoClientCallRequest message. Does not implicitly {@link VideoClientCallRequest.verify|verify} messages.
     * @function encode
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest} message VideoClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientCallRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.VideoClientCallRequest.Data.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.runClient != null && Object.hasOwnProperty.call(message, "runClient"))
            $root.VideoClientCallRequest.RunClient.encode(message.runClient, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.runServer != null && Object.hasOwnProperty.call(message, "runServer"))
            $root.VideoClientCallRequest.RunServer.encode(message.runServer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VideoClientCallRequest message, length delimited. Does not implicitly {@link VideoClientCallRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest} message VideoClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientCallRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoClientCallRequest message from the specified reader or buffer.
     * @function decode
     * @memberof VideoClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientCallRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            case 2:
                message.data = $root.VideoClientCallRequest.Data.decode(reader, reader.uint32());
                break;
            case 3:
                message.runClient = $root.VideoClientCallRequest.RunClient.decode(reader, reader.uint32());
                break;
            case 4:
                message.runServer = $root.VideoClientCallRequest.RunServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoClientCallRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientCallRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoClientCallRequest message.
     * @function verify
     * @memberof VideoClientCallRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoClientCallRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.data != null && message.hasOwnProperty("data")) {
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.RunClient.verify(message.runClient);
                if (error)
                    return "runClient." + error;
            }
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.RunServer.verify(message.runServer);
                if (error)
                    return "runServer." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VideoClientCallRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoClientCallRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     */
    VideoClientCallRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoClientCallRequest)
            return object;
        let message = new $root.VideoClientCallRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".VideoClientCallRequest.data: object expected");
            message.data = $root.VideoClientCallRequest.Data.fromObject(object.data);
        }
        if (object.runClient != null) {
            if (typeof object.runClient !== "object")
                throw TypeError(".VideoClientCallRequest.runClient: object expected");
            message.runClient = $root.VideoClientCallRequest.RunClient.fromObject(object.runClient);
        }
        if (object.runServer != null) {
            if (typeof object.runServer !== "object")
                throw TypeError(".VideoClientCallRequest.runServer: object expected");
            message.runServer = $root.VideoClientCallRequest.RunServer.fromObject(object.runServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a VideoClientCallRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoClientCallRequest
     * @static
     * @param {VideoClientCallRequest} message VideoClientCallRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoClientCallRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.VideoClientCallRequest.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            object.runClient = $root.VideoClientCallRequest.RunClient.toObject(message.runClient, options);
            if (options.oneofs)
                object.body = "runClient";
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            object.runServer = $root.VideoClientCallRequest.RunServer.toObject(message.runServer, options);
            if (options.oneofs)
                object.body = "runServer";
        }
        return object;
    };

    /**
     * Converts this VideoClientCallRequest to JSON.
     * @function toJSON
     * @memberof VideoClientCallRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoClientCallRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    VideoClientCallRequest.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof VideoClientCallRequest
         * @interface IData
         * @property {Uint8Array|null} [body] Data body
         */

        /**
         * Constructs a new Data.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {VideoClientCallRequest.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data body.
         * @member {Uint8Array} body
         * @memberof VideoClientCallRequest.Data
         * @instance
         */
        Data.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData=} [properties] Properties to set
         * @returns {VideoClientCallRequest.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link VideoClientCallRequest.Data.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link VideoClientCallRequest.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.Data)
                return object;
            let message = new $root.VideoClientCallRequest.Data();
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    VideoClientCallRequest.RunServer = (function() {

        /**
         * Properties of a RunServer.
         * @memberof VideoClientCallRequest
         * @interface IRunServer
         */

        /**
         * Constructs a new RunServer.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a RunServer.
         * @implements IRunServer
         * @constructor
         * @param {VideoClientCallRequest.IRunServer=} [properties] Properties to set
         */
        function RunServer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunServer instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer=} [properties] Properties to set
         * @returns {VideoClientCallRequest.RunServer} RunServer instance
         */
        RunServer.create = function create(properties) {
            return new RunServer(properties);
        };

        /**
         * Encodes the specified RunServer message. Does not implicitly {@link VideoClientCallRequest.RunServer.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunServer message, length delimited. Does not implicitly {@link VideoClientCallRequest.RunServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.RunServer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunServer message.
         * @function verify
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.RunServer} RunServer
         */
        RunServer.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.RunServer)
                return object;
            return new $root.VideoClientCallRequest.RunServer();
        };

        /**
         * Creates a plain object from a RunServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.RunServer} message RunServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunServer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunServer to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.RunServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunServer;
    })();

    VideoClientCallRequest.RunClient = (function() {

        /**
         * Properties of a RunClient.
         * @memberof VideoClientCallRequest
         * @interface IRunClient
         */

        /**
         * Constructs a new RunClient.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a RunClient.
         * @implements IRunClient
         * @constructor
         * @param {VideoClientCallRequest.IRunClient=} [properties] Properties to set
         */
        function RunClient(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunClient instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient=} [properties] Properties to set
         * @returns {VideoClientCallRequest.RunClient} RunClient instance
         */
        RunClient.create = function create(properties) {
            return new RunClient(properties);
        };

        /**
         * Encodes the specified RunClient message. Does not implicitly {@link VideoClientCallRequest.RunClient.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunClient message, length delimited. Does not implicitly {@link VideoClientCallRequest.RunClient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.RunClient();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunClient message.
         * @function verify
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunClient.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunClient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.RunClient} RunClient
         */
        RunClient.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.RunClient)
                return object;
            return new $root.VideoClientCallRequest.RunClient();
        };

        /**
         * Creates a plain object from a RunClient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.RunClient} message RunClient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunClient.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunClient to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.RunClient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunClient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunClient;
    })();

    return VideoClientCallRequest;
})();

export const StartVPNRequest = $root.StartVPNRequest = (() => {

    /**
     * Properties of a StartVPNRequest.
     * @exports IStartVPNRequest
     * @interface IStartVPNRequest
     */

    /**
     * Constructs a new StartVPNRequest.
     * @exports StartVPNRequest
     * @classdesc Represents a StartVPNRequest.
     * @implements IStartVPNRequest
     * @constructor
     * @param {IStartVPNRequest=} [properties] Properties to set
     */
    function StartVPNRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartVPNRequest instance using the specified properties.
     * @function create
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest=} [properties] Properties to set
     * @returns {StartVPNRequest} StartVPNRequest instance
     */
    StartVPNRequest.create = function create(properties) {
        return new StartVPNRequest(properties);
    };

    /**
     * Encodes the specified StartVPNRequest message. Does not implicitly {@link StartVPNRequest.verify|verify} messages.
     * @function encode
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest} message StartVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartVPNRequest message, length delimited. Does not implicitly {@link StartVPNRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest} message StartVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartVPNRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartVPNRequest} StartVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartVPNRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartVPNRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartVPNRequest} StartVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartVPNRequest message.
     * @function verify
     * @memberof StartVPNRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartVPNRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartVPNRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartVPNRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartVPNRequest} StartVPNRequest
     */
    StartVPNRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartVPNRequest)
            return object;
        return new $root.StartVPNRequest();
    };

    /**
     * Creates a plain object from a StartVPNRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartVPNRequest
     * @static
     * @param {StartVPNRequest} message StartVPNRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartVPNRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartVPNRequest to JSON.
     * @function toJSON
     * @memberof StartVPNRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartVPNRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartVPNRequest;
})();

export const StartVPNResponse = $root.StartVPNResponse = (() => {

    /**
     * Properties of a StartVPNResponse.
     * @exports IStartVPNResponse
     * @interface IStartVPNResponse
     */

    /**
     * Constructs a new StartVPNResponse.
     * @exports StartVPNResponse
     * @classdesc Represents a StartVPNResponse.
     * @implements IStartVPNResponse
     * @constructor
     * @param {IStartVPNResponse=} [properties] Properties to set
     */
    function StartVPNResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartVPNResponse instance using the specified properties.
     * @function create
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse=} [properties] Properties to set
     * @returns {StartVPNResponse} StartVPNResponse instance
     */
    StartVPNResponse.create = function create(properties) {
        return new StartVPNResponse(properties);
    };

    /**
     * Encodes the specified StartVPNResponse message. Does not implicitly {@link StartVPNResponse.verify|verify} messages.
     * @function encode
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse} message StartVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartVPNResponse message, length delimited. Does not implicitly {@link StartVPNResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse} message StartVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartVPNResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartVPNResponse} StartVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartVPNResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartVPNResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartVPNResponse} StartVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartVPNResponse message.
     * @function verify
     * @memberof StartVPNResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartVPNResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartVPNResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartVPNResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartVPNResponse} StartVPNResponse
     */
    StartVPNResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartVPNResponse)
            return object;
        return new $root.StartVPNResponse();
    };

    /**
     * Creates a plain object from a StartVPNResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartVPNResponse
     * @static
     * @param {StartVPNResponse} message StartVPNResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartVPNResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartVPNResponse to JSON.
     * @function toJSON
     * @memberof StartVPNResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartVPNResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartVPNResponse;
})();

export const StopVPNRequest = $root.StopVPNRequest = (() => {

    /**
     * Properties of a StopVPNRequest.
     * @exports IStopVPNRequest
     * @interface IStopVPNRequest
     */

    /**
     * Constructs a new StopVPNRequest.
     * @exports StopVPNRequest
     * @classdesc Represents a StopVPNRequest.
     * @implements IStopVPNRequest
     * @constructor
     * @param {IStopVPNRequest=} [properties] Properties to set
     */
    function StopVPNRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopVPNRequest instance using the specified properties.
     * @function create
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest=} [properties] Properties to set
     * @returns {StopVPNRequest} StopVPNRequest instance
     */
    StopVPNRequest.create = function create(properties) {
        return new StopVPNRequest(properties);
    };

    /**
     * Encodes the specified StopVPNRequest message. Does not implicitly {@link StopVPNRequest.verify|verify} messages.
     * @function encode
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest} message StopVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopVPNRequest message, length delimited. Does not implicitly {@link StopVPNRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest} message StopVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopVPNRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopVPNRequest} StopVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopVPNRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopVPNRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopVPNRequest} StopVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopVPNRequest message.
     * @function verify
     * @memberof StopVPNRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopVPNRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopVPNRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopVPNRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopVPNRequest} StopVPNRequest
     */
    StopVPNRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopVPNRequest)
            return object;
        return new $root.StopVPNRequest();
    };

    /**
     * Creates a plain object from a StopVPNRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopVPNRequest
     * @static
     * @param {StopVPNRequest} message StopVPNRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopVPNRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopVPNRequest to JSON.
     * @function toJSON
     * @memberof StopVPNRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopVPNRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopVPNRequest;
})();

export const StopVPNResponse = $root.StopVPNResponse = (() => {

    /**
     * Properties of a StopVPNResponse.
     * @exports IStopVPNResponse
     * @interface IStopVPNResponse
     */

    /**
     * Constructs a new StopVPNResponse.
     * @exports StopVPNResponse
     * @classdesc Represents a StopVPNResponse.
     * @implements IStopVPNResponse
     * @constructor
     * @param {IStopVPNResponse=} [properties] Properties to set
     */
    function StopVPNResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopVPNResponse instance using the specified properties.
     * @function create
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse=} [properties] Properties to set
     * @returns {StopVPNResponse} StopVPNResponse instance
     */
    StopVPNResponse.create = function create(properties) {
        return new StopVPNResponse(properties);
    };

    /**
     * Encodes the specified StopVPNResponse message. Does not implicitly {@link StopVPNResponse.verify|verify} messages.
     * @function encode
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse} message StopVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopVPNResponse message, length delimited. Does not implicitly {@link StopVPNResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse} message StopVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopVPNResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopVPNResponse} StopVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopVPNResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopVPNResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopVPNResponse} StopVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopVPNResponse message.
     * @function verify
     * @memberof StopVPNResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopVPNResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopVPNResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopVPNResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopVPNResponse} StopVPNResponse
     */
    StopVPNResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopVPNResponse)
            return object;
        return new $root.StopVPNResponse();
    };

    /**
     * Creates a plain object from a StopVPNResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopVPNResponse
     * @static
     * @param {StopVPNResponse} message StopVPNResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopVPNResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopVPNResponse to JSON.
     * @function toJSON
     * @memberof StopVPNResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopVPNResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopVPNResponse;
})();

export const JoinSwarmRequest = $root.JoinSwarmRequest = (() => {

    /**
     * Properties of a JoinSwarmRequest.
     * @exports IJoinSwarmRequest
     * @interface IJoinSwarmRequest
     * @property {string|null} [swarmUri] JoinSwarmRequest swarmUri
     */

    /**
     * Constructs a new JoinSwarmRequest.
     * @exports JoinSwarmRequest
     * @classdesc Represents a JoinSwarmRequest.
     * @implements IJoinSwarmRequest
     * @constructor
     * @param {IJoinSwarmRequest=} [properties] Properties to set
     */
    function JoinSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * JoinSwarmRequest swarmUri.
     * @member {string} swarmUri
     * @memberof JoinSwarmRequest
     * @instance
     */
    JoinSwarmRequest.prototype.swarmUri = "";

    /**
     * Creates a new JoinSwarmRequest instance using the specified properties.
     * @function create
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest=} [properties] Properties to set
     * @returns {JoinSwarmRequest} JoinSwarmRequest instance
     */
    JoinSwarmRequest.create = function create(properties) {
        return new JoinSwarmRequest(properties);
    };

    /**
     * Encodes the specified JoinSwarmRequest message. Does not implicitly {@link JoinSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest} message JoinSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified JoinSwarmRequest message, length delimited. Does not implicitly {@link JoinSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest} message JoinSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a JoinSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof JoinSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.JoinSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a JoinSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof JoinSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a JoinSwarmRequest message.
     * @function verify
     * @memberof JoinSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    JoinSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a JoinSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof JoinSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     */
    JoinSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.JoinSwarmRequest)
            return object;
        let message = new $root.JoinSwarmRequest();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a JoinSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof JoinSwarmRequest
     * @static
     * @param {JoinSwarmRequest} message JoinSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    JoinSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this JoinSwarmRequest to JSON.
     * @function toJSON
     * @memberof JoinSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    JoinSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return JoinSwarmRequest;
})();

export const JoinSwarmResponse = $root.JoinSwarmResponse = (() => {

    /**
     * Properties of a JoinSwarmResponse.
     * @exports IJoinSwarmResponse
     * @interface IJoinSwarmResponse
     */

    /**
     * Constructs a new JoinSwarmResponse.
     * @exports JoinSwarmResponse
     * @classdesc Represents a JoinSwarmResponse.
     * @implements IJoinSwarmResponse
     * @constructor
     * @param {IJoinSwarmResponse=} [properties] Properties to set
     */
    function JoinSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new JoinSwarmResponse instance using the specified properties.
     * @function create
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse=} [properties] Properties to set
     * @returns {JoinSwarmResponse} JoinSwarmResponse instance
     */
    JoinSwarmResponse.create = function create(properties) {
        return new JoinSwarmResponse(properties);
    };

    /**
     * Encodes the specified JoinSwarmResponse message. Does not implicitly {@link JoinSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse} message JoinSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified JoinSwarmResponse message, length delimited. Does not implicitly {@link JoinSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse} message JoinSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a JoinSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof JoinSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.JoinSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a JoinSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof JoinSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a JoinSwarmResponse message.
     * @function verify
     * @memberof JoinSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    JoinSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a JoinSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof JoinSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     */
    JoinSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.JoinSwarmResponse)
            return object;
        return new $root.JoinSwarmResponse();
    };

    /**
     * Creates a plain object from a JoinSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof JoinSwarmResponse
     * @static
     * @param {JoinSwarmResponse} message JoinSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    JoinSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this JoinSwarmResponse to JSON.
     * @function toJSON
     * @memberof JoinSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    JoinSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return JoinSwarmResponse;
})();

export const LeaveSwarmRequest = $root.LeaveSwarmRequest = (() => {

    /**
     * Properties of a LeaveSwarmRequest.
     * @exports ILeaveSwarmRequest
     * @interface ILeaveSwarmRequest
     * @property {string|null} [swarmUri] LeaveSwarmRequest swarmUri
     */

    /**
     * Constructs a new LeaveSwarmRequest.
     * @exports LeaveSwarmRequest
     * @classdesc Represents a LeaveSwarmRequest.
     * @implements ILeaveSwarmRequest
     * @constructor
     * @param {ILeaveSwarmRequest=} [properties] Properties to set
     */
    function LeaveSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LeaveSwarmRequest swarmUri.
     * @member {string} swarmUri
     * @memberof LeaveSwarmRequest
     * @instance
     */
    LeaveSwarmRequest.prototype.swarmUri = "";

    /**
     * Creates a new LeaveSwarmRequest instance using the specified properties.
     * @function create
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest=} [properties] Properties to set
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest instance
     */
    LeaveSwarmRequest.create = function create(properties) {
        return new LeaveSwarmRequest(properties);
    };

    /**
     * Encodes the specified LeaveSwarmRequest message. Does not implicitly {@link LeaveSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest} message LeaveSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified LeaveSwarmRequest message, length delimited. Does not implicitly {@link LeaveSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest} message LeaveSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LeaveSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LeaveSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LeaveSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LeaveSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LeaveSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LeaveSwarmRequest message.
     * @function verify
     * @memberof LeaveSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LeaveSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a LeaveSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LeaveSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     */
    LeaveSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LeaveSwarmRequest)
            return object;
        let message = new $root.LeaveSwarmRequest();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a LeaveSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LeaveSwarmRequest
     * @static
     * @param {LeaveSwarmRequest} message LeaveSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LeaveSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this LeaveSwarmRequest to JSON.
     * @function toJSON
     * @memberof LeaveSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LeaveSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LeaveSwarmRequest;
})();

export const LeaveSwarmResponse = $root.LeaveSwarmResponse = (() => {

    /**
     * Properties of a LeaveSwarmResponse.
     * @exports ILeaveSwarmResponse
     * @interface ILeaveSwarmResponse
     */

    /**
     * Constructs a new LeaveSwarmResponse.
     * @exports LeaveSwarmResponse
     * @classdesc Represents a LeaveSwarmResponse.
     * @implements ILeaveSwarmResponse
     * @constructor
     * @param {ILeaveSwarmResponse=} [properties] Properties to set
     */
    function LeaveSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new LeaveSwarmResponse instance using the specified properties.
     * @function create
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse=} [properties] Properties to set
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse instance
     */
    LeaveSwarmResponse.create = function create(properties) {
        return new LeaveSwarmResponse(properties);
    };

    /**
     * Encodes the specified LeaveSwarmResponse message. Does not implicitly {@link LeaveSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse} message LeaveSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified LeaveSwarmResponse message, length delimited. Does not implicitly {@link LeaveSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse} message LeaveSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LeaveSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LeaveSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LeaveSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LeaveSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LeaveSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LeaveSwarmResponse message.
     * @function verify
     * @memberof LeaveSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LeaveSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a LeaveSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LeaveSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     */
    LeaveSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LeaveSwarmResponse)
            return object;
        return new $root.LeaveSwarmResponse();
    };

    /**
     * Creates a plain object from a LeaveSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LeaveSwarmResponse
     * @static
     * @param {LeaveSwarmResponse} message LeaveSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LeaveSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this LeaveSwarmResponse to JSON.
     * @function toJSON
     * @memberof LeaveSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LeaveSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LeaveSwarmResponse;
})();

export const GetIngressStreamsRequest = $root.GetIngressStreamsRequest = (() => {

    /**
     * Properties of a GetIngressStreamsRequest.
     * @exports IGetIngressStreamsRequest
     * @interface IGetIngressStreamsRequest
     */

    /**
     * Constructs a new GetIngressStreamsRequest.
     * @exports GetIngressStreamsRequest
     * @classdesc Represents a GetIngressStreamsRequest.
     * @implements IGetIngressStreamsRequest
     * @constructor
     * @param {IGetIngressStreamsRequest=} [properties] Properties to set
     */
    function GetIngressStreamsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetIngressStreamsRequest instance using the specified properties.
     * @function create
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest=} [properties] Properties to set
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest instance
     */
    GetIngressStreamsRequest.create = function create(properties) {
        return new GetIngressStreamsRequest(properties);
    };

    /**
     * Encodes the specified GetIngressStreamsRequest message. Does not implicitly {@link GetIngressStreamsRequest.verify|verify} messages.
     * @function encode
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest} message GetIngressStreamsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetIngressStreamsRequest message, length delimited. Does not implicitly {@link GetIngressStreamsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest} message GetIngressStreamsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetIngressStreamsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetIngressStreamsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetIngressStreamsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetIngressStreamsRequest message.
     * @function verify
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetIngressStreamsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetIngressStreamsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     */
    GetIngressStreamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetIngressStreamsRequest)
            return object;
        return new $root.GetIngressStreamsRequest();
    };

    /**
     * Creates a plain object from a GetIngressStreamsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {GetIngressStreamsRequest} message GetIngressStreamsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetIngressStreamsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetIngressStreamsRequest to JSON.
     * @function toJSON
     * @memberof GetIngressStreamsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetIngressStreamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetIngressStreamsRequest;
})();

export const GetIngressStreamsResponse = $root.GetIngressStreamsResponse = (() => {

    /**
     * Properties of a GetIngressStreamsResponse.
     * @exports IGetIngressStreamsResponse
     * @interface IGetIngressStreamsResponse
     * @property {string|null} [swarmUri] GetIngressStreamsResponse swarmUri
     */

    /**
     * Constructs a new GetIngressStreamsResponse.
     * @exports GetIngressStreamsResponse
     * @classdesc Represents a GetIngressStreamsResponse.
     * @implements IGetIngressStreamsResponse
     * @constructor
     * @param {IGetIngressStreamsResponse=} [properties] Properties to set
     */
    function GetIngressStreamsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetIngressStreamsResponse swarmUri.
     * @member {string} swarmUri
     * @memberof GetIngressStreamsResponse
     * @instance
     */
    GetIngressStreamsResponse.prototype.swarmUri = "";

    /**
     * Creates a new GetIngressStreamsResponse instance using the specified properties.
     * @function create
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse=} [properties] Properties to set
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse instance
     */
    GetIngressStreamsResponse.create = function create(properties) {
        return new GetIngressStreamsResponse(properties);
    };

    /**
     * Encodes the specified GetIngressStreamsResponse message. Does not implicitly {@link GetIngressStreamsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse} message GetIngressStreamsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified GetIngressStreamsResponse message, length delimited. Does not implicitly {@link GetIngressStreamsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse} message GetIngressStreamsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetIngressStreamsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetIngressStreamsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetIngressStreamsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetIngressStreamsResponse message.
     * @function verify
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetIngressStreamsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a GetIngressStreamsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     */
    GetIngressStreamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetIngressStreamsResponse)
            return object;
        let message = new $root.GetIngressStreamsResponse();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a GetIngressStreamsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {GetIngressStreamsResponse} message GetIngressStreamsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetIngressStreamsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this GetIngressStreamsResponse to JSON.
     * @function toJSON
     * @memberof GetIngressStreamsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetIngressStreamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetIngressStreamsResponse;
})();

export const StartHLSIngressRequest = $root.StartHLSIngressRequest = (() => {

    /**
     * Properties of a StartHLSIngressRequest.
     * @exports IStartHLSIngressRequest
     * @interface IStartHLSIngressRequest
     */

    /**
     * Constructs a new StartHLSIngressRequest.
     * @exports StartHLSIngressRequest
     * @classdesc Represents a StartHLSIngressRequest.
     * @implements IStartHLSIngressRequest
     * @constructor
     * @param {IStartHLSIngressRequest=} [properties] Properties to set
     */
    function StartHLSIngressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartHLSIngressRequest instance using the specified properties.
     * @function create
     * @memberof StartHLSIngressRequest
     * @static
     * @param {IStartHLSIngressRequest=} [properties] Properties to set
     * @returns {StartHLSIngressRequest} StartHLSIngressRequest instance
     */
    StartHLSIngressRequest.create = function create(properties) {
        return new StartHLSIngressRequest(properties);
    };

    /**
     * Encodes the specified StartHLSIngressRequest message. Does not implicitly {@link StartHLSIngressRequest.verify|verify} messages.
     * @function encode
     * @memberof StartHLSIngressRequest
     * @static
     * @param {IStartHLSIngressRequest} message StartHLSIngressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSIngressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartHLSIngressRequest message, length delimited. Does not implicitly {@link StartHLSIngressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSIngressRequest
     * @static
     * @param {IStartHLSIngressRequest} message StartHLSIngressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSIngressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSIngressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSIngressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSIngressRequest} StartHLSIngressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSIngressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSIngressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSIngressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSIngressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSIngressRequest} StartHLSIngressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSIngressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSIngressRequest message.
     * @function verify
     * @memberof StartHLSIngressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSIngressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartHLSIngressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSIngressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSIngressRequest} StartHLSIngressRequest
     */
    StartHLSIngressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSIngressRequest)
            return object;
        return new $root.StartHLSIngressRequest();
    };

    /**
     * Creates a plain object from a StartHLSIngressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSIngressRequest
     * @static
     * @param {StartHLSIngressRequest} message StartHLSIngressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSIngressRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartHLSIngressRequest to JSON.
     * @function toJSON
     * @memberof StartHLSIngressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSIngressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSIngressRequest;
})();

export const StartHLSIngressResponse = $root.StartHLSIngressResponse = (() => {

    /**
     * Properties of a StartHLSIngressResponse.
     * @exports IStartHLSIngressResponse
     * @interface IStartHLSIngressResponse
     */

    /**
     * Constructs a new StartHLSIngressResponse.
     * @exports StartHLSIngressResponse
     * @classdesc Represents a StartHLSIngressResponse.
     * @implements IStartHLSIngressResponse
     * @constructor
     * @param {IStartHLSIngressResponse=} [properties] Properties to set
     */
    function StartHLSIngressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartHLSIngressResponse instance using the specified properties.
     * @function create
     * @memberof StartHLSIngressResponse
     * @static
     * @param {IStartHLSIngressResponse=} [properties] Properties to set
     * @returns {StartHLSIngressResponse} StartHLSIngressResponse instance
     */
    StartHLSIngressResponse.create = function create(properties) {
        return new StartHLSIngressResponse(properties);
    };

    /**
     * Encodes the specified StartHLSIngressResponse message. Does not implicitly {@link StartHLSIngressResponse.verify|verify} messages.
     * @function encode
     * @memberof StartHLSIngressResponse
     * @static
     * @param {IStartHLSIngressResponse} message StartHLSIngressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSIngressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartHLSIngressResponse message, length delimited. Does not implicitly {@link StartHLSIngressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSIngressResponse
     * @static
     * @param {IStartHLSIngressResponse} message StartHLSIngressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSIngressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSIngressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSIngressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSIngressResponse} StartHLSIngressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSIngressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSIngressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSIngressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSIngressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSIngressResponse} StartHLSIngressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSIngressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSIngressResponse message.
     * @function verify
     * @memberof StartHLSIngressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSIngressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartHLSIngressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSIngressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSIngressResponse} StartHLSIngressResponse
     */
    StartHLSIngressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSIngressResponse)
            return object;
        return new $root.StartHLSIngressResponse();
    };

    /**
     * Creates a plain object from a StartHLSIngressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSIngressResponse
     * @static
     * @param {StartHLSIngressResponse} message StartHLSIngressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSIngressResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartHLSIngressResponse to JSON.
     * @function toJSON
     * @memberof StartHLSIngressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSIngressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSIngressResponse;
})();

export const StartHLSEgressRequest = $root.StartHLSEgressRequest = (() => {

    /**
     * Properties of a StartHLSEgressRequest.
     * @exports IStartHLSEgressRequest
     * @interface IStartHLSEgressRequest
     */

    /**
     * Constructs a new StartHLSEgressRequest.
     * @exports StartHLSEgressRequest
     * @classdesc Represents a StartHLSEgressRequest.
     * @implements IStartHLSEgressRequest
     * @constructor
     * @param {IStartHLSEgressRequest=} [properties] Properties to set
     */
    function StartHLSEgressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartHLSEgressRequest instance using the specified properties.
     * @function create
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest=} [properties] Properties to set
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest instance
     */
    StartHLSEgressRequest.create = function create(properties) {
        return new StartHLSEgressRequest(properties);
    };

    /**
     * Encodes the specified StartHLSEgressRequest message. Does not implicitly {@link StartHLSEgressRequest.verify|verify} messages.
     * @function encode
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest} message StartHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartHLSEgressRequest message, length delimited. Does not implicitly {@link StartHLSEgressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest} message StartHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSEgressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSEgressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSEgressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSEgressRequest message.
     * @function verify
     * @memberof StartHLSEgressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSEgressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartHLSEgressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSEgressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     */
    StartHLSEgressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSEgressRequest)
            return object;
        return new $root.StartHLSEgressRequest();
    };

    /**
     * Creates a plain object from a StartHLSEgressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSEgressRequest
     * @static
     * @param {StartHLSEgressRequest} message StartHLSEgressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSEgressRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartHLSEgressRequest to JSON.
     * @function toJSON
     * @memberof StartHLSEgressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSEgressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSEgressRequest;
})();

export const StartHLSEgressResponse = $root.StartHLSEgressResponse = (() => {

    /**
     * Properties of a StartHLSEgressResponse.
     * @exports IStartHLSEgressResponse
     * @interface IStartHLSEgressResponse
     */

    /**
     * Constructs a new StartHLSEgressResponse.
     * @exports StartHLSEgressResponse
     * @classdesc Represents a StartHLSEgressResponse.
     * @implements IStartHLSEgressResponse
     * @constructor
     * @param {IStartHLSEgressResponse=} [properties] Properties to set
     */
    function StartHLSEgressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartHLSEgressResponse instance using the specified properties.
     * @function create
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse=} [properties] Properties to set
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse instance
     */
    StartHLSEgressResponse.create = function create(properties) {
        return new StartHLSEgressResponse(properties);
    };

    /**
     * Encodes the specified StartHLSEgressResponse message. Does not implicitly {@link StartHLSEgressResponse.verify|verify} messages.
     * @function encode
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse} message StartHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartHLSEgressResponse message, length delimited. Does not implicitly {@link StartHLSEgressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse} message StartHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSEgressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSEgressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSEgressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSEgressResponse message.
     * @function verify
     * @memberof StartHLSEgressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSEgressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartHLSEgressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSEgressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     */
    StartHLSEgressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSEgressResponse)
            return object;
        return new $root.StartHLSEgressResponse();
    };

    /**
     * Creates a plain object from a StartHLSEgressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSEgressResponse
     * @static
     * @param {StartHLSEgressResponse} message StartHLSEgressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSEgressResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartHLSEgressResponse to JSON.
     * @function toJSON
     * @memberof StartHLSEgressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSEgressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSEgressResponse;
})();

export const StopHLSEgressRequest = $root.StopHLSEgressRequest = (() => {

    /**
     * Properties of a StopHLSEgressRequest.
     * @exports IStopHLSEgressRequest
     * @interface IStopHLSEgressRequest
     */

    /**
     * Constructs a new StopHLSEgressRequest.
     * @exports StopHLSEgressRequest
     * @classdesc Represents a StopHLSEgressRequest.
     * @implements IStopHLSEgressRequest
     * @constructor
     * @param {IStopHLSEgressRequest=} [properties] Properties to set
     */
    function StopHLSEgressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopHLSEgressRequest instance using the specified properties.
     * @function create
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest=} [properties] Properties to set
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest instance
     */
    StopHLSEgressRequest.create = function create(properties) {
        return new StopHLSEgressRequest(properties);
    };

    /**
     * Encodes the specified StopHLSEgressRequest message. Does not implicitly {@link StopHLSEgressRequest.verify|verify} messages.
     * @function encode
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest} message StopHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopHLSEgressRequest message, length delimited. Does not implicitly {@link StopHLSEgressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest} message StopHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopHLSEgressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopHLSEgressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopHLSEgressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopHLSEgressRequest message.
     * @function verify
     * @memberof StopHLSEgressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopHLSEgressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopHLSEgressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopHLSEgressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     */
    StopHLSEgressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopHLSEgressRequest)
            return object;
        return new $root.StopHLSEgressRequest();
    };

    /**
     * Creates a plain object from a StopHLSEgressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopHLSEgressRequest
     * @static
     * @param {StopHLSEgressRequest} message StopHLSEgressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopHLSEgressRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopHLSEgressRequest to JSON.
     * @function toJSON
     * @memberof StopHLSEgressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopHLSEgressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopHLSEgressRequest;
})();

export const StopHLSEgressResponse = $root.StopHLSEgressResponse = (() => {

    /**
     * Properties of a StopHLSEgressResponse.
     * @exports IStopHLSEgressResponse
     * @interface IStopHLSEgressResponse
     */

    /**
     * Constructs a new StopHLSEgressResponse.
     * @exports StopHLSEgressResponse
     * @classdesc Represents a StopHLSEgressResponse.
     * @implements IStopHLSEgressResponse
     * @constructor
     * @param {IStopHLSEgressResponse=} [properties] Properties to set
     */
    function StopHLSEgressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopHLSEgressResponse instance using the specified properties.
     * @function create
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse=} [properties] Properties to set
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse instance
     */
    StopHLSEgressResponse.create = function create(properties) {
        return new StopHLSEgressResponse(properties);
    };

    /**
     * Encodes the specified StopHLSEgressResponse message. Does not implicitly {@link StopHLSEgressResponse.verify|verify} messages.
     * @function encode
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse} message StopHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopHLSEgressResponse message, length delimited. Does not implicitly {@link StopHLSEgressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse} message StopHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopHLSEgressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopHLSEgressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopHLSEgressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopHLSEgressResponse message.
     * @function verify
     * @memberof StopHLSEgressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopHLSEgressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopHLSEgressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopHLSEgressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     */
    StopHLSEgressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopHLSEgressResponse)
            return object;
        return new $root.StopHLSEgressResponse();
    };

    /**
     * Creates a plain object from a StopHLSEgressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopHLSEgressResponse
     * @static
     * @param {StopHLSEgressResponse} message StopHLSEgressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopHLSEgressResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopHLSEgressResponse to JSON.
     * @function toJSON
     * @memberof StopHLSEgressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopHLSEgressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopHLSEgressResponse;
})();

export const MonitorSwarmsRequest = $root.MonitorSwarmsRequest = (() => {

    /**
     * Properties of a MonitorSwarmsRequest.
     * @exports IMonitorSwarmsRequest
     * @interface IMonitorSwarmsRequest
     */

    /**
     * Constructs a new MonitorSwarmsRequest.
     * @exports MonitorSwarmsRequest
     * @classdesc Represents a MonitorSwarmsRequest.
     * @implements IMonitorSwarmsRequest
     * @constructor
     * @param {IMonitorSwarmsRequest=} [properties] Properties to set
     */
    function MonitorSwarmsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new MonitorSwarmsRequest instance using the specified properties.
     * @function create
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest=} [properties] Properties to set
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest instance
     */
    MonitorSwarmsRequest.create = function create(properties) {
        return new MonitorSwarmsRequest(properties);
    };

    /**
     * Encodes the specified MonitorSwarmsRequest message. Does not implicitly {@link MonitorSwarmsRequest.verify|verify} messages.
     * @function encode
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest} message MonitorSwarmsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified MonitorSwarmsRequest message, length delimited. Does not implicitly {@link MonitorSwarmsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest} message MonitorSwarmsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MonitorSwarmsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MonitorSwarmsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MonitorSwarmsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MonitorSwarmsRequest message.
     * @function verify
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MonitorSwarmsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a MonitorSwarmsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     */
    MonitorSwarmsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.MonitorSwarmsRequest)
            return object;
        return new $root.MonitorSwarmsRequest();
    };

    /**
     * Creates a plain object from a MonitorSwarmsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {MonitorSwarmsRequest} message MonitorSwarmsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MonitorSwarmsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this MonitorSwarmsRequest to JSON.
     * @function toJSON
     * @memberof MonitorSwarmsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MonitorSwarmsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MonitorSwarmsRequest;
})();

export const StartSwarmRequest = $root.StartSwarmRequest = (() => {

    /**
     * Properties of a StartSwarmRequest.
     * @exports IStartSwarmRequest
     * @interface IStartSwarmRequest
     */

    /**
     * Constructs a new StartSwarmRequest.
     * @exports StartSwarmRequest
     * @classdesc Represents a StartSwarmRequest.
     * @implements IStartSwarmRequest
     * @constructor
     * @param {IStartSwarmRequest=} [properties] Properties to set
     */
    function StartSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartSwarmRequest instance using the specified properties.
     * @function create
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest=} [properties] Properties to set
     * @returns {StartSwarmRequest} StartSwarmRequest instance
     */
    StartSwarmRequest.create = function create(properties) {
        return new StartSwarmRequest(properties);
    };

    /**
     * Encodes the specified StartSwarmRequest message. Does not implicitly {@link StartSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest} message StartSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartSwarmRequest message, length delimited. Does not implicitly {@link StartSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest} message StartSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartSwarmRequest} StartSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartSwarmRequest} StartSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartSwarmRequest message.
     * @function verify
     * @memberof StartSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartSwarmRequest} StartSwarmRequest
     */
    StartSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartSwarmRequest)
            return object;
        return new $root.StartSwarmRequest();
    };

    /**
     * Creates a plain object from a StartSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartSwarmRequest
     * @static
     * @param {StartSwarmRequest} message StartSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartSwarmRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartSwarmRequest to JSON.
     * @function toJSON
     * @memberof StartSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartSwarmRequest;
})();

export const StartSwarmResponse = $root.StartSwarmResponse = (() => {

    /**
     * Properties of a StartSwarmResponse.
     * @exports IStartSwarmResponse
     * @interface IStartSwarmResponse
     * @property {number|null} [id] StartSwarmResponse id
     */

    /**
     * Constructs a new StartSwarmResponse.
     * @exports StartSwarmResponse
     * @classdesc Represents a StartSwarmResponse.
     * @implements IStartSwarmResponse
     * @constructor
     * @param {IStartSwarmResponse=} [properties] Properties to set
     */
    function StartSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StartSwarmResponse id.
     * @member {number} id
     * @memberof StartSwarmResponse
     * @instance
     */
    StartSwarmResponse.prototype.id = 0;

    /**
     * Creates a new StartSwarmResponse instance using the specified properties.
     * @function create
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse=} [properties] Properties to set
     * @returns {StartSwarmResponse} StartSwarmResponse instance
     */
    StartSwarmResponse.create = function create(properties) {
        return new StartSwarmResponse(properties);
    };

    /**
     * Encodes the specified StartSwarmResponse message. Does not implicitly {@link StartSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse} message StartSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        return writer;
    };

    /**
     * Encodes the specified StartSwarmResponse message, length delimited. Does not implicitly {@link StartSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse} message StartSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartSwarmResponse} StartSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartSwarmResponse} StartSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartSwarmResponse message.
     * @function verify
     * @memberof StartSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a StartSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartSwarmResponse} StartSwarmResponse
     */
    StartSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartSwarmResponse)
            return object;
        let message = new $root.StartSwarmResponse();
        if (object.id != null)
            message.id = object.id >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a StartSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartSwarmResponse
     * @static
     * @param {StartSwarmResponse} message StartSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartSwarmResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this StartSwarmResponse to JSON.
     * @function toJSON
     * @memberof StartSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartSwarmResponse;
})();

export const WriteToSwarmRequest = $root.WriteToSwarmRequest = (() => {

    /**
     * Properties of a WriteToSwarmRequest.
     * @exports IWriteToSwarmRequest
     * @interface IWriteToSwarmRequest
     * @property {number|null} [id] WriteToSwarmRequest id
     * @property {Uint8Array|null} [data] WriteToSwarmRequest data
     */

    /**
     * Constructs a new WriteToSwarmRequest.
     * @exports WriteToSwarmRequest
     * @classdesc Represents a WriteToSwarmRequest.
     * @implements IWriteToSwarmRequest
     * @constructor
     * @param {IWriteToSwarmRequest=} [properties] Properties to set
     */
    function WriteToSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WriteToSwarmRequest id.
     * @member {number} id
     * @memberof WriteToSwarmRequest
     * @instance
     */
    WriteToSwarmRequest.prototype.id = 0;

    /**
     * WriteToSwarmRequest data.
     * @member {Uint8Array} data
     * @memberof WriteToSwarmRequest
     * @instance
     */
    WriteToSwarmRequest.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new WriteToSwarmRequest instance using the specified properties.
     * @function create
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest=} [properties] Properties to set
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest instance
     */
    WriteToSwarmRequest.create = function create(properties) {
        return new WriteToSwarmRequest(properties);
    };

    /**
     * Encodes the specified WriteToSwarmRequest message. Does not implicitly {@link WriteToSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest} message WriteToSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified WriteToSwarmRequest message, length delimited. Does not implicitly {@link WriteToSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest} message WriteToSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToSwarmRequest message.
     * @function verify
     * @memberof WriteToSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a WriteToSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     */
    WriteToSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToSwarmRequest)
            return object;
        let message = new $root.WriteToSwarmRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a WriteToSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToSwarmRequest
     * @static
     * @param {WriteToSwarmRequest} message WriteToSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this WriteToSwarmRequest to JSON.
     * @function toJSON
     * @memberof WriteToSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToSwarmRequest;
})();

export const WriteToSwarmResponse = $root.WriteToSwarmResponse = (() => {

    /**
     * Properties of a WriteToSwarmResponse.
     * @exports IWriteToSwarmResponse
     * @interface IWriteToSwarmResponse
     * @property {string|null} [error] WriteToSwarmResponse error
     */

    /**
     * Constructs a new WriteToSwarmResponse.
     * @exports WriteToSwarmResponse
     * @classdesc Represents a WriteToSwarmResponse.
     * @implements IWriteToSwarmResponse
     * @constructor
     * @param {IWriteToSwarmResponse=} [properties] Properties to set
     */
    function WriteToSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WriteToSwarmResponse error.
     * @member {string} error
     * @memberof WriteToSwarmResponse
     * @instance
     */
    WriteToSwarmResponse.prototype.error = "";

    /**
     * Creates a new WriteToSwarmResponse instance using the specified properties.
     * @function create
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse=} [properties] Properties to set
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse instance
     */
    WriteToSwarmResponse.create = function create(properties) {
        return new WriteToSwarmResponse(properties);
    };

    /**
     * Encodes the specified WriteToSwarmResponse message. Does not implicitly {@link WriteToSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse} message WriteToSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
        return writer;
    };

    /**
     * Encodes the specified WriteToSwarmResponse message, length delimited. Does not implicitly {@link WriteToSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse} message WriteToSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.error = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToSwarmResponse message.
     * @function verify
     * @memberof WriteToSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.error != null && message.hasOwnProperty("error"))
            if (!$util.isString(message.error))
                return "error: string expected";
        return null;
    };

    /**
     * Creates a WriteToSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     */
    WriteToSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToSwarmResponse)
            return object;
        let message = new $root.WriteToSwarmResponse();
        if (object.error != null)
            message.error = String(object.error);
        return message;
    };

    /**
     * Creates a plain object from a WriteToSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToSwarmResponse
     * @static
     * @param {WriteToSwarmResponse} message WriteToSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToSwarmResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.error = "";
        if (message.error != null && message.hasOwnProperty("error"))
            object.error = message.error;
        return object;
    };

    /**
     * Converts this WriteToSwarmResponse to JSON.
     * @function toJSON
     * @memberof WriteToSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToSwarmResponse;
})();

export const StopSwarmRequest = $root.StopSwarmRequest = (() => {

    /**
     * Properties of a StopSwarmRequest.
     * @exports IStopSwarmRequest
     * @interface IStopSwarmRequest
     * @property {number|null} [id] StopSwarmRequest id
     */

    /**
     * Constructs a new StopSwarmRequest.
     * @exports StopSwarmRequest
     * @classdesc Represents a StopSwarmRequest.
     * @implements IStopSwarmRequest
     * @constructor
     * @param {IStopSwarmRequest=} [properties] Properties to set
     */
    function StopSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StopSwarmRequest id.
     * @member {number} id
     * @memberof StopSwarmRequest
     * @instance
     */
    StopSwarmRequest.prototype.id = 0;

    /**
     * Creates a new StopSwarmRequest instance using the specified properties.
     * @function create
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest=} [properties] Properties to set
     * @returns {StopSwarmRequest} StopSwarmRequest instance
     */
    StopSwarmRequest.create = function create(properties) {
        return new StopSwarmRequest(properties);
    };

    /**
     * Encodes the specified StopSwarmRequest message. Does not implicitly {@link StopSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest} message StopSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        return writer;
    };

    /**
     * Encodes the specified StopSwarmRequest message, length delimited. Does not implicitly {@link StopSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest} message StopSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopSwarmRequest} StopSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopSwarmRequest} StopSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopSwarmRequest message.
     * @function verify
     * @memberof StopSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a StopSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopSwarmRequest} StopSwarmRequest
     */
    StopSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopSwarmRequest)
            return object;
        let message = new $root.StopSwarmRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a StopSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopSwarmRequest
     * @static
     * @param {StopSwarmRequest} message StopSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this StopSwarmRequest to JSON.
     * @function toJSON
     * @memberof StopSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopSwarmRequest;
})();

export const StopSwarmResponse = $root.StopSwarmResponse = (() => {

    /**
     * Properties of a StopSwarmResponse.
     * @exports IStopSwarmResponse
     * @interface IStopSwarmResponse
     */

    /**
     * Constructs a new StopSwarmResponse.
     * @exports StopSwarmResponse
     * @classdesc Represents a StopSwarmResponse.
     * @implements IStopSwarmResponse
     * @constructor
     * @param {IStopSwarmResponse=} [properties] Properties to set
     */
    function StopSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopSwarmResponse instance using the specified properties.
     * @function create
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse=} [properties] Properties to set
     * @returns {StopSwarmResponse} StopSwarmResponse instance
     */
    StopSwarmResponse.create = function create(properties) {
        return new StopSwarmResponse(properties);
    };

    /**
     * Encodes the specified StopSwarmResponse message. Does not implicitly {@link StopSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse} message StopSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopSwarmResponse message, length delimited. Does not implicitly {@link StopSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse} message StopSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopSwarmResponse} StopSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopSwarmResponse} StopSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopSwarmResponse message.
     * @function verify
     * @memberof StopSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopSwarmResponse} StopSwarmResponse
     */
    StopSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopSwarmResponse)
            return object;
        return new $root.StopSwarmResponse();
    };

    /**
     * Creates a plain object from a StopSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopSwarmResponse
     * @static
     * @param {StopSwarmResponse} message StopSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopSwarmResponse to JSON.
     * @function toJSON
     * @memberof StopSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopSwarmResponse;
})();

export const PublishSwarmRequest = $root.PublishSwarmRequest = (() => {

    /**
     * Properties of a PublishSwarmRequest.
     * @exports IPublishSwarmRequest
     * @interface IPublishSwarmRequest
     * @property {number|null} [id] PublishSwarmRequest id
     */

    /**
     * Constructs a new PublishSwarmRequest.
     * @exports PublishSwarmRequest
     * @classdesc Represents a PublishSwarmRequest.
     * @implements IPublishSwarmRequest
     * @constructor
     * @param {IPublishSwarmRequest=} [properties] Properties to set
     */
    function PublishSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PublishSwarmRequest id.
     * @member {number} id
     * @memberof PublishSwarmRequest
     * @instance
     */
    PublishSwarmRequest.prototype.id = 0;

    /**
     * Creates a new PublishSwarmRequest instance using the specified properties.
     * @function create
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest=} [properties] Properties to set
     * @returns {PublishSwarmRequest} PublishSwarmRequest instance
     */
    PublishSwarmRequest.create = function create(properties) {
        return new PublishSwarmRequest(properties);
    };

    /**
     * Encodes the specified PublishSwarmRequest message. Does not implicitly {@link PublishSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest} message PublishSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        return writer;
    };

    /**
     * Encodes the specified PublishSwarmRequest message, length delimited. Does not implicitly {@link PublishSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest} message PublishSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PublishSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishSwarmRequest message.
     * @function verify
     * @memberof PublishSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        return null;
    };

    /**
     * Creates a PublishSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     */
    PublishSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishSwarmRequest)
            return object;
        let message = new $root.PublishSwarmRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a PublishSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishSwarmRequest
     * @static
     * @param {PublishSwarmRequest} message PublishSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this PublishSwarmRequest to JSON.
     * @function toJSON
     * @memberof PublishSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishSwarmRequest;
})();

export const PublishSwarmResponse = $root.PublishSwarmResponse = (() => {

    /**
     * Properties of a PublishSwarmResponse.
     * @exports IPublishSwarmResponse
     * @interface IPublishSwarmResponse
     */

    /**
     * Constructs a new PublishSwarmResponse.
     * @exports PublishSwarmResponse
     * @classdesc Represents a PublishSwarmResponse.
     * @implements IPublishSwarmResponse
     * @constructor
     * @param {IPublishSwarmResponse=} [properties] Properties to set
     */
    function PublishSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new PublishSwarmResponse instance using the specified properties.
     * @function create
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse=} [properties] Properties to set
     * @returns {PublishSwarmResponse} PublishSwarmResponse instance
     */
    PublishSwarmResponse.create = function create(properties) {
        return new PublishSwarmResponse(properties);
    };

    /**
     * Encodes the specified PublishSwarmResponse message. Does not implicitly {@link PublishSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse} message PublishSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified PublishSwarmResponse message, length delimited. Does not implicitly {@link PublishSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse} message PublishSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PublishSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishSwarmResponse message.
     * @function verify
     * @memberof PublishSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a PublishSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     */
    PublishSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishSwarmResponse)
            return object;
        return new $root.PublishSwarmResponse();
    };

    /**
     * Creates a plain object from a PublishSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishSwarmResponse
     * @static
     * @param {PublishSwarmResponse} message PublishSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this PublishSwarmResponse to JSON.
     * @function toJSON
     * @memberof PublishSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishSwarmResponse;
})();

export const PProfRequest = $root.PProfRequest = (() => {

    /**
     * Properties of a PProfRequest.
     * @exports IPProfRequest
     * @interface IPProfRequest
     * @property {string|null} [name] PProfRequest name
     * @property {boolean|null} [debug] PProfRequest debug
     * @property {boolean|null} [gc] PProfRequest gc
     */

    /**
     * Constructs a new PProfRequest.
     * @exports PProfRequest
     * @classdesc Represents a PProfRequest.
     * @implements IPProfRequest
     * @constructor
     * @param {IPProfRequest=} [properties] Properties to set
     */
    function PProfRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PProfRequest name.
     * @member {string} name
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.name = "";

    /**
     * PProfRequest debug.
     * @member {boolean} debug
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.debug = false;

    /**
     * PProfRequest gc.
     * @member {boolean} gc
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.gc = false;

    /**
     * Creates a new PProfRequest instance using the specified properties.
     * @function create
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest=} [properties] Properties to set
     * @returns {PProfRequest} PProfRequest instance
     */
    PProfRequest.create = function create(properties) {
        return new PProfRequest(properties);
    };

    /**
     * Encodes the specified PProfRequest message. Does not implicitly {@link PProfRequest.verify|verify} messages.
     * @function encode
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest} message PProfRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.debug);
        if (message.gc != null && Object.hasOwnProperty.call(message, "gc"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.gc);
        return writer;
    };

    /**
     * Encodes the specified PProfRequest message, length delimited. Does not implicitly {@link PProfRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest} message PProfRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PProfRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PProfRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PProfRequest} PProfRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PProfRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.debug = reader.bool();
                break;
            case 3:
                message.gc = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PProfRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PProfRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PProfRequest} PProfRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PProfRequest message.
     * @function verify
     * @memberof PProfRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PProfRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.debug != null && message.hasOwnProperty("debug"))
            if (typeof message.debug !== "boolean")
                return "debug: boolean expected";
        if (message.gc != null && message.hasOwnProperty("gc"))
            if (typeof message.gc !== "boolean")
                return "gc: boolean expected";
        return null;
    };

    /**
     * Creates a PProfRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PProfRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PProfRequest} PProfRequest
     */
    PProfRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PProfRequest)
            return object;
        let message = new $root.PProfRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.debug != null)
            message.debug = Boolean(object.debug);
        if (object.gc != null)
            message.gc = Boolean(object.gc);
        return message;
    };

    /**
     * Creates a plain object from a PProfRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PProfRequest
     * @static
     * @param {PProfRequest} message PProfRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PProfRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.debug = false;
            object.gc = false;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.debug != null && message.hasOwnProperty("debug"))
            object.debug = message.debug;
        if (message.gc != null && message.hasOwnProperty("gc"))
            object.gc = message.gc;
        return object;
    };

    /**
     * Converts this PProfRequest to JSON.
     * @function toJSON
     * @memberof PProfRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PProfRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PProfRequest;
})();

export const PProfResponse = $root.PProfResponse = (() => {

    /**
     * Properties of a PProfResponse.
     * @exports IPProfResponse
     * @interface IPProfResponse
     * @property {string|null} [name] PProfResponse name
     * @property {Uint8Array|null} [data] PProfResponse data
     */

    /**
     * Constructs a new PProfResponse.
     * @exports PProfResponse
     * @classdesc Represents a PProfResponse.
     * @implements IPProfResponse
     * @constructor
     * @param {IPProfResponse=} [properties] Properties to set
     */
    function PProfResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PProfResponse name.
     * @member {string} name
     * @memberof PProfResponse
     * @instance
     */
    PProfResponse.prototype.name = "";

    /**
     * PProfResponse data.
     * @member {Uint8Array} data
     * @memberof PProfResponse
     * @instance
     */
    PProfResponse.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new PProfResponse instance using the specified properties.
     * @function create
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse=} [properties] Properties to set
     * @returns {PProfResponse} PProfResponse instance
     */
    PProfResponse.create = function create(properties) {
        return new PProfResponse(properties);
    };

    /**
     * Encodes the specified PProfResponse message. Does not implicitly {@link PProfResponse.verify|verify} messages.
     * @function encode
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse} message PProfResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified PProfResponse message, length delimited. Does not implicitly {@link PProfResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse} message PProfResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PProfResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PProfResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PProfResponse} PProfResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PProfResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PProfResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PProfResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PProfResponse} PProfResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PProfResponse message.
     * @function verify
     * @memberof PProfResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PProfResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a PProfResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PProfResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PProfResponse} PProfResponse
     */
    PProfResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PProfResponse)
            return object;
        let message = new $root.PProfResponse();
        if (object.name != null)
            message.name = String(object.name);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a PProfResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PProfResponse
     * @static
     * @param {PProfResponse} message PProfResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PProfResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this PProfResponse to JSON.
     * @function toJSON
     * @memberof PProfResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PProfResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PProfResponse;
})();

export const StorageKey = $root.StorageKey = (() => {

    /**
     * Properties of a StorageKey.
     * @exports IStorageKey
     * @interface IStorageKey
     * @property {KDFType|null} [kdfType] StorageKey kdfType
     * @property {StorageKey.IPBKDF2Options|null} [pbkdf2Options] StorageKey pbkdf2Options
     */

    /**
     * Constructs a new StorageKey.
     * @exports StorageKey
     * @classdesc Represents a StorageKey.
     * @implements IStorageKey
     * @constructor
     * @param {IStorageKey=} [properties] Properties to set
     */
    function StorageKey(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StorageKey kdfType.
     * @member {KDFType} kdfType
     * @memberof StorageKey
     * @instance
     */
    StorageKey.prototype.kdfType = 0;

    /**
     * StorageKey pbkdf2Options.
     * @member {StorageKey.IPBKDF2Options|null|undefined} pbkdf2Options
     * @memberof StorageKey
     * @instance
     */
    StorageKey.prototype.pbkdf2Options = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * StorageKey kdfOptions.
     * @member {"pbkdf2Options"|undefined} kdfOptions
     * @memberof StorageKey
     * @instance
     */
    Object.defineProperty(StorageKey.prototype, "kdfOptions", {
        get: $util.oneOfGetter($oneOfFields = ["pbkdf2Options"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new StorageKey instance using the specified properties.
     * @function create
     * @memberof StorageKey
     * @static
     * @param {IStorageKey=} [properties] Properties to set
     * @returns {StorageKey} StorageKey instance
     */
    StorageKey.create = function create(properties) {
        return new StorageKey(properties);
    };

    /**
     * Encodes the specified StorageKey message. Does not implicitly {@link StorageKey.verify|verify} messages.
     * @function encode
     * @memberof StorageKey
     * @static
     * @param {IStorageKey} message StorageKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StorageKey.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.kdfType != null && Object.hasOwnProperty.call(message, "kdfType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kdfType);
        if (message.pbkdf2Options != null && Object.hasOwnProperty.call(message, "pbkdf2Options"))
            $root.StorageKey.PBKDF2Options.encode(message.pbkdf2Options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified StorageKey message, length delimited. Does not implicitly {@link StorageKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StorageKey
     * @static
     * @param {IStorageKey} message StorageKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StorageKey.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StorageKey message from the specified reader or buffer.
     * @function decode
     * @memberof StorageKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StorageKey} StorageKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StorageKey.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StorageKey();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.kdfType = reader.int32();
                break;
            case 2:
                message.pbkdf2Options = $root.StorageKey.PBKDF2Options.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StorageKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StorageKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StorageKey} StorageKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StorageKey.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StorageKey message.
     * @function verify
     * @memberof StorageKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StorageKey.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.kdfType != null && message.hasOwnProperty("kdfType"))
            switch (message.kdfType) {
            default:
                return "kdfType: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.pbkdf2Options != null && message.hasOwnProperty("pbkdf2Options")) {
            properties.kdfOptions = 1;
            {
                let error = $root.StorageKey.PBKDF2Options.verify(message.pbkdf2Options);
                if (error)
                    return "pbkdf2Options." + error;
            }
        }
        return null;
    };

    /**
     * Creates a StorageKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StorageKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StorageKey} StorageKey
     */
    StorageKey.fromObject = function fromObject(object) {
        if (object instanceof $root.StorageKey)
            return object;
        let message = new $root.StorageKey();
        switch (object.kdfType) {
        case "KDF_TYPE_UNDEFINED":
        case 0:
            message.kdfType = 0;
            break;
        case "KDF_TYPE_PBKDF2_SHA256":
        case 1:
            message.kdfType = 1;
            break;
        }
        if (object.pbkdf2Options != null) {
            if (typeof object.pbkdf2Options !== "object")
                throw TypeError(".StorageKey.pbkdf2Options: object expected");
            message.pbkdf2Options = $root.StorageKey.PBKDF2Options.fromObject(object.pbkdf2Options);
        }
        return message;
    };

    /**
     * Creates a plain object from a StorageKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StorageKey
     * @static
     * @param {StorageKey} message StorageKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StorageKey.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.kdfType = options.enums === String ? "KDF_TYPE_UNDEFINED" : 0;
        if (message.kdfType != null && message.hasOwnProperty("kdfType"))
            object.kdfType = options.enums === String ? $root.KDFType[message.kdfType] : message.kdfType;
        if (message.pbkdf2Options != null && message.hasOwnProperty("pbkdf2Options")) {
            object.pbkdf2Options = $root.StorageKey.PBKDF2Options.toObject(message.pbkdf2Options, options);
            if (options.oneofs)
                object.kdfOptions = "pbkdf2Options";
        }
        return object;
    };

    /**
     * Converts this StorageKey to JSON.
     * @function toJSON
     * @memberof StorageKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StorageKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    StorageKey.PBKDF2Options = (function() {

        /**
         * Properties of a PBKDF2Options.
         * @memberof StorageKey
         * @interface IPBKDF2Options
         * @property {number|null} [iterations] PBKDF2Options iterations
         * @property {number|null} [keySize] PBKDF2Options keySize
         * @property {Uint8Array|null} [salt] PBKDF2Options salt
         */

        /**
         * Constructs a new PBKDF2Options.
         * @memberof StorageKey
         * @classdesc Represents a PBKDF2Options.
         * @implements IPBKDF2Options
         * @constructor
         * @param {StorageKey.IPBKDF2Options=} [properties] Properties to set
         */
        function PBKDF2Options(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PBKDF2Options iterations.
         * @member {number} iterations
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.iterations = 0;

        /**
         * PBKDF2Options keySize.
         * @member {number} keySize
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.keySize = 0;

        /**
         * PBKDF2Options salt.
         * @member {Uint8Array} salt
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new PBKDF2Options instance using the specified properties.
         * @function create
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options=} [properties] Properties to set
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options instance
         */
        PBKDF2Options.create = function create(properties) {
            return new PBKDF2Options(properties);
        };

        /**
         * Encodes the specified PBKDF2Options message. Does not implicitly {@link StorageKey.PBKDF2Options.verify|verify} messages.
         * @function encode
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options} message PBKDF2Options message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PBKDF2Options.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iterations != null && Object.hasOwnProperty.call(message, "iterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iterations);
            if (message.keySize != null && Object.hasOwnProperty.call(message, "keySize"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.keySize);
            if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified PBKDF2Options message, length delimited. Does not implicitly {@link StorageKey.PBKDF2Options.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options} message PBKDF2Options message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PBKDF2Options.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PBKDF2Options message from the specified reader or buffer.
         * @function decode
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PBKDF2Options.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StorageKey.PBKDF2Options();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iterations = reader.uint32();
                    break;
                case 2:
                    message.keySize = reader.uint32();
                    break;
                case 3:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PBKDF2Options message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PBKDF2Options.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PBKDF2Options message.
         * @function verify
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PBKDF2Options.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.keySize != null && message.hasOwnProperty("keySize"))
                if (!$util.isInteger(message.keySize))
                    return "keySize: integer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a PBKDF2Options message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         */
        PBKDF2Options.fromObject = function fromObject(object) {
            if (object instanceof $root.StorageKey.PBKDF2Options)
                return object;
            let message = new $root.StorageKey.PBKDF2Options();
            if (object.iterations != null)
                message.iterations = object.iterations >>> 0;
            if (object.keySize != null)
                message.keySize = object.keySize >>> 0;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a PBKDF2Options message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.PBKDF2Options} message PBKDF2Options
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PBKDF2Options.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.iterations = 0;
                object.keySize = 0;
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
            }
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.keySize != null && message.hasOwnProperty("keySize"))
                object.keySize = message.keySize;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this PBKDF2Options to JSON.
         * @function toJSON
         * @memberof StorageKey.PBKDF2Options
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PBKDF2Options.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PBKDF2Options;
    })();

    return StorageKey;
})();

export const MonitorSwarmsResponse = $root.MonitorSwarmsResponse = (() => {

    /**
     * Properties of a MonitorSwarmsResponse.
     * @exports IMonitorSwarmsResponse
     * @interface IMonitorSwarmsResponse
     * @property {SwarmEventType|null} [type] MonitorSwarmsResponse type
     * @property {string|null} [id] MonitorSwarmsResponse id
     */

    /**
     * Constructs a new MonitorSwarmsResponse.
     * @exports MonitorSwarmsResponse
     * @classdesc Represents a MonitorSwarmsResponse.
     * @implements IMonitorSwarmsResponse
     * @constructor
     * @param {IMonitorSwarmsResponse=} [properties] Properties to set
     */
    function MonitorSwarmsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MonitorSwarmsResponse type.
     * @member {SwarmEventType} type
     * @memberof MonitorSwarmsResponse
     * @instance
     */
    MonitorSwarmsResponse.prototype.type = 0;

    /**
     * MonitorSwarmsResponse id.
     * @member {string} id
     * @memberof MonitorSwarmsResponse
     * @instance
     */
    MonitorSwarmsResponse.prototype.id = "";

    /**
     * Creates a new MonitorSwarmsResponse instance using the specified properties.
     * @function create
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse=} [properties] Properties to set
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse instance
     */
    MonitorSwarmsResponse.create = function create(properties) {
        return new MonitorSwarmsResponse(properties);
    };

    /**
     * Encodes the specified MonitorSwarmsResponse message. Does not implicitly {@link MonitorSwarmsResponse.verify|verify} messages.
     * @function encode
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse} message MonitorSwarmsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
        return writer;
    };

    /**
     * Encodes the specified MonitorSwarmsResponse message, length delimited. Does not implicitly {@link MonitorSwarmsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse} message MonitorSwarmsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MonitorSwarmsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MonitorSwarmsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MonitorSwarmsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MonitorSwarmsResponse message.
     * @function verify
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MonitorSwarmsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        return null;
    };

    /**
     * Creates a MonitorSwarmsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     */
    MonitorSwarmsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.MonitorSwarmsResponse)
            return object;
        let message = new $root.MonitorSwarmsResponse();
        switch (object.type) {
        case "CREATE_SWARM":
        case 0:
            message.type = 0;
            break;
        case "UPDATE_SWARM":
        case 1:
            message.type = 1;
            break;
        case "DELETE_SWARM":
        case 2:
            message.type = 2;
            break;
        }
        if (object.id != null)
            message.id = String(object.id);
        return message;
    };

    /**
     * Creates a plain object from a MonitorSwarmsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {MonitorSwarmsResponse} message MonitorSwarmsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MonitorSwarmsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "CREATE_SWARM" : 0;
            object.id = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.SwarmEventType[message.type] : message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this MonitorSwarmsResponse to JSON.
     * @function toJSON
     * @memberof MonitorSwarmsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MonitorSwarmsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MonitorSwarmsResponse;
})();

export const BootstrapDHTRequest = $root.BootstrapDHTRequest = (() => {

    /**
     * Properties of a BootstrapDHTRequest.
     * @exports IBootstrapDHTRequest
     * @interface IBootstrapDHTRequest
     * @property {Array.<string>|null} [transportUris] BootstrapDHTRequest transportUris
     */

    /**
     * Constructs a new BootstrapDHTRequest.
     * @exports BootstrapDHTRequest
     * @classdesc Represents a BootstrapDHTRequest.
     * @implements IBootstrapDHTRequest
     * @constructor
     * @param {IBootstrapDHTRequest=} [properties] Properties to set
     */
    function BootstrapDHTRequest(properties) {
        this.transportUris = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapDHTRequest transportUris.
     * @member {Array.<string>} transportUris
     * @memberof BootstrapDHTRequest
     * @instance
     */
    BootstrapDHTRequest.prototype.transportUris = $util.emptyArray;

    /**
     * Creates a new BootstrapDHTRequest instance using the specified properties.
     * @function create
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest=} [properties] Properties to set
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest instance
     */
    BootstrapDHTRequest.create = function create(properties) {
        return new BootstrapDHTRequest(properties);
    };

    /**
     * Encodes the specified BootstrapDHTRequest message. Does not implicitly {@link BootstrapDHTRequest.verify|verify} messages.
     * @function encode
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest} message BootstrapDHTRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.transportUris != null && message.transportUris.length)
            for (let i = 0; i < message.transportUris.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transportUris[i]);
        return writer;
    };

    /**
     * Encodes the specified BootstrapDHTRequest message, length delimited. Does not implicitly {@link BootstrapDHTRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest} message BootstrapDHTRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapDHTRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapDHTRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapDHTRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.transportUris && message.transportUris.length))
                    message.transportUris = [];
                message.transportUris.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapDHTRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapDHTRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapDHTRequest message.
     * @function verify
     * @memberof BootstrapDHTRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapDHTRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.transportUris != null && message.hasOwnProperty("transportUris")) {
            if (!Array.isArray(message.transportUris))
                return "transportUris: array expected";
            for (let i = 0; i < message.transportUris.length; ++i)
                if (!$util.isString(message.transportUris[i]))
                    return "transportUris: string[] expected";
        }
        return null;
    };

    /**
     * Creates a BootstrapDHTRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapDHTRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     */
    BootstrapDHTRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapDHTRequest)
            return object;
        let message = new $root.BootstrapDHTRequest();
        if (object.transportUris) {
            if (!Array.isArray(object.transportUris))
                throw TypeError(".BootstrapDHTRequest.transportUris: array expected");
            message.transportUris = [];
            for (let i = 0; i < object.transportUris.length; ++i)
                message.transportUris[i] = String(object.transportUris[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapDHTRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapDHTRequest
     * @static
     * @param {BootstrapDHTRequest} message BootstrapDHTRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapDHTRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.transportUris = [];
        if (message.transportUris && message.transportUris.length) {
            object.transportUris = [];
            for (let j = 0; j < message.transportUris.length; ++j)
                object.transportUris[j] = message.transportUris[j];
        }
        return object;
    };

    /**
     * Converts this BootstrapDHTRequest to JSON.
     * @function toJSON
     * @memberof BootstrapDHTRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapDHTRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapDHTRequest;
})();

export const BootstrapDHTResponse = $root.BootstrapDHTResponse = (() => {

    /**
     * Properties of a BootstrapDHTResponse.
     * @exports IBootstrapDHTResponse
     * @interface IBootstrapDHTResponse
     */

    /**
     * Constructs a new BootstrapDHTResponse.
     * @exports BootstrapDHTResponse
     * @classdesc Represents a BootstrapDHTResponse.
     * @implements IBootstrapDHTResponse
     * @constructor
     * @param {IBootstrapDHTResponse=} [properties] Properties to set
     */
    function BootstrapDHTResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BootstrapDHTResponse instance using the specified properties.
     * @function create
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse=} [properties] Properties to set
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse instance
     */
    BootstrapDHTResponse.create = function create(properties) {
        return new BootstrapDHTResponse(properties);
    };

    /**
     * Encodes the specified BootstrapDHTResponse message. Does not implicitly {@link BootstrapDHTResponse.verify|verify} messages.
     * @function encode
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse} message BootstrapDHTResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BootstrapDHTResponse message, length delimited. Does not implicitly {@link BootstrapDHTResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse} message BootstrapDHTResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapDHTResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapDHTResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapDHTResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapDHTResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapDHTResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapDHTResponse message.
     * @function verify
     * @memberof BootstrapDHTResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapDHTResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BootstrapDHTResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapDHTResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     */
    BootstrapDHTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapDHTResponse)
            return object;
        return new $root.BootstrapDHTResponse();
    };

    /**
     * Creates a plain object from a BootstrapDHTResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapDHTResponse
     * @static
     * @param {BootstrapDHTResponse} message BootstrapDHTResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapDHTResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BootstrapDHTResponse to JSON.
     * @function toJSON
     * @memberof BootstrapDHTResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapDHTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapDHTResponse;
})();

export const NegotiateWRTCRequest = $root.NegotiateWRTCRequest = (() => {

    /**
     * Properties of a NegotiateWRTCRequest.
     * @exports INegotiateWRTCRequest
     * @interface INegotiateWRTCRequest
     * @property {WRTCSDPType|null} [type] NegotiateWRTCRequest type
     * @property {string|null} [sessionDescription] NegotiateWRTCRequest sessionDescription
     */

    /**
     * Constructs a new NegotiateWRTCRequest.
     * @exports NegotiateWRTCRequest
     * @classdesc Represents a NegotiateWRTCRequest.
     * @implements INegotiateWRTCRequest
     * @constructor
     * @param {INegotiateWRTCRequest=} [properties] Properties to set
     */
    function NegotiateWRTCRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NegotiateWRTCRequest type.
     * @member {WRTCSDPType} type
     * @memberof NegotiateWRTCRequest
     * @instance
     */
    NegotiateWRTCRequest.prototype.type = 0;

    /**
     * NegotiateWRTCRequest sessionDescription.
     * @member {string} sessionDescription
     * @memberof NegotiateWRTCRequest
     * @instance
     */
    NegotiateWRTCRequest.prototype.sessionDescription = "";

    /**
     * Creates a new NegotiateWRTCRequest instance using the specified properties.
     * @function create
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest=} [properties] Properties to set
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest instance
     */
    NegotiateWRTCRequest.create = function create(properties) {
        return new NegotiateWRTCRequest(properties);
    };

    /**
     * Encodes the specified NegotiateWRTCRequest message. Does not implicitly {@link NegotiateWRTCRequest.verify|verify} messages.
     * @function encode
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest} message NegotiateWRTCRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.sessionDescription != null && Object.hasOwnProperty.call(message, "sessionDescription"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionDescription);
        return writer;
    };

    /**
     * Encodes the specified NegotiateWRTCRequest message, length delimited. Does not implicitly {@link NegotiateWRTCRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest} message NegotiateWRTCRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NegotiateWRTCRequest message from the specified reader or buffer.
     * @function decode
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NegotiateWRTCRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.sessionDescription = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NegotiateWRTCRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NegotiateWRTCRequest message.
     * @function verify
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NegotiateWRTCRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.sessionDescription != null && message.hasOwnProperty("sessionDescription"))
            if (!$util.isString(message.sessionDescription))
                return "sessionDescription: string expected";
        return null;
    };

    /**
     * Creates a NegotiateWRTCRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     */
    NegotiateWRTCRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.NegotiateWRTCRequest)
            return object;
        let message = new $root.NegotiateWRTCRequest();
        switch (object.type) {
        case "OFFER":
        case 0:
            message.type = 0;
            break;
        case "ANSWER":
        case 1:
            message.type = 1;
            break;
        }
        if (object.sessionDescription != null)
            message.sessionDescription = String(object.sessionDescription);
        return message;
    };

    /**
     * Creates a plain object from a NegotiateWRTCRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {NegotiateWRTCRequest} message NegotiateWRTCRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NegotiateWRTCRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "OFFER" : 0;
            object.sessionDescription = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.WRTCSDPType[message.type] : message.type;
        if (message.sessionDescription != null && message.hasOwnProperty("sessionDescription"))
            object.sessionDescription = message.sessionDescription;
        return object;
    };

    /**
     * Converts this NegotiateWRTCRequest to JSON.
     * @function toJSON
     * @memberof NegotiateWRTCRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NegotiateWRTCRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NegotiateWRTCRequest;
})();

export const NegotiateWRTCResponse = $root.NegotiateWRTCResponse = (() => {

    /**
     * Properties of a NegotiateWRTCResponse.
     * @exports INegotiateWRTCResponse
     * @interface INegotiateWRTCResponse
     * @property {string|null} [candidate] NegotiateWRTCResponse candidate
     */

    /**
     * Constructs a new NegotiateWRTCResponse.
     * @exports NegotiateWRTCResponse
     * @classdesc Represents a NegotiateWRTCResponse.
     * @implements INegotiateWRTCResponse
     * @constructor
     * @param {INegotiateWRTCResponse=} [properties] Properties to set
     */
    function NegotiateWRTCResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NegotiateWRTCResponse candidate.
     * @member {string} candidate
     * @memberof NegotiateWRTCResponse
     * @instance
     */
    NegotiateWRTCResponse.prototype.candidate = "";

    /**
     * Creates a new NegotiateWRTCResponse instance using the specified properties.
     * @function create
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse=} [properties] Properties to set
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse instance
     */
    NegotiateWRTCResponse.create = function create(properties) {
        return new NegotiateWRTCResponse(properties);
    };

    /**
     * Encodes the specified NegotiateWRTCResponse message. Does not implicitly {@link NegotiateWRTCResponse.verify|verify} messages.
     * @function encode
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse} message NegotiateWRTCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.candidate != null && Object.hasOwnProperty.call(message, "candidate"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.candidate);
        return writer;
    };

    /**
     * Encodes the specified NegotiateWRTCResponse message, length delimited. Does not implicitly {@link NegotiateWRTCResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse} message NegotiateWRTCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NegotiateWRTCResponse message from the specified reader or buffer.
     * @function decode
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NegotiateWRTCResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.candidate = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NegotiateWRTCResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NegotiateWRTCResponse message.
     * @function verify
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NegotiateWRTCResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.candidate != null && message.hasOwnProperty("candidate"))
            if (!$util.isString(message.candidate))
                return "candidate: string expected";
        return null;
    };

    /**
     * Creates a NegotiateWRTCResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     */
    NegotiateWRTCResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.NegotiateWRTCResponse)
            return object;
        let message = new $root.NegotiateWRTCResponse();
        if (object.candidate != null)
            message.candidate = String(object.candidate);
        return message;
    };

    /**
     * Creates a plain object from a NegotiateWRTCResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {NegotiateWRTCResponse} message NegotiateWRTCResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NegotiateWRTCResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.candidate = "";
        if (message.candidate != null && message.hasOwnProperty("candidate"))
            object.candidate = message.candidate;
        return object;
    };

    /**
     * Converts this NegotiateWRTCResponse to JSON.
     * @function toJSON
     * @memberof NegotiateWRTCResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NegotiateWRTCResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NegotiateWRTCResponse;
})();

export const Key = $root.Key = (() => {

    /**
     * Properties of a Key.
     * @exports IKey
     * @interface IKey
     * @property {KeyType|null} [type] Key type
     * @property {Uint8Array|null} ["private"] Key private
     * @property {Uint8Array|null} ["public"] Key public
     */

    /**
     * Constructs a new Key.
     * @exports Key
     * @classdesc Represents a Key.
     * @implements IKey
     * @constructor
     * @param {IKey=} [properties] Properties to set
     */
    function Key(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Key type.
     * @member {KeyType} type
     * @memberof Key
     * @instance
     */
    Key.prototype.type = 0;

    /**
     * Key private.
     * @member {Uint8Array} private
     * @memberof Key
     * @instance
     */
    Key.prototype["private"] = $util.newBuffer([]);

    /**
     * Key public.
     * @member {Uint8Array} public
     * @memberof Key
     * @instance
     */
    Key.prototype["public"] = $util.newBuffer([]);

    /**
     * Creates a new Key instance using the specified properties.
     * @function create
     * @memberof Key
     * @static
     * @param {IKey=} [properties] Properties to set
     * @returns {Key} Key instance
     */
    Key.create = function create(properties) {
        return new Key(properties);
    };

    /**
     * Encodes the specified Key message. Does not implicitly {@link Key.verify|verify} messages.
     * @function encode
     * @memberof Key
     * @static
     * @param {IKey} message Key message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Key.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
        if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message["public"]);
        return writer;
    };

    /**
     * Encodes the specified Key message, length delimited. Does not implicitly {@link Key.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Key
     * @static
     * @param {IKey} message Key message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Key.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Key message from the specified reader or buffer.
     * @function decode
     * @memberof Key
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Key} Key
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Key.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Key();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message["private"] = reader.bytes();
                break;
            case 3:
                message["public"] = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Key message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Key
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Key} Key
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Key.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Key message.
     * @function verify
     * @memberof Key
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Key.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message["private"] != null && message.hasOwnProperty("private"))
            if (!(message["private"] && typeof message["private"].length === "number" || $util.isString(message["private"])))
                return "private: buffer expected";
        if (message["public"] != null && message.hasOwnProperty("public"))
            if (!(message["public"] && typeof message["public"].length === "number" || $util.isString(message["public"])))
                return "public: buffer expected";
        return null;
    };

    /**
     * Creates a Key message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Key
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Key} Key
     */
    Key.fromObject = function fromObject(object) {
        if (object instanceof $root.Key)
            return object;
        let message = new $root.Key();
        switch (object.type) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.type = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.type = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.type = 2;
            break;
        }
        if (object["private"] != null)
            if (typeof object["private"] === "string")
                $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
            else if (object["private"].length)
                message["private"] = object["private"];
        if (object["public"] != null)
            if (typeof object["public"] === "string")
                $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
            else if (object["public"].length)
                message["public"] = object["public"];
        return message;
    };

    /**
     * Creates a plain object from a Key message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Key
     * @static
     * @param {Key} message Key
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Key.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            if (options.bytes === String)
                object["private"] = "";
            else {
                object["private"] = [];
                if (options.bytes !== Array)
                    object["private"] = $util.newBuffer(object["private"]);
            }
            if (options.bytes === String)
                object["public"] = "";
            else {
                object["public"] = [];
                if (options.bytes !== Array)
                    object["public"] = $util.newBuffer(object["public"]);
            }
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.KeyType[message.type] : message.type;
        if (message["private"] != null && message.hasOwnProperty("private"))
            object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
        if (message["public"] != null && message.hasOwnProperty("public"))
            object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
        return object;
    };

    /**
     * Converts this Key to JSON.
     * @function toJSON
     * @memberof Key
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Key.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Key;
})();

export const CertificateRequest = $root.CertificateRequest = (() => {

    /**
     * Properties of a CertificateRequest.
     * @exports ICertificateRequest
     * @interface ICertificateRequest
     * @property {Uint8Array|null} [key] CertificateRequest key
     * @property {KeyType|null} [keyType] CertificateRequest keyType
     * @property {number|null} [keyUsage] CertificateRequest keyUsage
     * @property {Uint8Array|null} [signature] CertificateRequest signature
     */

    /**
     * Constructs a new CertificateRequest.
     * @exports CertificateRequest
     * @classdesc Represents a CertificateRequest.
     * @implements ICertificateRequest
     * @constructor
     * @param {ICertificateRequest=} [properties] Properties to set
     */
    function CertificateRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CertificateRequest key.
     * @member {Uint8Array} key
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.key = $util.newBuffer([]);

    /**
     * CertificateRequest keyType.
     * @member {KeyType} keyType
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.keyType = 0;

    /**
     * CertificateRequest keyUsage.
     * @member {number} keyUsage
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.keyUsage = 0;

    /**
     * CertificateRequest signature.
     * @member {Uint8Array} signature
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new CertificateRequest instance using the specified properties.
     * @function create
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest=} [properties] Properties to set
     * @returns {CertificateRequest} CertificateRequest instance
     */
    CertificateRequest.create = function create(properties) {
        return new CertificateRequest(properties);
    };

    /**
     * Encodes the specified CertificateRequest message. Does not implicitly {@link CertificateRequest.verify|verify} messages.
     * @function encode
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest} message CertificateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyType);
        if (message.keyUsage != null && Object.hasOwnProperty.call(message, "keyUsage"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.keyUsage);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified CertificateRequest message, length delimited. Does not implicitly {@link CertificateRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest} message CertificateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CertificateRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CertificateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CertificateRequest} CertificateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CertificateRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.keyType = reader.int32();
                break;
            case 3:
                message.keyUsage = reader.uint32();
                break;
            case 4:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CertificateRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CertificateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CertificateRequest} CertificateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CertificateRequest message.
     * @function verify
     * @memberof CertificateRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CertificateRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            switch (message.keyType) {
            default:
                return "keyType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            if (!$util.isInteger(message.keyUsage))
                return "keyUsage: integer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a CertificateRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CertificateRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CertificateRequest} CertificateRequest
     */
    CertificateRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CertificateRequest)
            return object;
        let message = new $root.CertificateRequest();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        switch (object.keyType) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.keyType = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.keyType = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.keyType = 2;
            break;
        }
        if (object.keyUsage != null)
            message.keyUsage = object.keyUsage >>> 0;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a CertificateRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CertificateRequest
     * @static
     * @param {CertificateRequest} message CertificateRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CertificateRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.keyType = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            object.keyUsage = 0;
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            object.keyType = options.enums === String ? $root.KeyType[message.keyType] : message.keyType;
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            object.keyUsage = message.keyUsage;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this CertificateRequest to JSON.
     * @function toJSON
     * @memberof CertificateRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CertificateRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CertificateRequest;
})();

export const Certificate = $root.Certificate = (() => {

    /**
     * Properties of a Certificate.
     * @exports ICertificate
     * @interface ICertificate
     * @property {Uint8Array|null} [key] Certificate key
     * @property {KeyType|null} [keyType] Certificate keyType
     * @property {number|null} [keyUsage] Certificate keyUsage
     * @property {number|null} [notBefore] Certificate notBefore
     * @property {number|null} [notAfter] Certificate notAfter
     * @property {Uint8Array|null} [serialNumber] Certificate serialNumber
     * @property {Uint8Array|null} [signature] Certificate signature
     * @property {ICertificate|null} [parent] Certificate parent
     */

    /**
     * Constructs a new Certificate.
     * @exports Certificate
     * @classdesc Represents a Certificate.
     * @implements ICertificate
     * @constructor
     * @param {ICertificate=} [properties] Properties to set
     */
    function Certificate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Certificate key.
     * @member {Uint8Array} key
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.key = $util.newBuffer([]);

    /**
     * Certificate keyType.
     * @member {KeyType} keyType
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.keyType = 0;

    /**
     * Certificate keyUsage.
     * @member {number} keyUsage
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.keyUsage = 0;

    /**
     * Certificate notBefore.
     * @member {number} notBefore
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.notBefore = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Certificate notAfter.
     * @member {number} notAfter
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.notAfter = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Certificate serialNumber.
     * @member {Uint8Array} serialNumber
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.serialNumber = $util.newBuffer([]);

    /**
     * Certificate signature.
     * @member {Uint8Array} signature
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.signature = $util.newBuffer([]);

    /**
     * Certificate parent.
     * @member {ICertificate|null|undefined} parent
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.parent = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * Certificate parentOneof.
     * @member {"parent"|undefined} parentOneof
     * @memberof Certificate
     * @instance
     */
    Object.defineProperty(Certificate.prototype, "parentOneof", {
        get: $util.oneOfGetter($oneOfFields = ["parent"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new Certificate instance using the specified properties.
     * @function create
     * @memberof Certificate
     * @static
     * @param {ICertificate=} [properties] Properties to set
     * @returns {Certificate} Certificate instance
     */
    Certificate.create = function create(properties) {
        return new Certificate(properties);
    };

    /**
     * Encodes the specified Certificate message. Does not implicitly {@link Certificate.verify|verify} messages.
     * @function encode
     * @memberof Certificate
     * @static
     * @param {ICertificate} message Certificate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Certificate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyType);
        if (message.keyUsage != null && Object.hasOwnProperty.call(message, "keyUsage"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.keyUsage);
        if (message.notBefore != null && Object.hasOwnProperty.call(message, "notBefore"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.notBefore);
        if (message.notAfter != null && Object.hasOwnProperty.call(message, "notAfter"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.notAfter);
        if (message.serialNumber != null && Object.hasOwnProperty.call(message, "serialNumber"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.serialNumber);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
        if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
            $root.Certificate.encode(message.parent, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Certificate message, length delimited. Does not implicitly {@link Certificate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Certificate
     * @static
     * @param {ICertificate} message Certificate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Certificate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Certificate message from the specified reader or buffer.
     * @function decode
     * @memberof Certificate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Certificate} Certificate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Certificate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Certificate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.keyType = reader.int32();
                break;
            case 3:
                message.keyUsage = reader.uint32();
                break;
            case 4:
                message.notBefore = reader.uint64();
                break;
            case 5:
                message.notAfter = reader.uint64();
                break;
            case 6:
                message.serialNumber = reader.bytes();
                break;
            case 7:
                message.signature = reader.bytes();
                break;
            case 8:
                message.parent = $root.Certificate.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Certificate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Certificate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Certificate} Certificate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Certificate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Certificate message.
     * @function verify
     * @memberof Certificate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Certificate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            switch (message.keyType) {
            default:
                return "keyType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            if (!$util.isInteger(message.keyUsage))
                return "keyUsage: integer expected";
        if (message.notBefore != null && message.hasOwnProperty("notBefore"))
            if (!$util.isInteger(message.notBefore) && !(message.notBefore && $util.isInteger(message.notBefore.low) && $util.isInteger(message.notBefore.high)))
                return "notBefore: integer|Long expected";
        if (message.notAfter != null && message.hasOwnProperty("notAfter"))
            if (!$util.isInteger(message.notAfter) && !(message.notAfter && $util.isInteger(message.notAfter.low) && $util.isInteger(message.notAfter.high)))
                return "notAfter: integer|Long expected";
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            if (!(message.serialNumber && typeof message.serialNumber.length === "number" || $util.isString(message.serialNumber)))
                return "serialNumber: buffer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        if (message.parent != null && message.hasOwnProperty("parent")) {
            properties.parentOneof = 1;
            {
                let error = $root.Certificate.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Certificate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Certificate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Certificate} Certificate
     */
    Certificate.fromObject = function fromObject(object) {
        if (object instanceof $root.Certificate)
            return object;
        let message = new $root.Certificate();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        switch (object.keyType) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.keyType = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.keyType = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.keyType = 2;
            break;
        }
        if (object.keyUsage != null)
            message.keyUsage = object.keyUsage >>> 0;
        if (object.notBefore != null)
            if ($util.Long)
                (message.notBefore = $util.Long.fromValue(object.notBefore)).unsigned = true;
            else if (typeof object.notBefore === "string")
                message.notBefore = parseInt(object.notBefore, 10);
            else if (typeof object.notBefore === "number")
                message.notBefore = object.notBefore;
            else if (typeof object.notBefore === "object")
                message.notBefore = new $util.LongBits(object.notBefore.low >>> 0, object.notBefore.high >>> 0).toNumber(true);
        if (object.notAfter != null)
            if ($util.Long)
                (message.notAfter = $util.Long.fromValue(object.notAfter)).unsigned = true;
            else if (typeof object.notAfter === "string")
                message.notAfter = parseInt(object.notAfter, 10);
            else if (typeof object.notAfter === "number")
                message.notAfter = object.notAfter;
            else if (typeof object.notAfter === "object")
                message.notAfter = new $util.LongBits(object.notAfter.low >>> 0, object.notAfter.high >>> 0).toNumber(true);
        if (object.serialNumber != null)
            if (typeof object.serialNumber === "string")
                $util.base64.decode(object.serialNumber, message.serialNumber = $util.newBuffer($util.base64.length(object.serialNumber)), 0);
            else if (object.serialNumber.length)
                message.serialNumber = object.serialNumber;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        if (object.parent != null) {
            if (typeof object.parent !== "object")
                throw TypeError(".Certificate.parent: object expected");
            message.parent = $root.Certificate.fromObject(object.parent);
        }
        return message;
    };

    /**
     * Creates a plain object from a Certificate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Certificate
     * @static
     * @param {Certificate} message Certificate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Certificate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.keyType = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            object.keyUsage = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.notBefore = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.notBefore = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.notAfter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.notAfter = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.serialNumber = "";
            else {
                object.serialNumber = [];
                if (options.bytes !== Array)
                    object.serialNumber = $util.newBuffer(object.serialNumber);
            }
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            object.keyType = options.enums === String ? $root.KeyType[message.keyType] : message.keyType;
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            object.keyUsage = message.keyUsage;
        if (message.notBefore != null && message.hasOwnProperty("notBefore"))
            if (typeof message.notBefore === "number")
                object.notBefore = options.longs === String ? String(message.notBefore) : message.notBefore;
            else
                object.notBefore = options.longs === String ? $util.Long.prototype.toString.call(message.notBefore) : options.longs === Number ? new $util.LongBits(message.notBefore.low >>> 0, message.notBefore.high >>> 0).toNumber(true) : message.notBefore;
        if (message.notAfter != null && message.hasOwnProperty("notAfter"))
            if (typeof message.notAfter === "number")
                object.notAfter = options.longs === String ? String(message.notAfter) : message.notAfter;
            else
                object.notAfter = options.longs === String ? $util.Long.prototype.toString.call(message.notAfter) : options.longs === Number ? new $util.LongBits(message.notAfter.low >>> 0, message.notAfter.high >>> 0).toNumber(true) : message.notAfter;
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            object.serialNumber = options.bytes === String ? $util.base64.encode(message.serialNumber, 0, message.serialNumber.length) : options.bytes === Array ? Array.prototype.slice.call(message.serialNumber) : message.serialNumber;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        if (message.parent != null && message.hasOwnProperty("parent")) {
            object.parent = $root.Certificate.toObject(message.parent, options);
            if (options.oneofs)
                object.parentOneof = "parent";
        }
        return object;
    };

    /**
     * Converts this Certificate to JSON.
     * @function toJSON
     * @memberof Certificate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Certificate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Certificate;
})();

export const Network = $root.Network = (() => {

    /**
     * Properties of a Network.
     * @exports INetwork
     * @interface INetwork
     * @property {number|null} [id] Network id
     * @property {string|null} [name] Network name
     * @property {IKey|null} [key] Network key
     * @property {ICertificate|null} [certificate] Network certificate
     */

    /**
     * Constructs a new Network.
     * @exports Network
     * @classdesc Represents a Network.
     * @implements INetwork
     * @constructor
     * @param {INetwork=} [properties] Properties to set
     */
    function Network(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Network id.
     * @member {number} id
     * @memberof Network
     * @instance
     */
    Network.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Network name.
     * @member {string} name
     * @memberof Network
     * @instance
     */
    Network.prototype.name = "";

    /**
     * Network key.
     * @member {IKey|null|undefined} key
     * @memberof Network
     * @instance
     */
    Network.prototype.key = null;

    /**
     * Network certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof Network
     * @instance
     */
    Network.prototype.certificate = null;

    /**
     * Creates a new Network instance using the specified properties.
     * @function create
     * @memberof Network
     * @static
     * @param {INetwork=} [properties] Properties to set
     * @returns {Network} Network instance
     */
    Network.create = function create(properties) {
        return new Network(properties);
    };

    /**
     * Encodes the specified Network message. Does not implicitly {@link Network.verify|verify} messages.
     * @function encode
     * @memberof Network
     * @static
     * @param {INetwork} message Network message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Network.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Network message, length delimited. Does not implicitly {@link Network.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Network
     * @static
     * @param {INetwork} message Network message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Network.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Network message from the specified reader or buffer.
     * @function decode
     * @memberof Network
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Network} Network
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Network.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Network();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 4:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Network message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Network
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Network} Network
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Network.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Network message.
     * @function verify
     * @memberof Network
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Network.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        return null;
    };

    /**
     * Creates a Network message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Network
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Network} Network
     */
    Network.fromObject = function fromObject(object) {
        if (object instanceof $root.Network)
            return object;
        let message = new $root.Network();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".Network.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".Network.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        return message;
    };

    /**
     * Creates a plain object from a Network message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Network
     * @static
     * @param {Network} message Network
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Network.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            object.key = null;
            object.certificate = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        return object;
    };

    /**
     * Converts this Network to JSON.
     * @function toJSON
     * @memberof Network
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Network.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Network;
})();

export const NetworkMembership = $root.NetworkMembership = (() => {

    /**
     * Properties of a NetworkMembership.
     * @exports INetworkMembership
     * @interface INetworkMembership
     * @property {number|null} [id] NetworkMembership id
     * @property {number|null} [createdAt] NetworkMembership createdAt
     * @property {string|null} [name] NetworkMembership name
     * @property {ICertificate|null} [caCertificate] NetworkMembership caCertificate
     * @property {ICertificate|null} [certificate] NetworkMembership certificate
     * @property {number|null} [lastSeenAt] NetworkMembership lastSeenAt
     */

    /**
     * Constructs a new NetworkMembership.
     * @exports NetworkMembership
     * @classdesc Represents a NetworkMembership.
     * @implements INetworkMembership
     * @constructor
     * @param {INetworkMembership=} [properties] Properties to set
     */
    function NetworkMembership(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkMembership id.
     * @member {number} id
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NetworkMembership createdAt.
     * @member {number} createdAt
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NetworkMembership name.
     * @member {string} name
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.name = "";

    /**
     * NetworkMembership caCertificate.
     * @member {ICertificate|null|undefined} caCertificate
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.caCertificate = null;

    /**
     * NetworkMembership certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.certificate = null;

    /**
     * NetworkMembership lastSeenAt.
     * @member {number} lastSeenAt
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.lastSeenAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new NetworkMembership instance using the specified properties.
     * @function create
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership=} [properties] Properties to set
     * @returns {NetworkMembership} NetworkMembership instance
     */
    NetworkMembership.create = function create(properties) {
        return new NetworkMembership(properties);
    };

    /**
     * Encodes the specified NetworkMembership message. Does not implicitly {@link NetworkMembership.verify|verify} messages.
     * @function encode
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership} message NetworkMembership message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkMembership.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.createdAt);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.caCertificate != null && Object.hasOwnProperty.call(message, "caCertificate"))
            $root.Certificate.encode(message.caCertificate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.lastSeenAt != null && Object.hasOwnProperty.call(message, "lastSeenAt"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.lastSeenAt);
        return writer;
    };

    /**
     * Encodes the specified NetworkMembership message, length delimited. Does not implicitly {@link NetworkMembership.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership} message NetworkMembership message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkMembership.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkMembership message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkMembership
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkMembership} NetworkMembership
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkMembership.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkMembership();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.createdAt = reader.uint64();
                break;
            case 3:
                message.name = reader.string();
                break;
            case 4:
                message.caCertificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 5:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 6:
                message.lastSeenAt = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkMembership message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkMembership
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkMembership} NetworkMembership
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkMembership.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkMembership message.
     * @function verify
     * @memberof NetworkMembership
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkMembership.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.createdAt != null && message.hasOwnProperty("createdAt"))
            if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                return "createdAt: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.caCertificate != null && message.hasOwnProperty("caCertificate")) {
            let error = $root.Certificate.verify(message.caCertificate);
            if (error)
                return "caCertificate." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.lastSeenAt != null && message.hasOwnProperty("lastSeenAt"))
            if (!$util.isInteger(message.lastSeenAt) && !(message.lastSeenAt && $util.isInteger(message.lastSeenAt.low) && $util.isInteger(message.lastSeenAt.high)))
                return "lastSeenAt: integer|Long expected";
        return null;
    };

    /**
     * Creates a NetworkMembership message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkMembership
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkMembership} NetworkMembership
     */
    NetworkMembership.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkMembership)
            return object;
        let message = new $root.NetworkMembership();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.createdAt != null)
            if ($util.Long)
                (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = true;
            else if (typeof object.createdAt === "string")
                message.createdAt = parseInt(object.createdAt, 10);
            else if (typeof object.createdAt === "number")
                message.createdAt = object.createdAt;
            else if (typeof object.createdAt === "object")
                message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.caCertificate != null) {
            if (typeof object.caCertificate !== "object")
                throw TypeError(".NetworkMembership.caCertificate: object expected");
            message.caCertificate = $root.Certificate.fromObject(object.caCertificate);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".NetworkMembership.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.lastSeenAt != null)
            if ($util.Long)
                (message.lastSeenAt = $util.Long.fromValue(object.lastSeenAt)).unsigned = true;
            else if (typeof object.lastSeenAt === "string")
                message.lastSeenAt = parseInt(object.lastSeenAt, 10);
            else if (typeof object.lastSeenAt === "number")
                message.lastSeenAt = object.lastSeenAt;
            else if (typeof object.lastSeenAt === "object")
                message.lastSeenAt = new $util.LongBits(object.lastSeenAt.low >>> 0, object.lastSeenAt.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a NetworkMembership message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkMembership
     * @static
     * @param {NetworkMembership} message NetworkMembership
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkMembership.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.createdAt = options.longs === String ? "0" : 0;
            object.name = "";
            object.caCertificate = null;
            object.certificate = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastSeenAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastSeenAt = options.longs === String ? "0" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.createdAt != null && message.hasOwnProperty("createdAt"))
            if (typeof message.createdAt === "number")
                object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
            else
                object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber(true) : message.createdAt;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.caCertificate != null && message.hasOwnProperty("caCertificate"))
            object.caCertificate = $root.Certificate.toObject(message.caCertificate, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.lastSeenAt != null && message.hasOwnProperty("lastSeenAt"))
            if (typeof message.lastSeenAt === "number")
                object.lastSeenAt = options.longs === String ? String(message.lastSeenAt) : message.lastSeenAt;
            else
                object.lastSeenAt = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeenAt) : options.longs === Number ? new $util.LongBits(message.lastSeenAt.low >>> 0, message.lastSeenAt.high >>> 0).toNumber(true) : message.lastSeenAt;
        return object;
    };

    /**
     * Converts this NetworkMembership to JSON.
     * @function toJSON
     * @memberof NetworkMembership
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkMembership.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NetworkMembership;
})();

export const BootstrapClient = $root.BootstrapClient = (() => {

    /**
     * Properties of a BootstrapClient.
     * @exports IBootstrapClient
     * @interface IBootstrapClient
     * @property {number|null} [id] BootstrapClient id
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] BootstrapClient websocketOptions
     */

    /**
     * Constructs a new BootstrapClient.
     * @exports BootstrapClient
     * @classdesc Represents a BootstrapClient.
     * @implements IBootstrapClient
     * @constructor
     * @param {IBootstrapClient=} [properties] Properties to set
     */
    function BootstrapClient(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapClient id.
     * @member {number} id
     * @memberof BootstrapClient
     * @instance
     */
    BootstrapClient.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BootstrapClient websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof BootstrapClient
     * @instance
     */
    BootstrapClient.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BootstrapClient clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof BootstrapClient
     * @instance
     */
    Object.defineProperty(BootstrapClient.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BootstrapClient instance using the specified properties.
     * @function create
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient=} [properties] Properties to set
     * @returns {BootstrapClient} BootstrapClient instance
     */
    BootstrapClient.create = function create(properties) {
        return new BootstrapClient(properties);
    };

    /**
     * Encodes the specified BootstrapClient message. Does not implicitly {@link BootstrapClient.verify|verify} messages.
     * @function encode
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient} message BootstrapClient message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClient.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BootstrapClient message, length delimited. Does not implicitly {@link BootstrapClient.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient} message BootstrapClient message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClient.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapClient message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapClient} BootstrapClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClient.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapClient();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapClient message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapClient} BootstrapClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClient.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapClient message.
     * @function verify
     * @memberof BootstrapClient
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapClient.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BootstrapClient message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapClient
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapClient} BootstrapClient
     */
    BootstrapClient.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapClient)
            return object;
        let message = new $root.BootstrapClient();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".BootstrapClient.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapClient message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapClient
     * @static
     * @param {BootstrapClient} message BootstrapClient
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapClient.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this BootstrapClient to JSON.
     * @function toJSON
     * @memberof BootstrapClient
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapClient.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapClient;
})();

export const BootstrapClientWebSocketOptions = $root.BootstrapClientWebSocketOptions = (() => {

    /**
     * Properties of a BootstrapClientWebSocketOptions.
     * @exports IBootstrapClientWebSocketOptions
     * @interface IBootstrapClientWebSocketOptions
     * @property {string|null} [url] BootstrapClientWebSocketOptions url
     */

    /**
     * Constructs a new BootstrapClientWebSocketOptions.
     * @exports BootstrapClientWebSocketOptions
     * @classdesc Represents a BootstrapClientWebSocketOptions.
     * @implements IBootstrapClientWebSocketOptions
     * @constructor
     * @param {IBootstrapClientWebSocketOptions=} [properties] Properties to set
     */
    function BootstrapClientWebSocketOptions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapClientWebSocketOptions url.
     * @member {string} url
     * @memberof BootstrapClientWebSocketOptions
     * @instance
     */
    BootstrapClientWebSocketOptions.prototype.url = "";

    /**
     * Creates a new BootstrapClientWebSocketOptions instance using the specified properties.
     * @function create
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions=} [properties] Properties to set
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions instance
     */
    BootstrapClientWebSocketOptions.create = function create(properties) {
        return new BootstrapClientWebSocketOptions(properties);
    };

    /**
     * Encodes the specified BootstrapClientWebSocketOptions message. Does not implicitly {@link BootstrapClientWebSocketOptions.verify|verify} messages.
     * @function encode
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClientWebSocketOptions.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        return writer;
    };

    /**
     * Encodes the specified BootstrapClientWebSocketOptions message, length delimited. Does not implicitly {@link BootstrapClientWebSocketOptions.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClientWebSocketOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapClientWebSocketOptions message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClientWebSocketOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapClientWebSocketOptions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapClientWebSocketOptions message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClientWebSocketOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapClientWebSocketOptions message.
     * @function verify
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapClientWebSocketOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        return null;
    };

    /**
     * Creates a BootstrapClientWebSocketOptions message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     */
    BootstrapClientWebSocketOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapClientWebSocketOptions)
            return object;
        let message = new $root.BootstrapClientWebSocketOptions();
        if (object.url != null)
            message.url = String(object.url);
        return message;
    };

    /**
     * Creates a plain object from a BootstrapClientWebSocketOptions message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {BootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapClientWebSocketOptions.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.url = "";
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        return object;
    };

    /**
     * Converts this BootstrapClientWebSocketOptions to JSON.
     * @function toJSON
     * @memberof BootstrapClientWebSocketOptions
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapClientWebSocketOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapClientWebSocketOptions;
})();

export const Profile = $root.Profile = (() => {

    /**
     * Properties of a Profile.
     * @exports IProfile
     * @interface IProfile
     * @property {number|null} [id] Profile id
     * @property {string|null} [name] Profile name
     * @property {Uint8Array|null} [secret] Profile secret
     * @property {IKey|null} [key] Profile key
     * @property {Array.<INetwork>|null} [networks] Profile networks
     * @property {Array.<INetworkMembership>|null} [networkMemberships] Profile networkMemberships
     */

    /**
     * Constructs a new Profile.
     * @exports Profile
     * @classdesc Represents a Profile.
     * @implements IProfile
     * @constructor
     * @param {IProfile=} [properties] Properties to set
     */
    function Profile(properties) {
        this.networks = [];
        this.networkMemberships = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Profile id.
     * @member {number} id
     * @memberof Profile
     * @instance
     */
    Profile.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Profile name.
     * @member {string} name
     * @memberof Profile
     * @instance
     */
    Profile.prototype.name = "";

    /**
     * Profile secret.
     * @member {Uint8Array} secret
     * @memberof Profile
     * @instance
     */
    Profile.prototype.secret = $util.newBuffer([]);

    /**
     * Profile key.
     * @member {IKey|null|undefined} key
     * @memberof Profile
     * @instance
     */
    Profile.prototype.key = null;

    /**
     * Profile networks.
     * @member {Array.<INetwork>} networks
     * @memberof Profile
     * @instance
     */
    Profile.prototype.networks = $util.emptyArray;

    /**
     * Profile networkMemberships.
     * @member {Array.<INetworkMembership>} networkMemberships
     * @memberof Profile
     * @instance
     */
    Profile.prototype.networkMemberships = $util.emptyArray;

    /**
     * Creates a new Profile instance using the specified properties.
     * @function create
     * @memberof Profile
     * @static
     * @param {IProfile=} [properties] Properties to set
     * @returns {Profile} Profile instance
     */
    Profile.create = function create(properties) {
        return new Profile(properties);
    };

    /**
     * Encodes the specified Profile message. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encode
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.secret);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.networks != null && message.networks.length)
            for (let i = 0; i < message.networks.length; ++i)
                $root.Network.encode(message.networks[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.networkMemberships != null && message.networkMemberships.length)
            for (let i = 0; i < message.networkMemberships.length; ++i)
                $root.NetworkMembership.encode(message.networkMemberships[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Profile message, length delimited. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Profile message from the specified reader or buffer.
     * @function decode
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.secret = reader.bytes();
                break;
            case 4:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 5:
                if (!(message.networks && message.networks.length))
                    message.networks = [];
                message.networks.push($root.Network.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.networkMemberships && message.networkMemberships.length))
                    message.networkMemberships = [];
                message.networkMemberships.push($root.NetworkMembership.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Profile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Profile message.
     * @function verify
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Profile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.secret != null && message.hasOwnProperty("secret"))
            if (!(message.secret && typeof message.secret.length === "number" || $util.isString(message.secret)))
                return "secret: buffer expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.networks != null && message.hasOwnProperty("networks")) {
            if (!Array.isArray(message.networks))
                return "networks: array expected";
            for (let i = 0; i < message.networks.length; ++i) {
                let error = $root.Network.verify(message.networks[i]);
                if (error)
                    return "networks." + error;
            }
        }
        if (message.networkMemberships != null && message.hasOwnProperty("networkMemberships")) {
            if (!Array.isArray(message.networkMemberships))
                return "networkMemberships: array expected";
            for (let i = 0; i < message.networkMemberships.length; ++i) {
                let error = $root.NetworkMembership.verify(message.networkMemberships[i]);
                if (error)
                    return "networkMemberships." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Profile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Profile} Profile
     */
    Profile.fromObject = function fromObject(object) {
        if (object instanceof $root.Profile)
            return object;
        let message = new $root.Profile();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.secret != null)
            if (typeof object.secret === "string")
                $util.base64.decode(object.secret, message.secret = $util.newBuffer($util.base64.length(object.secret)), 0);
            else if (object.secret.length)
                message.secret = object.secret;
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".Profile.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.networks) {
            if (!Array.isArray(object.networks))
                throw TypeError(".Profile.networks: array expected");
            message.networks = [];
            for (let i = 0; i < object.networks.length; ++i) {
                if (typeof object.networks[i] !== "object")
                    throw TypeError(".Profile.networks: object expected");
                message.networks[i] = $root.Network.fromObject(object.networks[i]);
            }
        }
        if (object.networkMemberships) {
            if (!Array.isArray(object.networkMemberships))
                throw TypeError(".Profile.networkMemberships: array expected");
            message.networkMemberships = [];
            for (let i = 0; i < object.networkMemberships.length; ++i) {
                if (typeof object.networkMemberships[i] !== "object")
                    throw TypeError(".Profile.networkMemberships: object expected");
                message.networkMemberships[i] = $root.NetworkMembership.fromObject(object.networkMemberships[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a Profile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Profile
     * @static
     * @param {Profile} message Profile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Profile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.networks = [];
            object.networkMemberships = [];
        }
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            if (options.bytes === String)
                object.secret = "";
            else {
                object.secret = [];
                if (options.bytes !== Array)
                    object.secret = $util.newBuffer(object.secret);
            }
            object.key = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.secret != null && message.hasOwnProperty("secret"))
            object.secret = options.bytes === String ? $util.base64.encode(message.secret, 0, message.secret.length) : options.bytes === Array ? Array.prototype.slice.call(message.secret) : message.secret;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.networks && message.networks.length) {
            object.networks = [];
            for (let j = 0; j < message.networks.length; ++j)
                object.networks[j] = $root.Network.toObject(message.networks[j], options);
        }
        if (message.networkMemberships && message.networkMemberships.length) {
            object.networkMemberships = [];
            for (let j = 0; j < message.networkMemberships.length; ++j)
                object.networkMemberships[j] = $root.NetworkMembership.toObject(message.networkMemberships[j], options);
        }
        return object;
    };

    /**
     * Converts this Profile to JSON.
     * @function toJSON
     * @memberof Profile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Profile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Profile;
})();

export const ProfileSummary = $root.ProfileSummary = (() => {

    /**
     * Properties of a ProfileSummary.
     * @exports IProfileSummary
     * @interface IProfileSummary
     * @property {number|null} [id] ProfileSummary id
     * @property {string|null} [name] ProfileSummary name
     */

    /**
     * Constructs a new ProfileSummary.
     * @exports ProfileSummary
     * @classdesc Represents a ProfileSummary.
     * @implements IProfileSummary
     * @constructor
     * @param {IProfileSummary=} [properties] Properties to set
     */
    function ProfileSummary(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ProfileSummary id.
     * @member {number} id
     * @memberof ProfileSummary
     * @instance
     */
    ProfileSummary.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ProfileSummary name.
     * @member {string} name
     * @memberof ProfileSummary
     * @instance
     */
    ProfileSummary.prototype.name = "";

    /**
     * Creates a new ProfileSummary instance using the specified properties.
     * @function create
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary=} [properties] Properties to set
     * @returns {ProfileSummary} ProfileSummary instance
     */
    ProfileSummary.create = function create(properties) {
        return new ProfileSummary(properties);
    };

    /**
     * Encodes the specified ProfileSummary message. Does not implicitly {@link ProfileSummary.verify|verify} messages.
     * @function encode
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary} message ProfileSummary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileSummary.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified ProfileSummary message, length delimited. Does not implicitly {@link ProfileSummary.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary} message ProfileSummary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileSummary.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ProfileSummary message from the specified reader or buffer.
     * @function decode
     * @memberof ProfileSummary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ProfileSummary} ProfileSummary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileSummary.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProfileSummary();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ProfileSummary message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ProfileSummary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ProfileSummary} ProfileSummary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileSummary.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ProfileSummary message.
     * @function verify
     * @memberof ProfileSummary
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ProfileSummary.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates a ProfileSummary message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ProfileSummary
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ProfileSummary} ProfileSummary
     */
    ProfileSummary.fromObject = function fromObject(object) {
        if (object instanceof $root.ProfileSummary)
            return object;
        let message = new $root.ProfileSummary();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from a ProfileSummary message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ProfileSummary
     * @static
     * @param {ProfileSummary} message ProfileSummary
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ProfileSummary.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this ProfileSummary to JSON.
     * @function toJSON
     * @memberof ProfileSummary
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ProfileSummary.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ProfileSummary;
})();

export const PeerInit = $root.PeerInit = (() => {

    /**
     * Properties of a PeerInit.
     * @exports IPeerInit
     * @interface IPeerInit
     * @property {number|null} [protocolVersion] PeerInit protocolVersion
     * @property {ICertificate|null} [certificate] PeerInit certificate
     * @property {Uint8Array|null} [iv] PeerInit iv
     */

    /**
     * Constructs a new PeerInit.
     * @exports PeerInit
     * @classdesc Represents a PeerInit.
     * @implements IPeerInit
     * @constructor
     * @param {IPeerInit=} [properties] Properties to set
     */
    function PeerInit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerInit protocolVersion.
     * @member {number} protocolVersion
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.protocolVersion = 0;

    /**
     * PeerInit certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.certificate = null;

    /**
     * PeerInit iv.
     * @member {Uint8Array} iv
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.iv = $util.newBuffer([]);

    /**
     * Creates a new PeerInit instance using the specified properties.
     * @function create
     * @memberof PeerInit
     * @static
     * @param {IPeerInit=} [properties] Properties to set
     * @returns {PeerInit} PeerInit instance
     */
    PeerInit.create = function create(properties) {
        return new PeerInit(properties);
    };

    /**
     * Encodes the specified PeerInit message. Does not implicitly {@link PeerInit.verify|verify} messages.
     * @function encode
     * @memberof PeerInit
     * @static
     * @param {IPeerInit} message PeerInit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerInit.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.protocolVersion != null && Object.hasOwnProperty.call(message, "protocolVersion"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.protocolVersion);
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.iv != null && Object.hasOwnProperty.call(message, "iv"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.iv);
        return writer;
    };

    /**
     * Encodes the specified PeerInit message, length delimited. Does not implicitly {@link PeerInit.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerInit
     * @static
     * @param {IPeerInit} message PeerInit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerInit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerInit message from the specified reader or buffer.
     * @function decode
     * @memberof PeerInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerInit} PeerInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerInit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerInit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.protocolVersion = reader.uint32();
                break;
            case 2:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 3:
                message.iv = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerInit message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerInit} PeerInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerInit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerInit message.
     * @function verify
     * @memberof PeerInit
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerInit.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
            if (!$util.isInteger(message.protocolVersion))
                return "protocolVersion: integer expected";
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.iv != null && message.hasOwnProperty("iv"))
            if (!(message.iv && typeof message.iv.length === "number" || $util.isString(message.iv)))
                return "iv: buffer expected";
        return null;
    };

    /**
     * Creates a PeerInit message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerInit
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerInit} PeerInit
     */
    PeerInit.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerInit)
            return object;
        let message = new $root.PeerInit();
        if (object.protocolVersion != null)
            message.protocolVersion = object.protocolVersion >>> 0;
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".PeerInit.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.iv != null)
            if (typeof object.iv === "string")
                $util.base64.decode(object.iv, message.iv = $util.newBuffer($util.base64.length(object.iv)), 0);
            else if (object.iv.length)
                message.iv = object.iv;
        return message;
    };

    /**
     * Creates a plain object from a PeerInit message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerInit
     * @static
     * @param {PeerInit} message PeerInit
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerInit.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.protocolVersion = 0;
            object.certificate = null;
            if (options.bytes === String)
                object.iv = "";
            else {
                object.iv = [];
                if (options.bytes !== Array)
                    object.iv = $util.newBuffer(object.iv);
            }
        }
        if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
            object.protocolVersion = message.protocolVersion;
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.iv != null && message.hasOwnProperty("iv"))
            object.iv = options.bytes === String ? $util.base64.encode(message.iv, 0, message.iv.length) : options.bytes === Array ? Array.prototype.slice.call(message.iv) : message.iv;
        return object;
    };

    /**
     * Converts this PeerInit to JSON.
     * @function toJSON
     * @memberof PeerInit
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerInit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PeerInit;
})();

export const NetworkHandshake = $root.NetworkHandshake = (() => {

    /**
     * Properties of a NetworkHandshake.
     * @exports INetworkHandshake
     * @interface INetworkHandshake
     * @property {NetworkHandshake.IInit|null} [init] NetworkHandshake init
     * @property {NetworkHandshake.INetworkBindings|null} [networkBindings] NetworkHandshake networkBindings
     */

    /**
     * Constructs a new NetworkHandshake.
     * @exports NetworkHandshake
     * @classdesc Represents a NetworkHandshake.
     * @implements INetworkHandshake
     * @constructor
     * @param {INetworkHandshake=} [properties] Properties to set
     */
    function NetworkHandshake(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkHandshake init.
     * @member {NetworkHandshake.IInit|null|undefined} init
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.init = null;

    /**
     * NetworkHandshake networkBindings.
     * @member {NetworkHandshake.INetworkBindings|null|undefined} networkBindings
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.networkBindings = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * NetworkHandshake body.
     * @member {"init"|"networkBindings"|undefined} body
     * @memberof NetworkHandshake
     * @instance
     */
    Object.defineProperty(NetworkHandshake.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["init", "networkBindings"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new NetworkHandshake instance using the specified properties.
     * @function create
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake=} [properties] Properties to set
     * @returns {NetworkHandshake} NetworkHandshake instance
     */
    NetworkHandshake.create = function create(properties) {
        return new NetworkHandshake(properties);
    };

    /**
     * Encodes the specified NetworkHandshake message. Does not implicitly {@link NetworkHandshake.verify|verify} messages.
     * @function encode
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake} message NetworkHandshake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkHandshake.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.init != null && Object.hasOwnProperty.call(message, "init"))
            $root.NetworkHandshake.Init.encode(message.init, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.networkBindings != null && Object.hasOwnProperty.call(message, "networkBindings"))
            $root.NetworkHandshake.NetworkBindings.encode(message.networkBindings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NetworkHandshake message, length delimited. Does not implicitly {@link NetworkHandshake.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake} message NetworkHandshake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkHandshake.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkHandshake message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkHandshake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkHandshake} NetworkHandshake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkHandshake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.init = $root.NetworkHandshake.Init.decode(reader, reader.uint32());
                break;
            case 2:
                message.networkBindings = $root.NetworkHandshake.NetworkBindings.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkHandshake message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkHandshake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkHandshake} NetworkHandshake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkHandshake.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkHandshake message.
     * @function verify
     * @memberof NetworkHandshake
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkHandshake.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.init != null && message.hasOwnProperty("init")) {
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.Init.verify(message.init);
                if (error)
                    return "init." + error;
            }
        }
        if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.NetworkBindings.verify(message.networkBindings);
                if (error)
                    return "networkBindings." + error;
            }
        }
        return null;
    };

    /**
     * Creates a NetworkHandshake message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkHandshake
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkHandshake} NetworkHandshake
     */
    NetworkHandshake.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkHandshake)
            return object;
        let message = new $root.NetworkHandshake();
        if (object.init != null) {
            if (typeof object.init !== "object")
                throw TypeError(".NetworkHandshake.init: object expected");
            message.init = $root.NetworkHandshake.Init.fromObject(object.init);
        }
        if (object.networkBindings != null) {
            if (typeof object.networkBindings !== "object")
                throw TypeError(".NetworkHandshake.networkBindings: object expected");
            message.networkBindings = $root.NetworkHandshake.NetworkBindings.fromObject(object.networkBindings);
        }
        return message;
    };

    /**
     * Creates a plain object from a NetworkHandshake message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkHandshake
     * @static
     * @param {NetworkHandshake} message NetworkHandshake
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkHandshake.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.init != null && message.hasOwnProperty("init")) {
            object.init = $root.NetworkHandshake.Init.toObject(message.init, options);
            if (options.oneofs)
                object.body = "init";
        }
        if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
            object.networkBindings = $root.NetworkHandshake.NetworkBindings.toObject(message.networkBindings, options);
            if (options.oneofs)
                object.body = "networkBindings";
        }
        return object;
    };

    /**
     * Converts this NetworkHandshake to JSON.
     * @function toJSON
     * @memberof NetworkHandshake
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkHandshake.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    NetworkHandshake.Init = (function() {

        /**
         * Properties of an Init.
         * @memberof NetworkHandshake
         * @interface IInit
         * @property {number|null} [keyCount] Init keyCount
         * @property {number|null} [discriminator] Init discriminator
         */

        /**
         * Constructs a new Init.
         * @memberof NetworkHandshake
         * @classdesc Represents an Init.
         * @implements IInit
         * @constructor
         * @param {NetworkHandshake.IInit=} [properties] Properties to set
         */
        function Init(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Init keyCount.
         * @member {number} keyCount
         * @memberof NetworkHandshake.Init
         * @instance
         */
        Init.prototype.keyCount = 0;

        /**
         * Init discriminator.
         * @member {number} discriminator
         * @memberof NetworkHandshake.Init
         * @instance
         */
        Init.prototype.discriminator = 0;

        /**
         * Creates a new Init instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit=} [properties] Properties to set
         * @returns {NetworkHandshake.Init} Init instance
         */
        Init.create = function create(properties) {
            return new Init(properties);
        };

        /**
         * Encodes the specified Init message. Does not implicitly {@link NetworkHandshake.Init.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit} message Init message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Init.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyCount != null && Object.hasOwnProperty.call(message, "keyCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keyCount);
            if (message.discriminator != null && Object.hasOwnProperty.call(message, "discriminator"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.discriminator);
            return writer;
        };

        /**
         * Encodes the specified Init message, length delimited. Does not implicitly {@link NetworkHandshake.Init.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit} message Init message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Init.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Init message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.Init
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.Init} Init
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Init.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.Init();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyCount = reader.int32();
                    break;
                case 2:
                    message.discriminator = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Init message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.Init
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.Init} Init
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Init.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Init message.
         * @function verify
         * @memberof NetworkHandshake.Init
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Init.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyCount != null && message.hasOwnProperty("keyCount"))
                if (!$util.isInteger(message.keyCount))
                    return "keyCount: integer expected";
            if (message.discriminator != null && message.hasOwnProperty("discriminator"))
                if (!$util.isInteger(message.discriminator))
                    return "discriminator: integer expected";
            return null;
        };

        /**
         * Creates an Init message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.Init
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.Init} Init
         */
        Init.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.Init)
                return object;
            let message = new $root.NetworkHandshake.Init();
            if (object.keyCount != null)
                message.keyCount = object.keyCount | 0;
            if (object.discriminator != null)
                message.discriminator = object.discriminator >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Init message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.Init} message Init
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Init.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.keyCount = 0;
                object.discriminator = 0;
            }
            if (message.keyCount != null && message.hasOwnProperty("keyCount"))
                object.keyCount = message.keyCount;
            if (message.discriminator != null && message.hasOwnProperty("discriminator"))
                object.discriminator = message.discriminator;
            return object;
        };

        /**
         * Converts this Init to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.Init
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Init.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Init;
    })();

    NetworkHandshake.NetworkBinding = (function() {

        /**
         * Properties of a NetworkBinding.
         * @memberof NetworkHandshake
         * @interface INetworkBinding
         * @property {number|null} [port] NetworkBinding port
         * @property {ICertificate|null} [certificate] NetworkBinding certificate
         */

        /**
         * Constructs a new NetworkBinding.
         * @memberof NetworkHandshake
         * @classdesc Represents a NetworkBinding.
         * @implements INetworkBinding
         * @constructor
         * @param {NetworkHandshake.INetworkBinding=} [properties] Properties to set
         */
        function NetworkBinding(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkBinding port.
         * @member {number} port
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         */
        NetworkBinding.prototype.port = 0;

        /**
         * NetworkBinding certificate.
         * @member {ICertificate|null|undefined} certificate
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         */
        NetworkBinding.prototype.certificate = null;

        /**
         * Creates a new NetworkBinding instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding=} [properties] Properties to set
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding instance
         */
        NetworkBinding.create = function create(properties) {
            return new NetworkBinding(properties);
        };

        /**
         * Encodes the specified NetworkBinding message. Does not implicitly {@link NetworkHandshake.NetworkBinding.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding} message NetworkBinding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBinding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.port);
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NetworkBinding message, length delimited. Does not implicitly {@link NetworkHandshake.NetworkBinding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding} message NetworkBinding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBinding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkBinding message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBinding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.NetworkBinding();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.port = reader.uint32();
                    break;
                case 2:
                    message.certificate = $root.Certificate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkBinding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBinding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkBinding message.
         * @function verify
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkBinding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.certificate != null && message.hasOwnProperty("certificate")) {
                let error = $root.Certificate.verify(message.certificate);
                if (error)
                    return "certificate." + error;
            }
            return null;
        };

        /**
         * Creates a NetworkBinding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         */
        NetworkBinding.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.NetworkBinding)
                return object;
            let message = new $root.NetworkHandshake.NetworkBinding();
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.certificate != null) {
                if (typeof object.certificate !== "object")
                    throw TypeError(".NetworkHandshake.NetworkBinding.certificate: object expected");
                message.certificate = $root.Certificate.fromObject(object.certificate);
            }
            return message;
        };

        /**
         * Creates a plain object from a NetworkBinding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.NetworkBinding} message NetworkBinding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkBinding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.port = 0;
                object.certificate = null;
            }
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = $root.Certificate.toObject(message.certificate, options);
            return object;
        };

        /**
         * Converts this NetworkBinding to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkBinding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkBinding;
    })();

    NetworkHandshake.NetworkBindings = (function() {

        /**
         * Properties of a NetworkBindings.
         * @memberof NetworkHandshake
         * @interface INetworkBindings
         * @property {number|null} [discriminator] NetworkBindings discriminator
         * @property {Array.<NetworkHandshake.INetworkBinding>|null} [networkBindings] NetworkBindings networkBindings
         */

        /**
         * Constructs a new NetworkBindings.
         * @memberof NetworkHandshake
         * @classdesc Represents a NetworkBindings.
         * @implements INetworkBindings
         * @constructor
         * @param {NetworkHandshake.INetworkBindings=} [properties] Properties to set
         */
        function NetworkBindings(properties) {
            this.networkBindings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkBindings discriminator.
         * @member {number} discriminator
         * @memberof NetworkHandshake.NetworkBindings
         * @instance
         */
        NetworkBindings.prototype.discriminator = 0;

        /**
         * NetworkBindings networkBindings.
         * @member {Array.<NetworkHandshake.INetworkBinding>} networkBindings
         * @memberof NetworkHandshake.NetworkBindings
         * @instance
         */
        NetworkBindings.prototype.networkBindings = $util.emptyArray;

        /**
         * Creates a new NetworkBindings instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings=} [properties] Properties to set
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings instance
         */
        NetworkBindings.create = function create(properties) {
            return new NetworkBindings(properties);
        };

        /**
         * Encodes the specified NetworkBindings message. Does not implicitly {@link NetworkHandshake.NetworkBindings.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings} message NetworkBindings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBindings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.discriminator != null && Object.hasOwnProperty.call(message, "discriminator"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.discriminator);
            if (message.networkBindings != null && message.networkBindings.length)
                for (let i = 0; i < message.networkBindings.length; ++i)
                    $root.NetworkHandshake.NetworkBinding.encode(message.networkBindings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NetworkBindings message, length delimited. Does not implicitly {@link NetworkHandshake.NetworkBindings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings} message NetworkBindings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBindings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkBindings message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBindings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.NetworkBindings();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.discriminator = reader.uint32();
                    break;
                case 2:
                    if (!(message.networkBindings && message.networkBindings.length))
                        message.networkBindings = [];
                    message.networkBindings.push($root.NetworkHandshake.NetworkBinding.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkBindings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBindings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkBindings message.
         * @function verify
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkBindings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.discriminator != null && message.hasOwnProperty("discriminator"))
                if (!$util.isInteger(message.discriminator))
                    return "discriminator: integer expected";
            if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
                if (!Array.isArray(message.networkBindings))
                    return "networkBindings: array expected";
                for (let i = 0; i < message.networkBindings.length; ++i) {
                    let error = $root.NetworkHandshake.NetworkBinding.verify(message.networkBindings[i]);
                    if (error)
                        return "networkBindings." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NetworkBindings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         */
        NetworkBindings.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.NetworkBindings)
                return object;
            let message = new $root.NetworkHandshake.NetworkBindings();
            if (object.discriminator != null)
                message.discriminator = object.discriminator >>> 0;
            if (object.networkBindings) {
                if (!Array.isArray(object.networkBindings))
                    throw TypeError(".NetworkHandshake.NetworkBindings.networkBindings: array expected");
                message.networkBindings = [];
                for (let i = 0; i < object.networkBindings.length; ++i) {
                    if (typeof object.networkBindings[i] !== "object")
                        throw TypeError(".NetworkHandshake.NetworkBindings.networkBindings: object expected");
                    message.networkBindings[i] = $root.NetworkHandshake.NetworkBinding.fromObject(object.networkBindings[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NetworkBindings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.NetworkBindings} message NetworkBindings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkBindings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.networkBindings = [];
            if (options.defaults)
                object.discriminator = 0;
            if (message.discriminator != null && message.hasOwnProperty("discriminator"))
                object.discriminator = message.discriminator;
            if (message.networkBindings && message.networkBindings.length) {
                object.networkBindings = [];
                for (let j = 0; j < message.networkBindings.length; ++j)
                    object.networkBindings[j] = $root.NetworkHandshake.NetworkBinding.toObject(message.networkBindings[j], options);
            }
            return object;
        };

        /**
         * Converts this NetworkBindings to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.NetworkBindings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkBindings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkBindings;
    })();

    return NetworkHandshake;
})();

export const HashTableMessage = $root.HashTableMessage = (() => {

    /**
     * Properties of a HashTableMessage.
     * @exports IHashTableMessage
     * @interface IHashTableMessage
     * @property {HashTableMessage.IPublish|null} [publish] HashTableMessage publish
     * @property {HashTableMessage.IUnpublish|null} [unpublish] HashTableMessage unpublish
     * @property {HashTableMessage.IGetRequest|null} [getRequest] HashTableMessage getRequest
     * @property {HashTableMessage.IGetResponse|null} [getResponse] HashTableMessage getResponse
     */

    /**
     * Constructs a new HashTableMessage.
     * @exports HashTableMessage
     * @classdesc Represents a HashTableMessage.
     * @implements IHashTableMessage
     * @constructor
     * @param {IHashTableMessage=} [properties] Properties to set
     */
    function HashTableMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HashTableMessage publish.
     * @member {HashTableMessage.IPublish|null|undefined} publish
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.publish = null;

    /**
     * HashTableMessage unpublish.
     * @member {HashTableMessage.IUnpublish|null|undefined} unpublish
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.unpublish = null;

    /**
     * HashTableMessage getRequest.
     * @member {HashTableMessage.IGetRequest|null|undefined} getRequest
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.getRequest = null;

    /**
     * HashTableMessage getResponse.
     * @member {HashTableMessage.IGetResponse|null|undefined} getResponse
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.getResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * HashTableMessage body.
     * @member {"publish"|"unpublish"|"getRequest"|"getResponse"|undefined} body
     * @memberof HashTableMessage
     * @instance
     */
    Object.defineProperty(HashTableMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "getRequest", "getResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new HashTableMessage instance using the specified properties.
     * @function create
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage=} [properties] Properties to set
     * @returns {HashTableMessage} HashTableMessage instance
     */
    HashTableMessage.create = function create(properties) {
        return new HashTableMessage(properties);
    };

    /**
     * Encodes the specified HashTableMessage message. Does not implicitly {@link HashTableMessage.verify|verify} messages.
     * @function encode
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage} message HashTableMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashTableMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.HashTableMessage.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.HashTableMessage.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.getRequest != null && Object.hasOwnProperty.call(message, "getRequest"))
            $root.HashTableMessage.GetRequest.encode(message.getRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.getResponse != null && Object.hasOwnProperty.call(message, "getResponse"))
            $root.HashTableMessage.GetResponse.encode(message.getResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified HashTableMessage message, length delimited. Does not implicitly {@link HashTableMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage} message HashTableMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashTableMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HashTableMessage message from the specified reader or buffer.
     * @function decode
     * @memberof HashTableMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HashTableMessage} HashTableMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashTableMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.HashTableMessage.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.HashTableMessage.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.getRequest = $root.HashTableMessage.GetRequest.decode(reader, reader.uint32());
                break;
            case 4:
                message.getResponse = $root.HashTableMessage.GetResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HashTableMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HashTableMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HashTableMessage} HashTableMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashTableMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HashTableMessage message.
     * @function verify
     * @memberof HashTableMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HashTableMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.HashTableMessage.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.getRequest != null && message.hasOwnProperty("getRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.GetRequest.verify(message.getRequest);
                if (error)
                    return "getRequest." + error;
            }
        }
        if (message.getResponse != null && message.hasOwnProperty("getResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.GetResponse.verify(message.getResponse);
                if (error)
                    return "getResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a HashTableMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HashTableMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HashTableMessage} HashTableMessage
     */
    HashTableMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.HashTableMessage)
            return object;
        let message = new $root.HashTableMessage();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".HashTableMessage.publish: object expected");
            message.publish = $root.HashTableMessage.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".HashTableMessage.unpublish: object expected");
            message.unpublish = $root.HashTableMessage.Unpublish.fromObject(object.unpublish);
        }
        if (object.getRequest != null) {
            if (typeof object.getRequest !== "object")
                throw TypeError(".HashTableMessage.getRequest: object expected");
            message.getRequest = $root.HashTableMessage.GetRequest.fromObject(object.getRequest);
        }
        if (object.getResponse != null) {
            if (typeof object.getResponse !== "object")
                throw TypeError(".HashTableMessage.getResponse: object expected");
            message.getResponse = $root.HashTableMessage.GetResponse.fromObject(object.getResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a HashTableMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HashTableMessage
     * @static
     * @param {HashTableMessage} message HashTableMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HashTableMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.HashTableMessage.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.HashTableMessage.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.getRequest != null && message.hasOwnProperty("getRequest")) {
            object.getRequest = $root.HashTableMessage.GetRequest.toObject(message.getRequest, options);
            if (options.oneofs)
                object.body = "getRequest";
        }
        if (message.getResponse != null && message.hasOwnProperty("getResponse")) {
            object.getResponse = $root.HashTableMessage.GetResponse.toObject(message.getResponse, options);
            if (options.oneofs)
                object.body = "getResponse";
        }
        return object;
    };

    /**
     * Converts this HashTableMessage to JSON.
     * @function toJSON
     * @memberof HashTableMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HashTableMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    HashTableMessage.Record = (function() {

        /**
         * Properties of a Record.
         * @memberof HashTableMessage
         * @interface IRecord
         * @property {Uint8Array|null} [key] Record key
         * @property {Uint8Array|null} [salt] Record salt
         * @property {Uint8Array|null} [value] Record value
         * @property {number|null} [timestamp] Record timestamp
         * @property {Uint8Array|null} [signature] Record signature
         */

        /**
         * Constructs a new Record.
         * @memberof HashTableMessage
         * @classdesc Represents a Record.
         * @implements IRecord
         * @constructor
         * @param {HashTableMessage.IRecord=} [properties] Properties to set
         */
        function Record(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Record key.
         * @member {Uint8Array} key
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.key = $util.newBuffer([]);

        /**
         * Record salt.
         * @member {Uint8Array} salt
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.salt = $util.newBuffer([]);

        /**
         * Record value.
         * @member {Uint8Array} value
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.value = $util.newBuffer([]);

        /**
         * Record timestamp.
         * @member {number} timestamp
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Record signature.
         * @member {Uint8Array} signature
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Record instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord=} [properties] Properties to set
         * @returns {HashTableMessage.Record} Record instance
         */
        Record.create = function create(properties) {
            return new Record(properties);
        };

        /**
         * Encodes the specified Record message. Does not implicitly {@link HashTableMessage.Record.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified Record message, length delimited. Does not implicitly {@link HashTableMessage.Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Record message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Record();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.value = reader.bytes();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Record message.
         * @function verify
         * @memberof HashTableMessage.Record
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Record.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Record} Record
         */
        Record.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Record)
                return object;
            let message = new $root.HashTableMessage.Record();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.Record} message Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this Record to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Record;
    })();

    HashTableMessage.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof HashTableMessage
         * @interface IPublish
         * @property {HashTableMessage.IRecord|null} [record] Publish record
         */

        /**
         * Constructs a new Publish.
         * @memberof HashTableMessage
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {HashTableMessage.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.Publish
         * @instance
         */
        Publish.prototype.record = null;

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish=} [properties] Properties to set
         * @returns {HashTableMessage.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link HashTableMessage.Publish.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link HashTableMessage.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof HashTableMessage.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Publish)
                return object;
            let message = new $root.HashTableMessage.Publish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.Publish.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    HashTableMessage.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof HashTableMessage
         * @interface IUnpublish
         * @property {HashTableMessage.IRecord|null} [record] Unpublish record
         */

        /**
         * Constructs a new Unpublish.
         * @memberof HashTableMessage
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {HashTableMessage.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.Unpublish
         * @instance
         */
        Unpublish.prototype.record = null;

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish=} [properties] Properties to set
         * @returns {HashTableMessage.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link HashTableMessage.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link HashTableMessage.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Unpublish)
                return object;
            let message = new $root.HashTableMessage.Unpublish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.Unpublish.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    HashTableMessage.GetRequest = (function() {

        /**
         * Properties of a GetRequest.
         * @memberof HashTableMessage
         * @interface IGetRequest
         * @property {number|null} [requestId] GetRequest requestId
         * @property {Uint8Array|null} [hash] GetRequest hash
         */

        /**
         * Constructs a new GetRequest.
         * @memberof HashTableMessage
         * @classdesc Represents a GetRequest.
         * @implements IGetRequest
         * @constructor
         * @param {HashTableMessage.IGetRequest=} [properties] Properties to set
         */
        function GetRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRequest requestId.
         * @member {number} requestId
         * @memberof HashTableMessage.GetRequest
         * @instance
         */
        GetRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetRequest hash.
         * @member {Uint8Array} hash
         * @memberof HashTableMessage.GetRequest
         * @instance
         */
        GetRequest.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new GetRequest instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest=} [properties] Properties to set
         * @returns {HashTableMessage.GetRequest} GetRequest instance
         */
        GetRequest.create = function create(properties) {
            return new GetRequest(properties);
        };

        /**
         * Encodes the specified GetRequest message. Does not implicitly {@link HashTableMessage.GetRequest.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest} message GetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified GetRequest message, length delimited. Does not implicitly {@link HashTableMessage.GetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest} message GetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.GetRequest} GetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.GetRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.GetRequest} GetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRequest message.
         * @function verify
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a GetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.GetRequest} GetRequest
         */
        GetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.GetRequest)
                return object;
            let message = new $root.HashTableMessage.GetRequest();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a GetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.GetRequest} message GetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this GetRequest to JSON.
         * @function toJSON
         * @memberof HashTableMessage.GetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRequest;
    })();

    HashTableMessage.GetResponse = (function() {

        /**
         * Properties of a GetResponse.
         * @memberof HashTableMessage
         * @interface IGetResponse
         * @property {number|null} [requestId] GetResponse requestId
         * @property {HashTableMessage.IRecord|null} [record] GetResponse record
         */

        /**
         * Constructs a new GetResponse.
         * @memberof HashTableMessage
         * @classdesc Represents a GetResponse.
         * @implements IGetResponse
         * @constructor
         * @param {HashTableMessage.IGetResponse=} [properties] Properties to set
         */
        function GetResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetResponse requestId.
         * @member {number} requestId
         * @memberof HashTableMessage.GetResponse
         * @instance
         */
        GetResponse.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetResponse record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.GetResponse
         * @instance
         */
        GetResponse.prototype.record = null;

        /**
         * Creates a new GetResponse instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse=} [properties] Properties to set
         * @returns {HashTableMessage.GetResponse} GetResponse instance
         */
        GetResponse.create = function create(properties) {
            return new GetResponse(properties);
        };

        /**
         * Encodes the specified GetResponse message. Does not implicitly {@link HashTableMessage.GetResponse.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse} message GetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetResponse message, length delimited. Does not implicitly {@link HashTableMessage.GetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse} message GetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.GetResponse} GetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.GetResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.GetResponse} GetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetResponse message.
         * @function verify
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a GetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.GetResponse} GetResponse
         */
        GetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.GetResponse)
                return object;
            let message = new $root.HashTableMessage.GetResponse();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.GetResponse.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.GetResponse} message GetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                object.record = null;
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this GetResponse to JSON.
         * @function toJSON
         * @memberof HashTableMessage.GetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetResponse;
    })();

    return HashTableMessage;
})();

export const PeerExchangeMessage = $root.PeerExchangeMessage = (() => {

    /**
     * Properties of a PeerExchangeMessage.
     * @exports IPeerExchangeMessage
     * @interface IPeerExchangeMessage
     * @property {PeerExchangeMessage.IRequest|null} [request] PeerExchangeMessage request
     * @property {PeerExchangeMessage.IResponse|null} [response] PeerExchangeMessage response
     * @property {PeerExchangeMessage.IOffer|null} [offer] PeerExchangeMessage offer
     * @property {PeerExchangeMessage.IAnswer|null} [answer] PeerExchangeMessage answer
     * @property {PeerExchangeMessage.IIceCandidate|null} [iceCandidate] PeerExchangeMessage iceCandidate
     * @property {PeerExchangeMessage.ICallbackRequest|null} [callbackRequest] PeerExchangeMessage callbackRequest
     */

    /**
     * Constructs a new PeerExchangeMessage.
     * @exports PeerExchangeMessage
     * @classdesc Represents a PeerExchangeMessage.
     * @implements IPeerExchangeMessage
     * @constructor
     * @param {IPeerExchangeMessage=} [properties] Properties to set
     */
    function PeerExchangeMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerExchangeMessage request.
     * @member {PeerExchangeMessage.IRequest|null|undefined} request
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.request = null;

    /**
     * PeerExchangeMessage response.
     * @member {PeerExchangeMessage.IResponse|null|undefined} response
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.response = null;

    /**
     * PeerExchangeMessage offer.
     * @member {PeerExchangeMessage.IOffer|null|undefined} offer
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.offer = null;

    /**
     * PeerExchangeMessage answer.
     * @member {PeerExchangeMessage.IAnswer|null|undefined} answer
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.answer = null;

    /**
     * PeerExchangeMessage iceCandidate.
     * @member {PeerExchangeMessage.IIceCandidate|null|undefined} iceCandidate
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.iceCandidate = null;

    /**
     * PeerExchangeMessage callbackRequest.
     * @member {PeerExchangeMessage.ICallbackRequest|null|undefined} callbackRequest
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.callbackRequest = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PeerExchangeMessage body.
     * @member {"request"|"response"|"offer"|"answer"|"iceCandidate"|"callbackRequest"|undefined} body
     * @memberof PeerExchangeMessage
     * @instance
     */
    Object.defineProperty(PeerExchangeMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["request", "response", "offer", "answer", "iceCandidate", "callbackRequest"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PeerExchangeMessage instance using the specified properties.
     * @function create
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage=} [properties] Properties to set
     * @returns {PeerExchangeMessage} PeerExchangeMessage instance
     */
    PeerExchangeMessage.create = function create(properties) {
        return new PeerExchangeMessage(properties);
    };

    /**
     * Encodes the specified PeerExchangeMessage message. Does not implicitly {@link PeerExchangeMessage.verify|verify} messages.
     * @function encode
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage} message PeerExchangeMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerExchangeMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.request != null && Object.hasOwnProperty.call(message, "request"))
            $root.PeerExchangeMessage.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.response != null && Object.hasOwnProperty.call(message, "response"))
            $root.PeerExchangeMessage.Response.encode(message.response, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
            $root.PeerExchangeMessage.Offer.encode(message.offer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
            $root.PeerExchangeMessage.Answer.encode(message.answer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.iceCandidate != null && Object.hasOwnProperty.call(message, "iceCandidate"))
            $root.PeerExchangeMessage.IceCandidate.encode(message.iceCandidate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.callbackRequest != null && Object.hasOwnProperty.call(message, "callbackRequest"))
            $root.PeerExchangeMessage.CallbackRequest.encode(message.callbackRequest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerExchangeMessage message, length delimited. Does not implicitly {@link PeerExchangeMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage} message PeerExchangeMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerExchangeMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerExchangeMessage message from the specified reader or buffer.
     * @function decode
     * @memberof PeerExchangeMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerExchangeMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.request = $root.PeerExchangeMessage.Request.decode(reader, reader.uint32());
                break;
            case 2:
                message.response = $root.PeerExchangeMessage.Response.decode(reader, reader.uint32());
                break;
            case 3:
                message.offer = $root.PeerExchangeMessage.Offer.decode(reader, reader.uint32());
                break;
            case 4:
                message.answer = $root.PeerExchangeMessage.Answer.decode(reader, reader.uint32());
                break;
            case 5:
                message.iceCandidate = $root.PeerExchangeMessage.IceCandidate.decode(reader, reader.uint32());
                break;
            case 6:
                message.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerExchangeMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerExchangeMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerExchangeMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerExchangeMessage message.
     * @function verify
     * @memberof PeerExchangeMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerExchangeMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.request != null && message.hasOwnProperty("request")) {
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Request.verify(message.request);
                if (error)
                    return "request." + error;
            }
        }
        if (message.response != null && message.hasOwnProperty("response")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Response.verify(message.response);
                if (error)
                    return "response." + error;
            }
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Offer.verify(message.offer);
                if (error)
                    return "offer." + error;
            }
        }
        if (message.answer != null && message.hasOwnProperty("answer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Answer.verify(message.answer);
                if (error)
                    return "answer." + error;
            }
        }
        if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.IceCandidate.verify(message.iceCandidate);
                if (error)
                    return "iceCandidate." + error;
            }
        }
        if (message.callbackRequest != null && message.hasOwnProperty("callbackRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.CallbackRequest.verify(message.callbackRequest);
                if (error)
                    return "callbackRequest." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PeerExchangeMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerExchangeMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     */
    PeerExchangeMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerExchangeMessage)
            return object;
        let message = new $root.PeerExchangeMessage();
        if (object.request != null) {
            if (typeof object.request !== "object")
                throw TypeError(".PeerExchangeMessage.request: object expected");
            message.request = $root.PeerExchangeMessage.Request.fromObject(object.request);
        }
        if (object.response != null) {
            if (typeof object.response !== "object")
                throw TypeError(".PeerExchangeMessage.response: object expected");
            message.response = $root.PeerExchangeMessage.Response.fromObject(object.response);
        }
        if (object.offer != null) {
            if (typeof object.offer !== "object")
                throw TypeError(".PeerExchangeMessage.offer: object expected");
            message.offer = $root.PeerExchangeMessage.Offer.fromObject(object.offer);
        }
        if (object.answer != null) {
            if (typeof object.answer !== "object")
                throw TypeError(".PeerExchangeMessage.answer: object expected");
            message.answer = $root.PeerExchangeMessage.Answer.fromObject(object.answer);
        }
        if (object.iceCandidate != null) {
            if (typeof object.iceCandidate !== "object")
                throw TypeError(".PeerExchangeMessage.iceCandidate: object expected");
            message.iceCandidate = $root.PeerExchangeMessage.IceCandidate.fromObject(object.iceCandidate);
        }
        if (object.callbackRequest != null) {
            if (typeof object.callbackRequest !== "object")
                throw TypeError(".PeerExchangeMessage.callbackRequest: object expected");
            message.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.fromObject(object.callbackRequest);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerExchangeMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerExchangeMessage
     * @static
     * @param {PeerExchangeMessage} message PeerExchangeMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerExchangeMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.request != null && message.hasOwnProperty("request")) {
            object.request = $root.PeerExchangeMessage.Request.toObject(message.request, options);
            if (options.oneofs)
                object.body = "request";
        }
        if (message.response != null && message.hasOwnProperty("response")) {
            object.response = $root.PeerExchangeMessage.Response.toObject(message.response, options);
            if (options.oneofs)
                object.body = "response";
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            object.offer = $root.PeerExchangeMessage.Offer.toObject(message.offer, options);
            if (options.oneofs)
                object.body = "offer";
        }
        if (message.answer != null && message.hasOwnProperty("answer")) {
            object.answer = $root.PeerExchangeMessage.Answer.toObject(message.answer, options);
            if (options.oneofs)
                object.body = "answer";
        }
        if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
            object.iceCandidate = $root.PeerExchangeMessage.IceCandidate.toObject(message.iceCandidate, options);
            if (options.oneofs)
                object.body = "iceCandidate";
        }
        if (message.callbackRequest != null && message.hasOwnProperty("callbackRequest")) {
            object.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.toObject(message.callbackRequest, options);
            if (options.oneofs)
                object.body = "callbackRequest";
        }
        return object;
    };

    /**
     * Converts this PeerExchangeMessage to JSON.
     * @function toJSON
     * @memberof PeerExchangeMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerExchangeMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PeerExchangeMessage.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof PeerExchangeMessage
         * @interface IRequest
         * @property {number|null} [count] Request count
         */

        /**
         * Constructs a new Request.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {PeerExchangeMessage.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request count.
         * @member {number} count
         * @memberof PeerExchangeMessage.Request
         * @instance
         */
        Request.prototype.count = 0;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link PeerExchangeMessage.Request.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.count);
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link PeerExchangeMessage.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Request)
                return object;
            let message = new $root.PeerExchangeMessage.Request();
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    PeerExchangeMessage.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof PeerExchangeMessage
         * @interface IResponse
         * @property {Array.<Uint8Array>|null} [ids] Response ids
         */

        /**
         * Constructs a new Response.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {PeerExchangeMessage.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            this.ids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response ids.
         * @member {Array.<Uint8Array>} ids
         * @memberof PeerExchangeMessage.Response
         * @instance
         */
        Response.prototype.ids = $util.emptyArray;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link PeerExchangeMessage.Response.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (let i = 0; i < message.ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ids[i]);
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link PeerExchangeMessage.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Response();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (let i = 0; i < message.ids.length; ++i)
                    if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                        return "ids: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Response)
                return object;
            let message = new $root.PeerExchangeMessage.Response();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".PeerExchangeMessage.Response.ids: array expected");
                message.ids = [];
                for (let i = 0; i < object.ids.length; ++i)
                    if (typeof object.ids[i] === "string")
                        $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                    else if (object.ids[i].length)
                        message.ids[i] = object.ids[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (let j = 0; j < message.ids.length; ++j)
                    object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
            }
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    PeerExchangeMessage.Offer = (function() {

        /**
         * Properties of an Offer.
         * @memberof PeerExchangeMessage
         * @interface IOffer
         * @property {number|null} [mediationId] Offer mediationId
         * @property {Uint8Array|null} [data] Offer data
         */

        /**
         * Constructs a new Offer.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an Offer.
         * @implements IOffer
         * @constructor
         * @param {PeerExchangeMessage.IOffer=} [properties] Properties to set
         */
        function Offer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Offer mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.Offer
         * @instance
         */
        Offer.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Offer data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.Offer
         * @instance
         */
        Offer.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Offer instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Offer} Offer instance
         */
        Offer.create = function create(properties) {
            return new Offer(properties);
        };

        /**
         * Encodes the specified Offer message. Does not implicitly {@link PeerExchangeMessage.Offer.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Offer message, length delimited. Does not implicitly {@link PeerExchangeMessage.Offer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Offer message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Offer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Offer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Offer message.
         * @function verify
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Offer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an Offer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Offer} Offer
         */
        Offer.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Offer)
                return object;
            let message = new $root.PeerExchangeMessage.Offer();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an Offer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.Offer} message Offer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Offer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Offer to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Offer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Offer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Offer;
    })();

    PeerExchangeMessage.Answer = (function() {

        /**
         * Properties of an Answer.
         * @memberof PeerExchangeMessage
         * @interface IAnswer
         * @property {number|null} [mediationId] Answer mediationId
         * @property {Uint8Array|null} [data] Answer data
         */

        /**
         * Constructs a new Answer.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an Answer.
         * @implements IAnswer
         * @constructor
         * @param {PeerExchangeMessage.IAnswer=} [properties] Properties to set
         */
        function Answer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Answer mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.Answer
         * @instance
         */
        Answer.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Answer data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.Answer
         * @instance
         */
        Answer.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Answer instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Answer} Answer instance
         */
        Answer.create = function create(properties) {
            return new Answer(properties);
        };

        /**
         * Encodes the specified Answer message. Does not implicitly {@link PeerExchangeMessage.Answer.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Answer message, length delimited. Does not implicitly {@link PeerExchangeMessage.Answer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Answer message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Answer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Answer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Answer message.
         * @function verify
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Answer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an Answer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Answer} Answer
         */
        Answer.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Answer)
                return object;
            let message = new $root.PeerExchangeMessage.Answer();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an Answer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.Answer} message Answer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Answer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Answer to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Answer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Answer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Answer;
    })();

    PeerExchangeMessage.IceCandidate = (function() {

        /**
         * Properties of an IceCandidate.
         * @memberof PeerExchangeMessage
         * @interface IIceCandidate
         * @property {number|null} [mediationId] IceCandidate mediationId
         * @property {number|null} [index] IceCandidate index
         * @property {Uint8Array|null} [data] IceCandidate data
         */

        /**
         * Constructs a new IceCandidate.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an IceCandidate.
         * @implements IIceCandidate
         * @constructor
         * @param {PeerExchangeMessage.IIceCandidate=} [properties] Properties to set
         */
        function IceCandidate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceCandidate mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IceCandidate index.
         * @member {number} index
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IceCandidate data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new IceCandidate instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate=} [properties] Properties to set
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate instance
         */
        IceCandidate.create = function create(properties) {
            return new IceCandidate(properties);
        };

        /**
         * Encodes the specified IceCandidate message. Does not implicitly {@link PeerExchangeMessage.IceCandidate.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link PeerExchangeMessage.IceCandidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.IceCandidate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.index = reader.uint64();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceCandidate message.
         * @function verify
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceCandidate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         */
        IceCandidate.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.IceCandidate)
                return object;
            let message = new $root.PeerExchangeMessage.IceCandidate();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IceCandidate} message IceCandidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceCandidate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this IceCandidate to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceCandidate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceCandidate;
    })();

    PeerExchangeMessage.CallbackRequest = (function() {

        /**
         * Properties of a CallbackRequest.
         * @memberof PeerExchangeMessage
         * @interface ICallbackRequest
         */

        /**
         * Constructs a new CallbackRequest.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a CallbackRequest.
         * @implements ICallbackRequest
         * @constructor
         * @param {PeerExchangeMessage.ICallbackRequest=} [properties] Properties to set
         */
        function CallbackRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CallbackRequest instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest=} [properties] Properties to set
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest instance
         */
        CallbackRequest.create = function create(properties) {
            return new CallbackRequest(properties);
        };

        /**
         * Encodes the specified CallbackRequest message. Does not implicitly {@link PeerExchangeMessage.CallbackRequest.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest} message CallbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallbackRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CallbackRequest message, length delimited. Does not implicitly {@link PeerExchangeMessage.CallbackRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest} message CallbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallbackRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallbackRequest message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallbackRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.CallbackRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallbackRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallbackRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallbackRequest message.
         * @function verify
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallbackRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CallbackRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         */
        CallbackRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.CallbackRequest)
                return object;
            return new $root.PeerExchangeMessage.CallbackRequest();
        };

        /**
         * Creates a plain object from a CallbackRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.CallbackRequest} message CallbackRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallbackRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CallbackRequest to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.CallbackRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallbackRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallbackRequest;
    })();

    return PeerExchangeMessage;
})();

export const SwarmThingMessage = $root.SwarmThingMessage = (() => {

    /**
     * Properties of a SwarmThingMessage.
     * @exports ISwarmThingMessage
     * @interface ISwarmThingMessage
     * @property {SwarmThingMessage.IOpen|null} [open] SwarmThingMessage open
     * @property {SwarmThingMessage.IClose|null} [close] SwarmThingMessage close
     */

    /**
     * Constructs a new SwarmThingMessage.
     * @exports SwarmThingMessage
     * @classdesc Represents a SwarmThingMessage.
     * @implements ISwarmThingMessage
     * @constructor
     * @param {ISwarmThingMessage=} [properties] Properties to set
     */
    function SwarmThingMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SwarmThingMessage open.
     * @member {SwarmThingMessage.IOpen|null|undefined} open
     * @memberof SwarmThingMessage
     * @instance
     */
    SwarmThingMessage.prototype.open = null;

    /**
     * SwarmThingMessage close.
     * @member {SwarmThingMessage.IClose|null|undefined} close
     * @memberof SwarmThingMessage
     * @instance
     */
    SwarmThingMessage.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * SwarmThingMessage body.
     * @member {"open"|"close"|undefined} body
     * @memberof SwarmThingMessage
     * @instance
     */
    Object.defineProperty(SwarmThingMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new SwarmThingMessage instance using the specified properties.
     * @function create
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage=} [properties] Properties to set
     * @returns {SwarmThingMessage} SwarmThingMessage instance
     */
    SwarmThingMessage.create = function create(properties) {
        return new SwarmThingMessage(properties);
    };

    /**
     * Encodes the specified SwarmThingMessage message. Does not implicitly {@link SwarmThingMessage.verify|verify} messages.
     * @function encode
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage} message SwarmThingMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SwarmThingMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.SwarmThingMessage.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.SwarmThingMessage.Close.encode(message.close, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SwarmThingMessage message, length delimited. Does not implicitly {@link SwarmThingMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage} message SwarmThingMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SwarmThingMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SwarmThingMessage message from the specified reader or buffer.
     * @function decode
     * @memberof SwarmThingMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SwarmThingMessage} SwarmThingMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SwarmThingMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.SwarmThingMessage.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.close = $root.SwarmThingMessage.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SwarmThingMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SwarmThingMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SwarmThingMessage} SwarmThingMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SwarmThingMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SwarmThingMessage message.
     * @function verify
     * @memberof SwarmThingMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SwarmThingMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.SwarmThingMessage.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.SwarmThingMessage.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SwarmThingMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SwarmThingMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SwarmThingMessage} SwarmThingMessage
     */
    SwarmThingMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.SwarmThingMessage)
            return object;
        let message = new $root.SwarmThingMessage();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".SwarmThingMessage.open: object expected");
            message.open = $root.SwarmThingMessage.Open.fromObject(object.open);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".SwarmThingMessage.close: object expected");
            message.close = $root.SwarmThingMessage.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a SwarmThingMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SwarmThingMessage
     * @static
     * @param {SwarmThingMessage} message SwarmThingMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SwarmThingMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.SwarmThingMessage.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.SwarmThingMessage.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this SwarmThingMessage to JSON.
     * @function toJSON
     * @memberof SwarmThingMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SwarmThingMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    SwarmThingMessage.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof SwarmThingMessage
         * @interface IOpen
         * @property {Uint8Array|null} [swarmId] Open swarmId
         * @property {number|null} [port] Open port
         */

        /**
         * Constructs a new Open.
         * @memberof SwarmThingMessage
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {SwarmThingMessage.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open swarmId.
         * @member {Uint8Array} swarmId
         * @memberof SwarmThingMessage.Open
         * @instance
         */
        Open.prototype.swarmId = $util.newBuffer([]);

        /**
         * Open port.
         * @member {number} port
         * @memberof SwarmThingMessage.Open
         * @instance
         */
        Open.prototype.port = 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen=} [properties] Properties to set
         * @returns {SwarmThingMessage.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link SwarmThingMessage.Open.verify|verify} messages.
         * @function encode
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swarmId != null && Object.hasOwnProperty.call(message, "swarmId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swarmId);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link SwarmThingMessage.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SwarmThingMessage.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.swarmId = reader.bytes();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SwarmThingMessage.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                if (!(message.swarmId && typeof message.swarmId.length === "number" || $util.isString(message.swarmId)))
                    return "swarmId: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SwarmThingMessage.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.SwarmThingMessage.Open)
                return object;
            let message = new $root.SwarmThingMessage.Open();
            if (object.swarmId != null)
                if (typeof object.swarmId === "string")
                    $util.base64.decode(object.swarmId, message.swarmId = $util.newBuffer($util.base64.length(object.swarmId)), 0);
                else if (object.swarmId.length)
                    message.swarmId = object.swarmId;
            if (object.port != null)
                message.port = object.port >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.swarmId = "";
                else {
                    object.swarmId = [];
                    if (options.bytes !== Array)
                        object.swarmId = $util.newBuffer(object.swarmId);
                }
                object.port = 0;
            }
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                object.swarmId = options.bytes === String ? $util.base64.encode(message.swarmId, 0, message.swarmId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swarmId) : message.swarmId;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof SwarmThingMessage.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    SwarmThingMessage.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof SwarmThingMessage
         * @interface IClose
         * @property {Uint8Array|null} [swarmId] Close swarmId
         */

        /**
         * Constructs a new Close.
         * @memberof SwarmThingMessage
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {SwarmThingMessage.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Close swarmId.
         * @member {Uint8Array} swarmId
         * @memberof SwarmThingMessage.Close
         * @instance
         */
        Close.prototype.swarmId = $util.newBuffer([]);

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose=} [properties] Properties to set
         * @returns {SwarmThingMessage.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link SwarmThingMessage.Close.verify|verify} messages.
         * @function encode
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swarmId != null && Object.hasOwnProperty.call(message, "swarmId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swarmId);
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link SwarmThingMessage.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SwarmThingMessage.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.swarmId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SwarmThingMessage.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                if (!(message.swarmId && typeof message.swarmId.length === "number" || $util.isString(message.swarmId)))
                    return "swarmId: buffer expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SwarmThingMessage.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.SwarmThingMessage.Close)
                return object;
            let message = new $root.SwarmThingMessage.Close();
            if (object.swarmId != null)
                if (typeof object.swarmId === "string")
                    $util.base64.decode(object.swarmId, message.swarmId = $util.newBuffer($util.base64.length(object.swarmId)), 0);
                else if (object.swarmId.length)
                    message.swarmId = object.swarmId;
            return message;
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.swarmId = "";
                else {
                    object.swarmId = [];
                    if (options.bytes !== Array)
                        object.swarmId = $util.newBuffer(object.swarmId);
                }
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                object.swarmId = options.bytes === String ? $util.base64.encode(message.swarmId, 0, message.swarmId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swarmId) : message.swarmId;
            return object;
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof SwarmThingMessage.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return SwarmThingMessage;
})();

export const BrokerPeerRequest = $root.BrokerPeerRequest = (() => {

    /**
     * Properties of a BrokerPeerRequest.
     * @exports IBrokerPeerRequest
     * @interface IBrokerPeerRequest
     * @property {number|null} [connMtu] BrokerPeerRequest connMtu
     */

    /**
     * Constructs a new BrokerPeerRequest.
     * @exports BrokerPeerRequest
     * @classdesc Represents a BrokerPeerRequest.
     * @implements IBrokerPeerRequest
     * @constructor
     * @param {IBrokerPeerRequest=} [properties] Properties to set
     */
    function BrokerPeerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerPeerRequest connMtu.
     * @member {number} connMtu
     * @memberof BrokerPeerRequest
     * @instance
     */
    BrokerPeerRequest.prototype.connMtu = 0;

    /**
     * Creates a new BrokerPeerRequest instance using the specified properties.
     * @function create
     * @memberof BrokerPeerRequest
     * @static
     * @param {IBrokerPeerRequest=} [properties] Properties to set
     * @returns {BrokerPeerRequest} BrokerPeerRequest instance
     */
    BrokerPeerRequest.create = function create(properties) {
        return new BrokerPeerRequest(properties);
    };

    /**
     * Encodes the specified BrokerPeerRequest message. Does not implicitly {@link BrokerPeerRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerPeerRequest
     * @static
     * @param {IBrokerPeerRequest} message BrokerPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connMtu != null && Object.hasOwnProperty.call(message, "connMtu"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.connMtu);
        return writer;
    };

    /**
     * Encodes the specified BrokerPeerRequest message, length delimited. Does not implicitly {@link BrokerPeerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerPeerRequest
     * @static
     * @param {IBrokerPeerRequest} message BrokerPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerPeerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerPeerRequest} BrokerPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.connMtu = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerPeerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerPeerRequest} BrokerPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerPeerRequest message.
     * @function verify
     * @memberof BrokerPeerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerPeerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connMtu != null && message.hasOwnProperty("connMtu"))
            if (!$util.isInteger(message.connMtu))
                return "connMtu: integer expected";
        return null;
    };

    /**
     * Creates a BrokerPeerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerPeerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerPeerRequest} BrokerPeerRequest
     */
    BrokerPeerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerPeerRequest)
            return object;
        let message = new $root.BrokerPeerRequest();
        if (object.connMtu != null)
            message.connMtu = object.connMtu | 0;
        return message;
    };

    /**
     * Creates a plain object from a BrokerPeerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerPeerRequest
     * @static
     * @param {BrokerPeerRequest} message BrokerPeerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerPeerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connMtu = 0;
        if (message.connMtu != null && message.hasOwnProperty("connMtu"))
            object.connMtu = message.connMtu;
        return object;
    };

    /**
     * Converts this BrokerPeerRequest to JSON.
     * @function toJSON
     * @memberof BrokerPeerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerPeerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerPeerRequest;
})();

export const BrokerPeerEvent = $root.BrokerPeerEvent = (() => {

    /**
     * Properties of a BrokerPeerEvent.
     * @exports IBrokerPeerEvent
     * @interface IBrokerPeerEvent
     * @property {BrokerPeerEvent.IOpen|null} [open] BrokerPeerEvent open
     * @property {BrokerPeerEvent.IData|null} [data] BrokerPeerEvent data
     * @property {BrokerPeerEvent.IInitRequired|null} [initRequired] BrokerPeerEvent initRequired
     * @property {BrokerPeerEvent.IKeys|null} [keys] BrokerPeerEvent keys
     */

    /**
     * Constructs a new BrokerPeerEvent.
     * @exports BrokerPeerEvent
     * @classdesc Represents a BrokerPeerEvent.
     * @implements IBrokerPeerEvent
     * @constructor
     * @param {IBrokerPeerEvent=} [properties] Properties to set
     */
    function BrokerPeerEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerPeerEvent open.
     * @member {BrokerPeerEvent.IOpen|null|undefined} open
     * @memberof BrokerPeerEvent
     * @instance
     */
    BrokerPeerEvent.prototype.open = null;

    /**
     * BrokerPeerEvent data.
     * @member {BrokerPeerEvent.IData|null|undefined} data
     * @memberof BrokerPeerEvent
     * @instance
     */
    BrokerPeerEvent.prototype.data = null;

    /**
     * BrokerPeerEvent initRequired.
     * @member {BrokerPeerEvent.IInitRequired|null|undefined} initRequired
     * @memberof BrokerPeerEvent
     * @instance
     */
    BrokerPeerEvent.prototype.initRequired = null;

    /**
     * BrokerPeerEvent keys.
     * @member {BrokerPeerEvent.IKeys|null|undefined} keys
     * @memberof BrokerPeerEvent
     * @instance
     */
    BrokerPeerEvent.prototype.keys = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BrokerPeerEvent body.
     * @member {"open"|"data"|"initRequired"|"keys"|undefined} body
     * @memberof BrokerPeerEvent
     * @instance
     */
    Object.defineProperty(BrokerPeerEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "data", "initRequired", "keys"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BrokerPeerEvent instance using the specified properties.
     * @function create
     * @memberof BrokerPeerEvent
     * @static
     * @param {IBrokerPeerEvent=} [properties] Properties to set
     * @returns {BrokerPeerEvent} BrokerPeerEvent instance
     */
    BrokerPeerEvent.create = function create(properties) {
        return new BrokerPeerEvent(properties);
    };

    /**
     * Encodes the specified BrokerPeerEvent message. Does not implicitly {@link BrokerPeerEvent.verify|verify} messages.
     * @function encode
     * @memberof BrokerPeerEvent
     * @static
     * @param {IBrokerPeerEvent} message BrokerPeerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.BrokerPeerEvent.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.BrokerPeerEvent.Data.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.initRequired != null && Object.hasOwnProperty.call(message, "initRequired"))
            $root.BrokerPeerEvent.InitRequired.encode(message.initRequired, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
            $root.BrokerPeerEvent.Keys.encode(message.keys, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BrokerPeerEvent message, length delimited. Does not implicitly {@link BrokerPeerEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerPeerEvent
     * @static
     * @param {IBrokerPeerEvent} message BrokerPeerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerPeerEvent message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerPeerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerPeerEvent} BrokerPeerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.BrokerPeerEvent.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.data = $root.BrokerPeerEvent.Data.decode(reader, reader.uint32());
                break;
            case 3:
                message.initRequired = $root.BrokerPeerEvent.InitRequired.decode(reader, reader.uint32());
                break;
            case 4:
                message.keys = $root.BrokerPeerEvent.Keys.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerPeerEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerPeerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerPeerEvent} BrokerPeerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerPeerEvent message.
     * @function verify
     * @memberof BrokerPeerEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerPeerEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.BrokerPeerEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BrokerPeerEvent.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.initRequired != null && message.hasOwnProperty("initRequired")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BrokerPeerEvent.InitRequired.verify(message.initRequired);
                if (error)
                    return "initRequired." + error;
            }
        }
        if (message.keys != null && message.hasOwnProperty("keys")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BrokerPeerEvent.Keys.verify(message.keys);
                if (error)
                    return "keys." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BrokerPeerEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerPeerEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerPeerEvent} BrokerPeerEvent
     */
    BrokerPeerEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerPeerEvent)
            return object;
        let message = new $root.BrokerPeerEvent();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".BrokerPeerEvent.open: object expected");
            message.open = $root.BrokerPeerEvent.Open.fromObject(object.open);
        }
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".BrokerPeerEvent.data: object expected");
            message.data = $root.BrokerPeerEvent.Data.fromObject(object.data);
        }
        if (object.initRequired != null) {
            if (typeof object.initRequired !== "object")
                throw TypeError(".BrokerPeerEvent.initRequired: object expected");
            message.initRequired = $root.BrokerPeerEvent.InitRequired.fromObject(object.initRequired);
        }
        if (object.keys != null) {
            if (typeof object.keys !== "object")
                throw TypeError(".BrokerPeerEvent.keys: object expected");
            message.keys = $root.BrokerPeerEvent.Keys.fromObject(object.keys);
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerPeerEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerPeerEvent
     * @static
     * @param {BrokerPeerEvent} message BrokerPeerEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerPeerEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.BrokerPeerEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.BrokerPeerEvent.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.initRequired != null && message.hasOwnProperty("initRequired")) {
            object.initRequired = $root.BrokerPeerEvent.InitRequired.toObject(message.initRequired, options);
            if (options.oneofs)
                object.body = "initRequired";
        }
        if (message.keys != null && message.hasOwnProperty("keys")) {
            object.keys = $root.BrokerPeerEvent.Keys.toObject(message.keys, options);
            if (options.oneofs)
                object.body = "keys";
        }
        return object;
    };

    /**
     * Converts this BrokerPeerEvent to JSON.
     * @function toJSON
     * @memberof BrokerPeerEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerPeerEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    BrokerPeerEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof BrokerPeerEvent
         * @interface IOpen
         * @property {number|null} [peerId] Open peerId
         */

        /**
         * Constructs a new Open.
         * @memberof BrokerPeerEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {BrokerPeerEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open peerId.
         * @member {number} peerId
         * @memberof BrokerPeerEvent.Open
         * @instance
         */
        Open.prototype.peerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {BrokerPeerEvent.IOpen=} [properties] Properties to set
         * @returns {BrokerPeerEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link BrokerPeerEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {BrokerPeerEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.peerId);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link BrokerPeerEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {BrokerPeerEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerPeerEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.peerId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerPeerEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (!$util.isInteger(message.peerId) && !(message.peerId && $util.isInteger(message.peerId.low) && $util.isInteger(message.peerId.high)))
                    return "peerId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerPeerEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerPeerEvent.Open)
                return object;
            let message = new $root.BrokerPeerEvent.Open();
            if (object.peerId != null)
                if ($util.Long)
                    (message.peerId = $util.Long.fromValue(object.peerId)).unsigned = true;
                else if (typeof object.peerId === "string")
                    message.peerId = parseInt(object.peerId, 10);
                else if (typeof object.peerId === "number")
                    message.peerId = object.peerId;
                else if (typeof object.peerId === "object")
                    message.peerId = new $util.LongBits(object.peerId.low >>> 0, object.peerId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerPeerEvent.Open
         * @static
         * @param {BrokerPeerEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.peerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerId = options.longs === String ? "0" : 0;
            if (message.peerId != null && message.hasOwnProperty("peerId"))
                if (typeof message.peerId === "number")
                    object.peerId = options.longs === String ? String(message.peerId) : message.peerId;
                else
                    object.peerId = options.longs === String ? $util.Long.prototype.toString.call(message.peerId) : options.longs === Number ? new $util.LongBits(message.peerId.low >>> 0, message.peerId.high >>> 0).toNumber(true) : message.peerId;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof BrokerPeerEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    BrokerPeerEvent.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof BrokerPeerEvent
         * @interface IData
         * @property {Uint8Array|null} [data] Data data
         */

        /**
         * Constructs a new Data.
         * @memberof BrokerPeerEvent
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {BrokerPeerEvent.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data data.
         * @member {Uint8Array} data
         * @memberof BrokerPeerEvent.Data
         * @instance
         */
        Data.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {BrokerPeerEvent.IData=} [properties] Properties to set
         * @returns {BrokerPeerEvent.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link BrokerPeerEvent.Data.verify|verify} messages.
         * @function encode
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {BrokerPeerEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link BrokerPeerEvent.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {BrokerPeerEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerPeerEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerEvent.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerPeerEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerPeerEvent.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerPeerEvent.Data)
                return object;
            let message = new $root.BrokerPeerEvent.Data();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerPeerEvent.Data
         * @static
         * @param {BrokerPeerEvent.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof BrokerPeerEvent.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    BrokerPeerEvent.InitRequired = (function() {

        /**
         * Properties of an InitRequired.
         * @memberof BrokerPeerEvent
         * @interface IInitRequired
         * @property {Uint8Array|null} [data] InitRequired data
         */

        /**
         * Constructs a new InitRequired.
         * @memberof BrokerPeerEvent
         * @classdesc Represents an InitRequired.
         * @implements IInitRequired
         * @constructor
         * @param {BrokerPeerEvent.IInitRequired=} [properties] Properties to set
         */
        function InitRequired(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitRequired data.
         * @member {Uint8Array} data
         * @memberof BrokerPeerEvent.InitRequired
         * @instance
         */
        InitRequired.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new InitRequired instance using the specified properties.
         * @function create
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {BrokerPeerEvent.IInitRequired=} [properties] Properties to set
         * @returns {BrokerPeerEvent.InitRequired} InitRequired instance
         */
        InitRequired.create = function create(properties) {
            return new InitRequired(properties);
        };

        /**
         * Encodes the specified InitRequired message. Does not implicitly {@link BrokerPeerEvent.InitRequired.verify|verify} messages.
         * @function encode
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {BrokerPeerEvent.IInitRequired} message InitRequired message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitRequired.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified InitRequired message, length delimited. Does not implicitly {@link BrokerPeerEvent.InitRequired.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {BrokerPeerEvent.IInitRequired} message InitRequired message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitRequired.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitRequired message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerPeerEvent.InitRequired} InitRequired
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitRequired.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerEvent.InitRequired();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitRequired message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerPeerEvent.InitRequired} InitRequired
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitRequired.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitRequired message.
         * @function verify
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitRequired.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an InitRequired message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerPeerEvent.InitRequired} InitRequired
         */
        InitRequired.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerPeerEvent.InitRequired)
                return object;
            let message = new $root.BrokerPeerEvent.InitRequired();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an InitRequired message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerPeerEvent.InitRequired
         * @static
         * @param {BrokerPeerEvent.InitRequired} message InitRequired
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitRequired.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this InitRequired to JSON.
         * @function toJSON
         * @memberof BrokerPeerEvent.InitRequired
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitRequired.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitRequired;
    })();

    BrokerPeerEvent.Keys = (function() {

        /**
         * Properties of a Keys.
         * @memberof BrokerPeerEvent
         * @interface IKeys
         * @property {Array.<Uint8Array>|null} [keys] Keys keys
         */

        /**
         * Constructs a new Keys.
         * @memberof BrokerPeerEvent
         * @classdesc Represents a Keys.
         * @implements IKeys
         * @constructor
         * @param {BrokerPeerEvent.IKeys=} [properties] Properties to set
         */
        function Keys(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Keys keys.
         * @member {Array.<Uint8Array>} keys
         * @memberof BrokerPeerEvent.Keys
         * @instance
         */
        Keys.prototype.keys = $util.emptyArray;

        /**
         * Creates a new Keys instance using the specified properties.
         * @function create
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {BrokerPeerEvent.IKeys=} [properties] Properties to set
         * @returns {BrokerPeerEvent.Keys} Keys instance
         */
        Keys.create = function create(properties) {
            return new Keys(properties);
        };

        /**
         * Encodes the specified Keys message. Does not implicitly {@link BrokerPeerEvent.Keys.verify|verify} messages.
         * @function encode
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {BrokerPeerEvent.IKeys} message Keys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (let i = 0; i < message.keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys[i]);
            return writer;
        };

        /**
         * Encodes the specified Keys message, length delimited. Does not implicitly {@link BrokerPeerEvent.Keys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {BrokerPeerEvent.IKeys} message Keys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Keys message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerPeerEvent.Keys} Keys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerEvent.Keys();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Keys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerPeerEvent.Keys} Keys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Keys message.
         * @function verify
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Keys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (let i = 0; i < message.keys.length; ++i)
                    if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                        return "keys: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a Keys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerPeerEvent.Keys} Keys
         */
        Keys.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerPeerEvent.Keys)
                return object;
            let message = new $root.BrokerPeerEvent.Keys();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".BrokerPeerEvent.Keys.keys: array expected");
                message.keys = [];
                for (let i = 0; i < object.keys.length; ++i)
                    if (typeof object.keys[i] === "string")
                        $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                    else if (object.keys[i].length)
                        message.keys[i] = object.keys[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a Keys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerPeerEvent.Keys
         * @static
         * @param {BrokerPeerEvent.Keys} message Keys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Keys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (let j = 0; j < message.keys.length; ++j)
                    object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
            }
            return object;
        };

        /**
         * Converts this Keys to JSON.
         * @function toJSON
         * @memberof BrokerPeerEvent.Keys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Keys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Keys;
    })();

    return BrokerPeerEvent;
})();

export const BrokerPeerInitRequest = $root.BrokerPeerInitRequest = (() => {

    /**
     * Properties of a BrokerPeerInitRequest.
     * @exports IBrokerPeerInitRequest
     * @interface IBrokerPeerInitRequest
     * @property {number|null} [peerId] BrokerPeerInitRequest peerId
     * @property {number|null} [discriminator] BrokerPeerInitRequest discriminator
     * @property {Array.<Uint8Array>|null} [keys] BrokerPeerInitRequest keys
     */

    /**
     * Constructs a new BrokerPeerInitRequest.
     * @exports BrokerPeerInitRequest
     * @classdesc Represents a BrokerPeerInitRequest.
     * @implements IBrokerPeerInitRequest
     * @constructor
     * @param {IBrokerPeerInitRequest=} [properties] Properties to set
     */
    function BrokerPeerInitRequest(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerPeerInitRequest peerId.
     * @member {number} peerId
     * @memberof BrokerPeerInitRequest
     * @instance
     */
    BrokerPeerInitRequest.prototype.peerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BrokerPeerInitRequest discriminator.
     * @member {number} discriminator
     * @memberof BrokerPeerInitRequest
     * @instance
     */
    BrokerPeerInitRequest.prototype.discriminator = 0;

    /**
     * BrokerPeerInitRequest keys.
     * @member {Array.<Uint8Array>} keys
     * @memberof BrokerPeerInitRequest
     * @instance
     */
    BrokerPeerInitRequest.prototype.keys = $util.emptyArray;

    /**
     * Creates a new BrokerPeerInitRequest instance using the specified properties.
     * @function create
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {IBrokerPeerInitRequest=} [properties] Properties to set
     * @returns {BrokerPeerInitRequest} BrokerPeerInitRequest instance
     */
    BrokerPeerInitRequest.create = function create(properties) {
        return new BrokerPeerInitRequest(properties);
    };

    /**
     * Encodes the specified BrokerPeerInitRequest message. Does not implicitly {@link BrokerPeerInitRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {IBrokerPeerInitRequest} message BrokerPeerInitRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerInitRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.peerId);
        if (message.discriminator != null && Object.hasOwnProperty.call(message, "discriminator"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.discriminator);
        if (message.keys != null && message.keys.length)
            for (let i = 0; i < message.keys.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.keys[i]);
        return writer;
    };

    /**
     * Encodes the specified BrokerPeerInitRequest message, length delimited. Does not implicitly {@link BrokerPeerInitRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {IBrokerPeerInitRequest} message BrokerPeerInitRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerInitRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerPeerInitRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerPeerInitRequest} BrokerPeerInitRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerInitRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerInitRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.peerId = reader.uint64();
                break;
            case 2:
                message.discriminator = reader.uint32();
                break;
            case 3:
                if (!(message.keys && message.keys.length))
                    message.keys = [];
                message.keys.push(reader.bytes());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerPeerInitRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerPeerInitRequest} BrokerPeerInitRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerInitRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerPeerInitRequest message.
     * @function verify
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerPeerInitRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (!$util.isInteger(message.peerId) && !(message.peerId && $util.isInteger(message.peerId.low) && $util.isInteger(message.peerId.high)))
                return "peerId: integer|Long expected";
        if (message.discriminator != null && message.hasOwnProperty("discriminator"))
            if (!$util.isInteger(message.discriminator))
                return "discriminator: integer expected";
        if (message.keys != null && message.hasOwnProperty("keys")) {
            if (!Array.isArray(message.keys))
                return "keys: array expected";
            for (let i = 0; i < message.keys.length; ++i)
                if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                    return "keys: buffer[] expected";
        }
        return null;
    };

    /**
     * Creates a BrokerPeerInitRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerPeerInitRequest} BrokerPeerInitRequest
     */
    BrokerPeerInitRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerPeerInitRequest)
            return object;
        let message = new $root.BrokerPeerInitRequest();
        if (object.peerId != null)
            if ($util.Long)
                (message.peerId = $util.Long.fromValue(object.peerId)).unsigned = true;
            else if (typeof object.peerId === "string")
                message.peerId = parseInt(object.peerId, 10);
            else if (typeof object.peerId === "number")
                message.peerId = object.peerId;
            else if (typeof object.peerId === "object")
                message.peerId = new $util.LongBits(object.peerId.low >>> 0, object.peerId.high >>> 0).toNumber(true);
        if (object.discriminator != null)
            message.discriminator = object.discriminator >>> 0;
        if (object.keys) {
            if (!Array.isArray(object.keys))
                throw TypeError(".BrokerPeerInitRequest.keys: array expected");
            message.keys = [];
            for (let i = 0; i < object.keys.length; ++i)
                if (typeof object.keys[i] === "string")
                    $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                else if (object.keys[i].length)
                    message.keys[i] = object.keys[i];
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerPeerInitRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerPeerInitRequest
     * @static
     * @param {BrokerPeerInitRequest} message BrokerPeerInitRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerPeerInitRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.keys = [];
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.peerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.peerId = options.longs === String ? "0" : 0;
            object.discriminator = 0;
        }
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (typeof message.peerId === "number")
                object.peerId = options.longs === String ? String(message.peerId) : message.peerId;
            else
                object.peerId = options.longs === String ? $util.Long.prototype.toString.call(message.peerId) : options.longs === Number ? new $util.LongBits(message.peerId.low >>> 0, message.peerId.high >>> 0).toNumber(true) : message.peerId;
        if (message.discriminator != null && message.hasOwnProperty("discriminator"))
            object.discriminator = message.discriminator;
        if (message.keys && message.keys.length) {
            object.keys = [];
            for (let j = 0; j < message.keys.length; ++j)
                object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
        }
        return object;
    };

    /**
     * Converts this BrokerPeerInitRequest to JSON.
     * @function toJSON
     * @memberof BrokerPeerInitRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerPeerInitRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerPeerInitRequest;
})();

export const BrokerPeerDataRequest = $root.BrokerPeerDataRequest = (() => {

    /**
     * Properties of a BrokerPeerDataRequest.
     * @exports IBrokerPeerDataRequest
     * @interface IBrokerPeerDataRequest
     * @property {number|null} [peerId] BrokerPeerDataRequest peerId
     * @property {Uint8Array|null} [data] BrokerPeerDataRequest data
     */

    /**
     * Constructs a new BrokerPeerDataRequest.
     * @exports BrokerPeerDataRequest
     * @classdesc Represents a BrokerPeerDataRequest.
     * @implements IBrokerPeerDataRequest
     * @constructor
     * @param {IBrokerPeerDataRequest=} [properties] Properties to set
     */
    function BrokerPeerDataRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerPeerDataRequest peerId.
     * @member {number} peerId
     * @memberof BrokerPeerDataRequest
     * @instance
     */
    BrokerPeerDataRequest.prototype.peerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BrokerPeerDataRequest data.
     * @member {Uint8Array} data
     * @memberof BrokerPeerDataRequest
     * @instance
     */
    BrokerPeerDataRequest.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new BrokerPeerDataRequest instance using the specified properties.
     * @function create
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {IBrokerPeerDataRequest=} [properties] Properties to set
     * @returns {BrokerPeerDataRequest} BrokerPeerDataRequest instance
     */
    BrokerPeerDataRequest.create = function create(properties) {
        return new BrokerPeerDataRequest(properties);
    };

    /**
     * Encodes the specified BrokerPeerDataRequest message. Does not implicitly {@link BrokerPeerDataRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {IBrokerPeerDataRequest} message BrokerPeerDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerDataRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.peerId);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified BrokerPeerDataRequest message, length delimited. Does not implicitly {@link BrokerPeerDataRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {IBrokerPeerDataRequest} message BrokerPeerDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerPeerDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerPeerDataRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerPeerDataRequest} BrokerPeerDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerDataRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerPeerDataRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.peerId = reader.uint64();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerPeerDataRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerPeerDataRequest} BrokerPeerDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerPeerDataRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerPeerDataRequest message.
     * @function verify
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerPeerDataRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (!$util.isInteger(message.peerId) && !(message.peerId && $util.isInteger(message.peerId.low) && $util.isInteger(message.peerId.high)))
                return "peerId: integer|Long expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a BrokerPeerDataRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerPeerDataRequest} BrokerPeerDataRequest
     */
    BrokerPeerDataRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerPeerDataRequest)
            return object;
        let message = new $root.BrokerPeerDataRequest();
        if (object.peerId != null)
            if ($util.Long)
                (message.peerId = $util.Long.fromValue(object.peerId)).unsigned = true;
            else if (typeof object.peerId === "string")
                message.peerId = parseInt(object.peerId, 10);
            else if (typeof object.peerId === "number")
                message.peerId = object.peerId;
            else if (typeof object.peerId === "object")
                message.peerId = new $util.LongBits(object.peerId.low >>> 0, object.peerId.high >>> 0).toNumber(true);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a BrokerPeerDataRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerPeerDataRequest
     * @static
     * @param {BrokerPeerDataRequest} message BrokerPeerDataRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerPeerDataRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.peerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.peerId = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.peerId != null && message.hasOwnProperty("peerId"))
            if (typeof message.peerId === "number")
                object.peerId = options.longs === String ? String(message.peerId) : message.peerId;
            else
                object.peerId = options.longs === String ? $util.Long.prototype.toString.call(message.peerId) : options.longs === Number ? new $util.LongBits(message.peerId.low >>> 0, message.peerId.high >>> 0).toNumber(true) : message.peerId;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this BrokerPeerDataRequest to JSON.
     * @function toJSON
     * @memberof BrokerPeerDataRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerPeerDataRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerPeerDataRequest;
})();

export const ReadMetricsRequest = $root.ReadMetricsRequest = (() => {

    /**
     * Properties of a ReadMetricsRequest.
     * @exports IReadMetricsRequest
     * @interface IReadMetricsRequest
     * @property {MetricsFormat|null} [format] ReadMetricsRequest format
     */

    /**
     * Constructs a new ReadMetricsRequest.
     * @exports ReadMetricsRequest
     * @classdesc Represents a ReadMetricsRequest.
     * @implements IReadMetricsRequest
     * @constructor
     * @param {IReadMetricsRequest=} [properties] Properties to set
     */
    function ReadMetricsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReadMetricsRequest format.
     * @member {MetricsFormat} format
     * @memberof ReadMetricsRequest
     * @instance
     */
    ReadMetricsRequest.prototype.format = 0;

    /**
     * Creates a new ReadMetricsRequest instance using the specified properties.
     * @function create
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest=} [properties] Properties to set
     * @returns {ReadMetricsRequest} ReadMetricsRequest instance
     */
    ReadMetricsRequest.create = function create(properties) {
        return new ReadMetricsRequest(properties);
    };

    /**
     * Encodes the specified ReadMetricsRequest message. Does not implicitly {@link ReadMetricsRequest.verify|verify} messages.
     * @function encode
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest} message ReadMetricsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.format != null && Object.hasOwnProperty.call(message, "format"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.format);
        return writer;
    };

    /**
     * Encodes the specified ReadMetricsRequest message, length delimited. Does not implicitly {@link ReadMetricsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest} message ReadMetricsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReadMetricsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ReadMetricsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReadMetricsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.format = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReadMetricsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReadMetricsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReadMetricsRequest message.
     * @function verify
     * @memberof ReadMetricsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReadMetricsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.format != null && message.hasOwnProperty("format"))
            switch (message.format) {
            default:
                return "format: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        return null;
    };

    /**
     * Creates a ReadMetricsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReadMetricsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     */
    ReadMetricsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ReadMetricsRequest)
            return object;
        let message = new $root.ReadMetricsRequest();
        switch (object.format) {
        case "METRICS_FORMAT_TEXT":
        case 0:
            message.format = 0;
            break;
        case "METRICS_FORMAT_PROTO_DELIM":
        case 1:
            message.format = 1;
            break;
        case "METRICS_FORMAT_PROTO_TEXT":
        case 2:
            message.format = 2;
            break;
        case "METRICS_FORMAT_PROTO_COMPACT":
        case 3:
            message.format = 3;
            break;
        case "METRICS_FORMAT_OPEN_METRICS":
        case 4:
            message.format = 4;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ReadMetricsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReadMetricsRequest
     * @static
     * @param {ReadMetricsRequest} message ReadMetricsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReadMetricsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.format = options.enums === String ? "METRICS_FORMAT_TEXT" : 0;
        if (message.format != null && message.hasOwnProperty("format"))
            object.format = options.enums === String ? $root.MetricsFormat[message.format] : message.format;
        return object;
    };

    /**
     * Converts this ReadMetricsRequest to JSON.
     * @function toJSON
     * @memberof ReadMetricsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReadMetricsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReadMetricsRequest;
})();

export const ReadMetricsResponse = $root.ReadMetricsResponse = (() => {

    /**
     * Properties of a ReadMetricsResponse.
     * @exports IReadMetricsResponse
     * @interface IReadMetricsResponse
     * @property {Uint8Array|null} [data] ReadMetricsResponse data
     */

    /**
     * Constructs a new ReadMetricsResponse.
     * @exports ReadMetricsResponse
     * @classdesc Represents a ReadMetricsResponse.
     * @implements IReadMetricsResponse
     * @constructor
     * @param {IReadMetricsResponse=} [properties] Properties to set
     */
    function ReadMetricsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReadMetricsResponse data.
     * @member {Uint8Array} data
     * @memberof ReadMetricsResponse
     * @instance
     */
    ReadMetricsResponse.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new ReadMetricsResponse instance using the specified properties.
     * @function create
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse=} [properties] Properties to set
     * @returns {ReadMetricsResponse} ReadMetricsResponse instance
     */
    ReadMetricsResponse.create = function create(properties) {
        return new ReadMetricsResponse(properties);
    };

    /**
     * Encodes the specified ReadMetricsResponse message. Does not implicitly {@link ReadMetricsResponse.verify|verify} messages.
     * @function encode
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse} message ReadMetricsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified ReadMetricsResponse message, length delimited. Does not implicitly {@link ReadMetricsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse} message ReadMetricsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReadMetricsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ReadMetricsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReadMetricsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReadMetricsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReadMetricsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReadMetricsResponse message.
     * @function verify
     * @memberof ReadMetricsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReadMetricsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a ReadMetricsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReadMetricsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     */
    ReadMetricsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ReadMetricsResponse)
            return object;
        let message = new $root.ReadMetricsResponse();
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a ReadMetricsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReadMetricsResponse
     * @static
     * @param {ReadMetricsResponse} message ReadMetricsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReadMetricsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this ReadMetricsResponse to JSON.
     * @function toJSON
     * @memberof ReadMetricsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReadMetricsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReadMetricsResponse;
})();

export const CreateNetworkInvitationRequest = $root.CreateNetworkInvitationRequest = (() => {

    /**
     * Properties of a CreateNetworkInvitationRequest.
     * @exports ICreateNetworkInvitationRequest
     * @interface ICreateNetworkInvitationRequest
     * @property {IKey|null} [signingKey] CreateNetworkInvitationRequest signingKey
     * @property {ICertificate|null} [signingCert] CreateNetworkInvitationRequest signingCert
     * @property {string|null} [networkName] CreateNetworkInvitationRequest networkName
     */

    /**
     * Constructs a new CreateNetworkInvitationRequest.
     * @exports CreateNetworkInvitationRequest
     * @classdesc Represents a CreateNetworkInvitationRequest.
     * @implements ICreateNetworkInvitationRequest
     * @constructor
     * @param {ICreateNetworkInvitationRequest=} [properties] Properties to set
     */
    function CreateNetworkInvitationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkInvitationRequest signingKey.
     * @member {IKey|null|undefined} signingKey
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.signingKey = null;

    /**
     * CreateNetworkInvitationRequest signingCert.
     * @member {ICertificate|null|undefined} signingCert
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.signingCert = null;

    /**
     * CreateNetworkInvitationRequest networkName.
     * @member {string} networkName
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.networkName = "";

    /**
     * Creates a new CreateNetworkInvitationRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest=} [properties] Properties to set
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest instance
     */
    CreateNetworkInvitationRequest.create = function create(properties) {
        return new CreateNetworkInvitationRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkInvitationRequest message. Does not implicitly {@link CreateNetworkInvitationRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest} message CreateNetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.signingKey != null && Object.hasOwnProperty.call(message, "signingKey"))
            $root.Key.encode(message.signingKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.signingCert != null && Object.hasOwnProperty.call(message, "signingCert"))
            $root.Certificate.encode(message.signingCert, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.networkName != null && Object.hasOwnProperty.call(message, "networkName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.networkName);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkInvitationRequest message, length delimited. Does not implicitly {@link CreateNetworkInvitationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest} message CreateNetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkInvitationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkInvitationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.signingKey = $root.Key.decode(reader, reader.uint32());
                break;
            case 2:
                message.signingCert = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 3:
                message.networkName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkInvitationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkInvitationRequest message.
     * @function verify
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkInvitationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.signingKey != null && message.hasOwnProperty("signingKey")) {
            let error = $root.Key.verify(message.signingKey);
            if (error)
                return "signingKey." + error;
        }
        if (message.signingCert != null && message.hasOwnProperty("signingCert")) {
            let error = $root.Certificate.verify(message.signingCert);
            if (error)
                return "signingCert." + error;
        }
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            if (!$util.isString(message.networkName))
                return "networkName: string expected";
        return null;
    };

    /**
     * Creates a CreateNetworkInvitationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     */
    CreateNetworkInvitationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkInvitationRequest)
            return object;
        let message = new $root.CreateNetworkInvitationRequest();
        if (object.signingKey != null) {
            if (typeof object.signingKey !== "object")
                throw TypeError(".CreateNetworkInvitationRequest.signingKey: object expected");
            message.signingKey = $root.Key.fromObject(object.signingKey);
        }
        if (object.signingCert != null) {
            if (typeof object.signingCert !== "object")
                throw TypeError(".CreateNetworkInvitationRequest.signingCert: object expected");
            message.signingCert = $root.Certificate.fromObject(object.signingCert);
        }
        if (object.networkName != null)
            message.networkName = String(object.networkName);
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkInvitationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {CreateNetworkInvitationRequest} message CreateNetworkInvitationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkInvitationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.signingKey = null;
            object.signingCert = null;
            object.networkName = "";
        }
        if (message.signingKey != null && message.hasOwnProperty("signingKey"))
            object.signingKey = $root.Key.toObject(message.signingKey, options);
        if (message.signingCert != null && message.hasOwnProperty("signingCert"))
            object.signingCert = $root.Certificate.toObject(message.signingCert, options);
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            object.networkName = message.networkName;
        return object;
    };

    /**
     * Converts this CreateNetworkInvitationRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkInvitationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkInvitationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkInvitationRequest;
})();

export const CreateNetworkInvitationResponse = $root.CreateNetworkInvitationResponse = (() => {

    /**
     * Properties of a CreateNetworkInvitationResponse.
     * @exports ICreateNetworkInvitationResponse
     * @interface ICreateNetworkInvitationResponse
     * @property {IInvitation|null} [invitation] CreateNetworkInvitationResponse invitation
     * @property {string|null} [invitationB64] CreateNetworkInvitationResponse invitationB64
     * @property {Uint8Array|null} [invitationBytes] CreateNetworkInvitationResponse invitationBytes
     */

    /**
     * Constructs a new CreateNetworkInvitationResponse.
     * @exports CreateNetworkInvitationResponse
     * @classdesc Represents a CreateNetworkInvitationResponse.
     * @implements ICreateNetworkInvitationResponse
     * @constructor
     * @param {ICreateNetworkInvitationResponse=} [properties] Properties to set
     */
    function CreateNetworkInvitationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkInvitationResponse invitation.
     * @member {IInvitation|null|undefined} invitation
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitation = null;

    /**
     * CreateNetworkInvitationResponse invitationB64.
     * @member {string} invitationB64
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitationB64 = "";

    /**
     * CreateNetworkInvitationResponse invitationBytes.
     * @member {Uint8Array} invitationBytes
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitationBytes = $util.newBuffer([]);

    /**
     * Creates a new CreateNetworkInvitationResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse=} [properties] Properties to set
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse instance
     */
    CreateNetworkInvitationResponse.create = function create(properties) {
        return new CreateNetworkInvitationResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkInvitationResponse message. Does not implicitly {@link CreateNetworkInvitationResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse} message CreateNetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.invitation != null && Object.hasOwnProperty.call(message, "invitation"))
            $root.Invitation.encode(message.invitation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.invitationB64 != null && Object.hasOwnProperty.call(message, "invitationB64"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.invitationB64);
        if (message.invitationBytes != null && Object.hasOwnProperty.call(message, "invitationBytes"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.invitationBytes);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkInvitationResponse message, length delimited. Does not implicitly {@link CreateNetworkInvitationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse} message CreateNetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkInvitationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkInvitationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.invitation = $root.Invitation.decode(reader, reader.uint32());
                break;
            case 2:
                message.invitationB64 = reader.string();
                break;
            case 3:
                message.invitationBytes = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkInvitationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkInvitationResponse message.
     * @function verify
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkInvitationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.invitation != null && message.hasOwnProperty("invitation")) {
            let error = $root.Invitation.verify(message.invitation);
            if (error)
                return "invitation." + error;
        }
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64"))
            if (!$util.isString(message.invitationB64))
                return "invitationB64: string expected";
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes"))
            if (!(message.invitationBytes && typeof message.invitationBytes.length === "number" || $util.isString(message.invitationBytes)))
                return "invitationBytes: buffer expected";
        return null;
    };

    /**
     * Creates a CreateNetworkInvitationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     */
    CreateNetworkInvitationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkInvitationResponse)
            return object;
        let message = new $root.CreateNetworkInvitationResponse();
        if (object.invitation != null) {
            if (typeof object.invitation !== "object")
                throw TypeError(".CreateNetworkInvitationResponse.invitation: object expected");
            message.invitation = $root.Invitation.fromObject(object.invitation);
        }
        if (object.invitationB64 != null)
            message.invitationB64 = String(object.invitationB64);
        if (object.invitationBytes != null)
            if (typeof object.invitationBytes === "string")
                $util.base64.decode(object.invitationBytes, message.invitationBytes = $util.newBuffer($util.base64.length(object.invitationBytes)), 0);
            else if (object.invitationBytes.length)
                message.invitationBytes = object.invitationBytes;
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkInvitationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {CreateNetworkInvitationResponse} message CreateNetworkInvitationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkInvitationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.invitation = null;
            object.invitationB64 = "";
            if (options.bytes === String)
                object.invitationBytes = "";
            else {
                object.invitationBytes = [];
                if (options.bytes !== Array)
                    object.invitationBytes = $util.newBuffer(object.invitationBytes);
            }
        }
        if (message.invitation != null && message.hasOwnProperty("invitation"))
            object.invitation = $root.Invitation.toObject(message.invitation, options);
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64"))
            object.invitationB64 = message.invitationB64;
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes"))
            object.invitationBytes = options.bytes === String ? $util.base64.encode(message.invitationBytes, 0, message.invitationBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.invitationBytes) : message.invitationBytes;
        return object;
    };

    /**
     * Converts this CreateNetworkInvitationResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkInvitationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkInvitationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkInvitationResponse;
})();

export const Invitation = $root.Invitation = (() => {

    /**
     * Properties of an Invitation.
     * @exports IInvitation
     * @interface IInvitation
     * @property {number|null} [version] Invitation version
     * @property {Uint8Array|null} [data] Invitation data
     */

    /**
     * Constructs a new Invitation.
     * @exports Invitation
     * @classdesc Represents an Invitation.
     * @implements IInvitation
     * @constructor
     * @param {IInvitation=} [properties] Properties to set
     */
    function Invitation(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Invitation version.
     * @member {number} version
     * @memberof Invitation
     * @instance
     */
    Invitation.prototype.version = 0;

    /**
     * Invitation data.
     * @member {Uint8Array} data
     * @memberof Invitation
     * @instance
     */
    Invitation.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new Invitation instance using the specified properties.
     * @function create
     * @memberof Invitation
     * @static
     * @param {IInvitation=} [properties] Properties to set
     * @returns {Invitation} Invitation instance
     */
    Invitation.create = function create(properties) {
        return new Invitation(properties);
    };

    /**
     * Encodes the specified Invitation message. Does not implicitly {@link Invitation.verify|verify} messages.
     * @function encode
     * @memberof Invitation
     * @static
     * @param {IInvitation} message Invitation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Invitation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified Invitation message, length delimited. Does not implicitly {@link Invitation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Invitation
     * @static
     * @param {IInvitation} message Invitation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Invitation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Invitation message from the specified reader or buffer.
     * @function decode
     * @memberof Invitation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Invitation} Invitation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Invitation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Invitation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.version = reader.uint32();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Invitation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Invitation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Invitation} Invitation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Invitation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Invitation message.
     * @function verify
     * @memberof Invitation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Invitation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates an Invitation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Invitation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Invitation} Invitation
     */
    Invitation.fromObject = function fromObject(object) {
        if (object instanceof $root.Invitation)
            return object;
        let message = new $root.Invitation();
        if (object.version != null)
            message.version = object.version >>> 0;
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from an Invitation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Invitation
     * @static
     * @param {Invitation} message Invitation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Invitation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.version = 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this Invitation to JSON.
     * @function toJSON
     * @memberof Invitation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Invitation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Invitation;
})();

export const InvitationV0 = $root.InvitationV0 = (() => {

    /**
     * Properties of an InvitationV0.
     * @exports IInvitationV0
     * @interface IInvitationV0
     * @property {IKey|null} [key] InvitationV0 key
     * @property {ICertificate|null} [certificate] InvitationV0 certificate
     * @property {string|null} [networkName] InvitationV0 networkName
     */

    /**
     * Constructs a new InvitationV0.
     * @exports InvitationV0
     * @classdesc Represents an InvitationV0.
     * @implements IInvitationV0
     * @constructor
     * @param {IInvitationV0=} [properties] Properties to set
     */
    function InvitationV0(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InvitationV0 key.
     * @member {IKey|null|undefined} key
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.key = null;

    /**
     * InvitationV0 certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.certificate = null;

    /**
     * InvitationV0 networkName.
     * @member {string} networkName
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.networkName = "";

    /**
     * Creates a new InvitationV0 instance using the specified properties.
     * @function create
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0=} [properties] Properties to set
     * @returns {InvitationV0} InvitationV0 instance
     */
    InvitationV0.create = function create(properties) {
        return new InvitationV0(properties);
    };

    /**
     * Encodes the specified InvitationV0 message. Does not implicitly {@link InvitationV0.verify|verify} messages.
     * @function encode
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0} message InvitationV0 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InvitationV0.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.networkName != null && Object.hasOwnProperty.call(message, "networkName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkName);
        return writer;
    };

    /**
     * Encodes the specified InvitationV0 message, length delimited. Does not implicitly {@link InvitationV0.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0} message InvitationV0 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InvitationV0.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InvitationV0 message from the specified reader or buffer.
     * @function decode
     * @memberof InvitationV0
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InvitationV0} InvitationV0
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InvitationV0.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.InvitationV0();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 2:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 4:
                message.networkName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InvitationV0 message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InvitationV0
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InvitationV0} InvitationV0
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InvitationV0.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InvitationV0 message.
     * @function verify
     * @memberof InvitationV0
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InvitationV0.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            if (!$util.isString(message.networkName))
                return "networkName: string expected";
        return null;
    };

    /**
     * Creates an InvitationV0 message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InvitationV0
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InvitationV0} InvitationV0
     */
    InvitationV0.fromObject = function fromObject(object) {
        if (object instanceof $root.InvitationV0)
            return object;
        let message = new $root.InvitationV0();
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".InvitationV0.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".InvitationV0.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.networkName != null)
            message.networkName = String(object.networkName);
        return message;
    };

    /**
     * Creates a plain object from an InvitationV0 message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InvitationV0
     * @static
     * @param {InvitationV0} message InvitationV0
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InvitationV0.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.key = null;
            object.certificate = null;
            object.networkName = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            object.networkName = message.networkName;
        return object;
    };

    /**
     * Converts this InvitationV0 to JSON.
     * @function toJSON
     * @memberof InvitationV0
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InvitationV0.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InvitationV0;
})();

export const CreateNetworkMembershipFromInvitationRequest = $root.CreateNetworkMembershipFromInvitationRequest = (() => {

    /**
     * Properties of a CreateNetworkMembershipFromInvitationRequest.
     * @exports ICreateNetworkMembershipFromInvitationRequest
     * @interface ICreateNetworkMembershipFromInvitationRequest
     * @property {string|null} [invitationB64] CreateNetworkMembershipFromInvitationRequest invitationB64
     * @property {Uint8Array|null} [invitationBytes] CreateNetworkMembershipFromInvitationRequest invitationBytes
     */

    /**
     * Constructs a new CreateNetworkMembershipFromInvitationRequest.
     * @exports CreateNetworkMembershipFromInvitationRequest
     * @classdesc Represents a CreateNetworkMembershipFromInvitationRequest.
     * @implements ICreateNetworkMembershipFromInvitationRequest
     * @constructor
     * @param {ICreateNetworkMembershipFromInvitationRequest=} [properties] Properties to set
     */
    function CreateNetworkMembershipFromInvitationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkMembershipFromInvitationRequest invitationB64.
     * @member {string} invitationB64
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @instance
     */
    CreateNetworkMembershipFromInvitationRequest.prototype.invitationB64 = "";

    /**
     * CreateNetworkMembershipFromInvitationRequest invitationBytes.
     * @member {Uint8Array} invitationBytes
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @instance
     */
    CreateNetworkMembershipFromInvitationRequest.prototype.invitationBytes = $util.newBuffer([]);

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CreateNetworkMembershipFromInvitationRequest invitation.
     * @member {"invitationB64"|"invitationBytes"|undefined} invitation
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @instance
     */
    Object.defineProperty(CreateNetworkMembershipFromInvitationRequest.prototype, "invitation", {
        get: $util.oneOfGetter($oneOfFields = ["invitationB64", "invitationBytes"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CreateNetworkMembershipFromInvitationRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {ICreateNetworkMembershipFromInvitationRequest=} [properties] Properties to set
     * @returns {CreateNetworkMembershipFromInvitationRequest} CreateNetworkMembershipFromInvitationRequest instance
     */
    CreateNetworkMembershipFromInvitationRequest.create = function create(properties) {
        return new CreateNetworkMembershipFromInvitationRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkMembershipFromInvitationRequest message. Does not implicitly {@link CreateNetworkMembershipFromInvitationRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {ICreateNetworkMembershipFromInvitationRequest} message CreateNetworkMembershipFromInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkMembershipFromInvitationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.invitationB64 != null && Object.hasOwnProperty.call(message, "invitationB64"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.invitationB64);
        if (message.invitationBytes != null && Object.hasOwnProperty.call(message, "invitationBytes"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.invitationBytes);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkMembershipFromInvitationRequest message, length delimited. Does not implicitly {@link CreateNetworkMembershipFromInvitationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {ICreateNetworkMembershipFromInvitationRequest} message CreateNetworkMembershipFromInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkMembershipFromInvitationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkMembershipFromInvitationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkMembershipFromInvitationRequest} CreateNetworkMembershipFromInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkMembershipFromInvitationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkMembershipFromInvitationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.invitationB64 = reader.string();
                break;
            case 2:
                message.invitationBytes = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkMembershipFromInvitationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkMembershipFromInvitationRequest} CreateNetworkMembershipFromInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkMembershipFromInvitationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkMembershipFromInvitationRequest message.
     * @function verify
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkMembershipFromInvitationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64")) {
            properties.invitation = 1;
            if (!$util.isString(message.invitationB64))
                return "invitationB64: string expected";
        }
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes")) {
            if (properties.invitation === 1)
                return "invitation: multiple values";
            properties.invitation = 1;
            if (!(message.invitationBytes && typeof message.invitationBytes.length === "number" || $util.isString(message.invitationBytes)))
                return "invitationBytes: buffer expected";
        }
        return null;
    };

    /**
     * Creates a CreateNetworkMembershipFromInvitationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkMembershipFromInvitationRequest} CreateNetworkMembershipFromInvitationRequest
     */
    CreateNetworkMembershipFromInvitationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkMembershipFromInvitationRequest)
            return object;
        let message = new $root.CreateNetworkMembershipFromInvitationRequest();
        if (object.invitationB64 != null)
            message.invitationB64 = String(object.invitationB64);
        if (object.invitationBytes != null)
            if (typeof object.invitationBytes === "string")
                $util.base64.decode(object.invitationBytes, message.invitationBytes = $util.newBuffer($util.base64.length(object.invitationBytes)), 0);
            else if (object.invitationBytes.length)
                message.invitationBytes = object.invitationBytes;
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkMembershipFromInvitationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @static
     * @param {CreateNetworkMembershipFromInvitationRequest} message CreateNetworkMembershipFromInvitationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkMembershipFromInvitationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64")) {
            object.invitationB64 = message.invitationB64;
            if (options.oneofs)
                object.invitation = "invitationB64";
        }
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes")) {
            object.invitationBytes = options.bytes === String ? $util.base64.encode(message.invitationBytes, 0, message.invitationBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.invitationBytes) : message.invitationBytes;
            if (options.oneofs)
                object.invitation = "invitationBytes";
        }
        return object;
    };

    /**
     * Converts this CreateNetworkMembershipFromInvitationRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkMembershipFromInvitationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkMembershipFromInvitationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkMembershipFromInvitationRequest;
})();

export const CreateNetworkMembershipFromInvitationResponse = $root.CreateNetworkMembershipFromInvitationResponse = (() => {

    /**
     * Properties of a CreateNetworkMembershipFromInvitationResponse.
     * @exports ICreateNetworkMembershipFromInvitationResponse
     * @interface ICreateNetworkMembershipFromInvitationResponse
     * @property {INetworkMembership|null} [membership] CreateNetworkMembershipFromInvitationResponse membership
     */

    /**
     * Constructs a new CreateNetworkMembershipFromInvitationResponse.
     * @exports CreateNetworkMembershipFromInvitationResponse
     * @classdesc Represents a CreateNetworkMembershipFromInvitationResponse.
     * @implements ICreateNetworkMembershipFromInvitationResponse
     * @constructor
     * @param {ICreateNetworkMembershipFromInvitationResponse=} [properties] Properties to set
     */
    function CreateNetworkMembershipFromInvitationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkMembershipFromInvitationResponse membership.
     * @member {INetworkMembership|null|undefined} membership
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @instance
     */
    CreateNetworkMembershipFromInvitationResponse.prototype.membership = null;

    /**
     * Creates a new CreateNetworkMembershipFromInvitationResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {ICreateNetworkMembershipFromInvitationResponse=} [properties] Properties to set
     * @returns {CreateNetworkMembershipFromInvitationResponse} CreateNetworkMembershipFromInvitationResponse instance
     */
    CreateNetworkMembershipFromInvitationResponse.create = function create(properties) {
        return new CreateNetworkMembershipFromInvitationResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkMembershipFromInvitationResponse message. Does not implicitly {@link CreateNetworkMembershipFromInvitationResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {ICreateNetworkMembershipFromInvitationResponse} message CreateNetworkMembershipFromInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkMembershipFromInvitationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.membership != null && Object.hasOwnProperty.call(message, "membership"))
            $root.NetworkMembership.encode(message.membership, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkMembershipFromInvitationResponse message, length delimited. Does not implicitly {@link CreateNetworkMembershipFromInvitationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {ICreateNetworkMembershipFromInvitationResponse} message CreateNetworkMembershipFromInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkMembershipFromInvitationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkMembershipFromInvitationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkMembershipFromInvitationResponse} CreateNetworkMembershipFromInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkMembershipFromInvitationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkMembershipFromInvitationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.membership = $root.NetworkMembership.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkMembershipFromInvitationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkMembershipFromInvitationResponse} CreateNetworkMembershipFromInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkMembershipFromInvitationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkMembershipFromInvitationResponse message.
     * @function verify
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkMembershipFromInvitationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.membership != null && message.hasOwnProperty("membership")) {
            let error = $root.NetworkMembership.verify(message.membership);
            if (error)
                return "membership." + error;
        }
        return null;
    };

    /**
     * Creates a CreateNetworkMembershipFromInvitationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkMembershipFromInvitationResponse} CreateNetworkMembershipFromInvitationResponse
     */
    CreateNetworkMembershipFromInvitationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkMembershipFromInvitationResponse)
            return object;
        let message = new $root.CreateNetworkMembershipFromInvitationResponse();
        if (object.membership != null) {
            if (typeof object.membership !== "object")
                throw TypeError(".CreateNetworkMembershipFromInvitationResponse.membership: object expected");
            message.membership = $root.NetworkMembership.fromObject(object.membership);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkMembershipFromInvitationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @static
     * @param {CreateNetworkMembershipFromInvitationResponse} message CreateNetworkMembershipFromInvitationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkMembershipFromInvitationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.membership = null;
        if (message.membership != null && message.hasOwnProperty("membership"))
            object.membership = $root.NetworkMembership.toObject(message.membership, options);
        return object;
    };

    /**
     * Converts this CreateNetworkMembershipFromInvitationResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkMembershipFromInvitationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkMembershipFromInvitationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkMembershipFromInvitationResponse;
})();

export const BootstrapServiceMessage = $root.BootstrapServiceMessage = (() => {

    /**
     * Properties of a BootstrapServiceMessage.
     * @exports IBootstrapServiceMessage
     * @interface IBootstrapServiceMessage
     * @property {BootstrapServiceMessage.IBrokerOffer|null} [brokerOffer] BootstrapServiceMessage brokerOffer
     * @property {BootstrapServiceMessage.IPublishRequest|null} [publishRequest] BootstrapServiceMessage publishRequest
     * @property {BootstrapServiceMessage.IPublishResponse|null} [publishResponse] BootstrapServiceMessage publishResponse
     */

    /**
     * Constructs a new BootstrapServiceMessage.
     * @exports BootstrapServiceMessage
     * @classdesc Represents a BootstrapServiceMessage.
     * @implements IBootstrapServiceMessage
     * @constructor
     * @param {IBootstrapServiceMessage=} [properties] Properties to set
     */
    function BootstrapServiceMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapServiceMessage brokerOffer.
     * @member {BootstrapServiceMessage.IBrokerOffer|null|undefined} brokerOffer
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.brokerOffer = null;

    /**
     * BootstrapServiceMessage publishRequest.
     * @member {BootstrapServiceMessage.IPublishRequest|null|undefined} publishRequest
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.publishRequest = null;

    /**
     * BootstrapServiceMessage publishResponse.
     * @member {BootstrapServiceMessage.IPublishResponse|null|undefined} publishResponse
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.publishResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BootstrapServiceMessage body.
     * @member {"brokerOffer"|"publishRequest"|"publishResponse"|undefined} body
     * @memberof BootstrapServiceMessage
     * @instance
     */
    Object.defineProperty(BootstrapServiceMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["brokerOffer", "publishRequest", "publishResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BootstrapServiceMessage instance using the specified properties.
     * @function create
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage=} [properties] Properties to set
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage instance
     */
    BootstrapServiceMessage.create = function create(properties) {
        return new BootstrapServiceMessage(properties);
    };

    /**
     * Encodes the specified BootstrapServiceMessage message. Does not implicitly {@link BootstrapServiceMessage.verify|verify} messages.
     * @function encode
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage} message BootstrapServiceMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapServiceMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.brokerOffer != null && Object.hasOwnProperty.call(message, "brokerOffer"))
            $root.BootstrapServiceMessage.BrokerOffer.encode(message.brokerOffer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.publishRequest != null && Object.hasOwnProperty.call(message, "publishRequest"))
            $root.BootstrapServiceMessage.PublishRequest.encode(message.publishRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.publishResponse != null && Object.hasOwnProperty.call(message, "publishResponse"))
            $root.BootstrapServiceMessage.PublishResponse.encode(message.publishResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BootstrapServiceMessage message, length delimited. Does not implicitly {@link BootstrapServiceMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage} message BootstrapServiceMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapServiceMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapServiceMessage message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapServiceMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapServiceMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.decode(reader, reader.uint32());
                break;
            case 2:
                message.publishRequest = $root.BootstrapServiceMessage.PublishRequest.decode(reader, reader.uint32());
                break;
            case 3:
                message.publishResponse = $root.BootstrapServiceMessage.PublishResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapServiceMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapServiceMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapServiceMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapServiceMessage message.
     * @function verify
     * @memberof BootstrapServiceMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapServiceMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.brokerOffer != null && message.hasOwnProperty("brokerOffer")) {
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.BrokerOffer.verify(message.brokerOffer);
                if (error)
                    return "brokerOffer." + error;
            }
        }
        if (message.publishRequest != null && message.hasOwnProperty("publishRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.PublishRequest.verify(message.publishRequest);
                if (error)
                    return "publishRequest." + error;
            }
        }
        if (message.publishResponse != null && message.hasOwnProperty("publishResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.PublishResponse.verify(message.publishResponse);
                if (error)
                    return "publishResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BootstrapServiceMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapServiceMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     */
    BootstrapServiceMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapServiceMessage)
            return object;
        let message = new $root.BootstrapServiceMessage();
        if (object.brokerOffer != null) {
            if (typeof object.brokerOffer !== "object")
                throw TypeError(".BootstrapServiceMessage.brokerOffer: object expected");
            message.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.fromObject(object.brokerOffer);
        }
        if (object.publishRequest != null) {
            if (typeof object.publishRequest !== "object")
                throw TypeError(".BootstrapServiceMessage.publishRequest: object expected");
            message.publishRequest = $root.BootstrapServiceMessage.PublishRequest.fromObject(object.publishRequest);
        }
        if (object.publishResponse != null) {
            if (typeof object.publishResponse !== "object")
                throw TypeError(".BootstrapServiceMessage.publishResponse: object expected");
            message.publishResponse = $root.BootstrapServiceMessage.PublishResponse.fromObject(object.publishResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapServiceMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapServiceMessage
     * @static
     * @param {BootstrapServiceMessage} message BootstrapServiceMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapServiceMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.brokerOffer != null && message.hasOwnProperty("brokerOffer")) {
            object.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.toObject(message.brokerOffer, options);
            if (options.oneofs)
                object.body = "brokerOffer";
        }
        if (message.publishRequest != null && message.hasOwnProperty("publishRequest")) {
            object.publishRequest = $root.BootstrapServiceMessage.PublishRequest.toObject(message.publishRequest, options);
            if (options.oneofs)
                object.body = "publishRequest";
        }
        if (message.publishResponse != null && message.hasOwnProperty("publishResponse")) {
            object.publishResponse = $root.BootstrapServiceMessage.PublishResponse.toObject(message.publishResponse, options);
            if (options.oneofs)
                object.body = "publishResponse";
        }
        return object;
    };

    /**
     * Converts this BootstrapServiceMessage to JSON.
     * @function toJSON
     * @memberof BootstrapServiceMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapServiceMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    BootstrapServiceMessage.BrokerOffer = (function() {

        /**
         * Properties of a BrokerOffer.
         * @memberof BootstrapServiceMessage
         * @interface IBrokerOffer
         */

        /**
         * Constructs a new BrokerOffer.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a BrokerOffer.
         * @implements IBrokerOffer
         * @constructor
         * @param {BootstrapServiceMessage.IBrokerOffer=} [properties] Properties to set
         */
        function BrokerOffer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BrokerOffer instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer instance
         */
        BrokerOffer.create = function create(properties) {
            return new BrokerOffer(properties);
        };

        /**
         * Encodes the specified BrokerOffer message. Does not implicitly {@link BootstrapServiceMessage.BrokerOffer.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer} message BrokerOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BrokerOffer message, length delimited. Does not implicitly {@link BootstrapServiceMessage.BrokerOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer} message BrokerOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BrokerOffer message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.BrokerOffer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BrokerOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BrokerOffer message.
         * @function verify
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BrokerOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a BrokerOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         */
        BrokerOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.BrokerOffer)
                return object;
            return new $root.BootstrapServiceMessage.BrokerOffer();
        };

        /**
         * Creates a plain object from a BrokerOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.BrokerOffer} message BrokerOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BrokerOffer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BrokerOffer to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BrokerOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BrokerOffer;
    })();

    BootstrapServiceMessage.PublishRequest = (function() {

        /**
         * Properties of a PublishRequest.
         * @memberof BootstrapServiceMessage
         * @interface IPublishRequest
         * @property {string|null} [name] PublishRequest name
         * @property {ICertificate|null} [certificate] PublishRequest certificate
         */

        /**
         * Constructs a new PublishRequest.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a PublishRequest.
         * @implements IPublishRequest
         * @constructor
         * @param {BootstrapServiceMessage.IPublishRequest=} [properties] Properties to set
         */
        function PublishRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishRequest name.
         * @member {string} name
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         */
        PublishRequest.prototype.name = "";

        /**
         * PublishRequest certificate.
         * @member {ICertificate|null|undefined} certificate
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         */
        PublishRequest.prototype.certificate = null;

        /**
         * Creates a new PublishRequest instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest instance
         */
        PublishRequest.create = function create(properties) {
            return new PublishRequest(properties);
        };

        /**
         * Encodes the specified PublishRequest message. Does not implicitly {@link BootstrapServiceMessage.PublishRequest.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest} message PublishRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PublishRequest message, length delimited. Does not implicitly {@link BootstrapServiceMessage.PublishRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest} message PublishRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.PublishRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.certificate = $root.Certificate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishRequest message.
         * @function verify
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.certificate != null && message.hasOwnProperty("certificate")) {
                let error = $root.Certificate.verify(message.certificate);
                if (error)
                    return "certificate." + error;
            }
            return null;
        };

        /**
         * Creates a PublishRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         */
        PublishRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.PublishRequest)
                return object;
            let message = new $root.BootstrapServiceMessage.PublishRequest();
            if (object.name != null)
                message.name = String(object.name);
            if (object.certificate != null) {
                if (typeof object.certificate !== "object")
                    throw TypeError(".BootstrapServiceMessage.PublishRequest.certificate: object expected");
                message.certificate = $root.Certificate.fromObject(object.certificate);
            }
            return message;
        };

        /**
         * Creates a plain object from a PublishRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.PublishRequest} message PublishRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.certificate = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = $root.Certificate.toObject(message.certificate, options);
            return object;
        };

        /**
         * Converts this PublishRequest to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishRequest;
    })();

    BootstrapServiceMessage.PublishResponse = (function() {

        /**
         * Properties of a PublishResponse.
         * @memberof BootstrapServiceMessage
         * @interface IPublishResponse
         * @property {string|null} [error] PublishResponse error
         */

        /**
         * Constructs a new PublishResponse.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a PublishResponse.
         * @implements IPublishResponse
         * @constructor
         * @param {BootstrapServiceMessage.IPublishResponse=} [properties] Properties to set
         */
        function PublishResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishResponse error.
         * @member {string} error
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         */
        PublishResponse.prototype.error = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PublishResponse body.
         * @member {"error"|undefined} body
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         */
        Object.defineProperty(PublishResponse.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["error"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PublishResponse instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse instance
         */
        PublishResponse.create = function create(properties) {
            return new PublishResponse(properties);
        };

        /**
         * Encodes the specified PublishResponse message. Does not implicitly {@link BootstrapServiceMessage.PublishResponse.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse} message PublishResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
            return writer;
        };

        /**
         * Encodes the specified PublishResponse message, length delimited. Does not implicitly {@link BootstrapServiceMessage.PublishResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse} message PublishResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.PublishResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishResponse message.
         * @function verify
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.error != null && message.hasOwnProperty("error")) {
                properties.body = 1;
                if (!$util.isString(message.error))
                    return "error: string expected";
            }
            return null;
        };

        /**
         * Creates a PublishResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         */
        PublishResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.PublishResponse)
                return object;
            let message = new $root.BootstrapServiceMessage.PublishResponse();
            if (object.error != null)
                message.error = String(object.error);
            return message;
        };

        /**
         * Creates a plain object from a PublishResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.PublishResponse} message PublishResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.error != null && message.hasOwnProperty("error")) {
                object.error = message.error;
                if (options.oneofs)
                    object.body = "error";
            }
            return object;
        };

        /**
         * Converts this PublishResponse to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishResponse;
    })();

    return BootstrapServiceMessage;
})();

/**
 * MetricsFormat enum.
 * @exports MetricsFormat
 * @enum {number}
 * @property {number} METRICS_FORMAT_TEXT=0 METRICS_FORMAT_TEXT value
 * @property {number} METRICS_FORMAT_PROTO_DELIM=1 METRICS_FORMAT_PROTO_DELIM value
 * @property {number} METRICS_FORMAT_PROTO_TEXT=2 METRICS_FORMAT_PROTO_TEXT value
 * @property {number} METRICS_FORMAT_PROTO_COMPACT=3 METRICS_FORMAT_PROTO_COMPACT value
 * @property {number} METRICS_FORMAT_OPEN_METRICS=4 METRICS_FORMAT_OPEN_METRICS value
 */
$root.MetricsFormat = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "METRICS_FORMAT_TEXT"] = 0;
    values[valuesById[1] = "METRICS_FORMAT_PROTO_DELIM"] = 1;
    values[valuesById[2] = "METRICS_FORMAT_PROTO_TEXT"] = 2;
    values[valuesById[3] = "METRICS_FORMAT_PROTO_COMPACT"] = 3;
    values[valuesById[4] = "METRICS_FORMAT_OPEN_METRICS"] = 4;
    return values;
})();

/**
 * KDFType enum.
 * @exports KDFType
 * @enum {number}
 * @property {number} KDF_TYPE_UNDEFINED=0 KDF_TYPE_UNDEFINED value
 * @property {number} KDF_TYPE_PBKDF2_SHA256=1 KDF_TYPE_PBKDF2_SHA256 value
 */
$root.KDFType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KDF_TYPE_UNDEFINED"] = 0;
    values[valuesById[1] = "KDF_TYPE_PBKDF2_SHA256"] = 1;
    return values;
})();

/**
 * KeyType enum.
 * @exports KeyType
 * @enum {number}
 * @property {number} KEY_TYPE_UNDEFINED=0 KEY_TYPE_UNDEFINED value
 * @property {number} KEY_TYPE_ED25519=1 KEY_TYPE_ED25519 value
 * @property {number} KEY_TYPE_X25519=2 KEY_TYPE_X25519 value
 */
$root.KeyType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KEY_TYPE_UNDEFINED"] = 0;
    values[valuesById[1] = "KEY_TYPE_ED25519"] = 1;
    values[valuesById[2] = "KEY_TYPE_X25519"] = 2;
    return values;
})();

/**
 * KeyUsage enum.
 * @exports KeyUsage
 * @enum {number}
 * @property {number} KEY_USAGE_UNDEFINED=0 KEY_USAGE_UNDEFINED value
 * @property {number} KEY_USAGE_PEER=1 KEY_USAGE_PEER value
 * @property {number} KEY_USAGE_BOOTSTRAP=2 KEY_USAGE_BOOTSTRAP value
 * @property {number} KEY_USAGE_SIGN=4 KEY_USAGE_SIGN value
 * @property {number} KEY_USAGE_BROKER=8 KEY_USAGE_BROKER value
 * @property {number} KEY_USAGE_ENCIPHERMENT=16 KEY_USAGE_ENCIPHERMENT value
 */
$root.KeyUsage = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KEY_USAGE_UNDEFINED"] = 0;
    values[valuesById[1] = "KEY_USAGE_PEER"] = 1;
    values[valuesById[2] = "KEY_USAGE_BOOTSTRAP"] = 2;
    values[valuesById[4] = "KEY_USAGE_SIGN"] = 4;
    values[valuesById[8] = "KEY_USAGE_BROKER"] = 8;
    values[valuesById[16] = "KEY_USAGE_ENCIPHERMENT"] = 16;
    return values;
})();

/**
 * SwarmEventType enum.
 * @exports SwarmEventType
 * @enum {number}
 * @property {number} CREATE_SWARM=0 CREATE_SWARM value
 * @property {number} UPDATE_SWARM=1 UPDATE_SWARM value
 * @property {number} DELETE_SWARM=2 DELETE_SWARM value
 */
$root.SwarmEventType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CREATE_SWARM"] = 0;
    values[valuesById[1] = "UPDATE_SWARM"] = 1;
    values[valuesById[2] = "DELETE_SWARM"] = 2;
    return values;
})();

/**
 * WRTCSDPType enum.
 * @exports WRTCSDPType
 * @enum {number}
 * @property {number} OFFER=0 OFFER value
 * @property {number} ANSWER=1 ANSWER value
 */
$root.WRTCSDPType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "OFFER"] = 0;
    values[valuesById[1] = "ANSWER"] = 1;
    return values;
})();

export { $root as default };
