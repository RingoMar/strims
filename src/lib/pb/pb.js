/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const MonitorSwarmsRequest = $root.MonitorSwarmsRequest = (() => {

    /**
     * Properties of a MonitorSwarmsRequest.
     * @exports IMonitorSwarmsRequest
     * @interface IMonitorSwarmsRequest
     */

    /**
     * Constructs a new MonitorSwarmsRequest.
     * @exports MonitorSwarmsRequest
     * @classdesc Represents a MonitorSwarmsRequest.
     * @implements IMonitorSwarmsRequest
     * @constructor
     * @param {IMonitorSwarmsRequest=} [properties] Properties to set
     */
    function MonitorSwarmsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new MonitorSwarmsRequest instance using the specified properties.
     * @function create
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest=} [properties] Properties to set
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest instance
     */
    MonitorSwarmsRequest.create = function create(properties) {
        return new MonitorSwarmsRequest(properties);
    };

    /**
     * Encodes the specified MonitorSwarmsRequest message. Does not implicitly {@link MonitorSwarmsRequest.verify|verify} messages.
     * @function encode
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest} message MonitorSwarmsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified MonitorSwarmsRequest message, length delimited. Does not implicitly {@link MonitorSwarmsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {IMonitorSwarmsRequest} message MonitorSwarmsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MonitorSwarmsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MonitorSwarmsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MonitorSwarmsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MonitorSwarmsRequest message.
     * @function verify
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MonitorSwarmsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a MonitorSwarmsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MonitorSwarmsRequest} MonitorSwarmsRequest
     */
    MonitorSwarmsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.MonitorSwarmsRequest)
            return object;
        return new $root.MonitorSwarmsRequest();
    };

    /**
     * Creates a plain object from a MonitorSwarmsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MonitorSwarmsRequest
     * @static
     * @param {MonitorSwarmsRequest} message MonitorSwarmsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MonitorSwarmsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this MonitorSwarmsRequest to JSON.
     * @function toJSON
     * @memberof MonitorSwarmsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MonitorSwarmsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MonitorSwarmsRequest;
})();

export const MonitorSwarmsResponse = $root.MonitorSwarmsResponse = (() => {

    /**
     * Properties of a MonitorSwarmsResponse.
     * @exports IMonitorSwarmsResponse
     * @interface IMonitorSwarmsResponse
     * @property {SwarmEventType|null} [type] MonitorSwarmsResponse type
     * @property {string|null} [id] MonitorSwarmsResponse id
     */

    /**
     * Constructs a new MonitorSwarmsResponse.
     * @exports MonitorSwarmsResponse
     * @classdesc Represents a MonitorSwarmsResponse.
     * @implements IMonitorSwarmsResponse
     * @constructor
     * @param {IMonitorSwarmsResponse=} [properties] Properties to set
     */
    function MonitorSwarmsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MonitorSwarmsResponse type.
     * @member {SwarmEventType} type
     * @memberof MonitorSwarmsResponse
     * @instance
     */
    MonitorSwarmsResponse.prototype.type = 0;

    /**
     * MonitorSwarmsResponse id.
     * @member {string} id
     * @memberof MonitorSwarmsResponse
     * @instance
     */
    MonitorSwarmsResponse.prototype.id = "";

    /**
     * Creates a new MonitorSwarmsResponse instance using the specified properties.
     * @function create
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse=} [properties] Properties to set
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse instance
     */
    MonitorSwarmsResponse.create = function create(properties) {
        return new MonitorSwarmsResponse(properties);
    };

    /**
     * Encodes the specified MonitorSwarmsResponse message. Does not implicitly {@link MonitorSwarmsResponse.verify|verify} messages.
     * @function encode
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse} message MonitorSwarmsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
        return writer;
    };

    /**
     * Encodes the specified MonitorSwarmsResponse message, length delimited. Does not implicitly {@link MonitorSwarmsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {IMonitorSwarmsResponse} message MonitorSwarmsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonitorSwarmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MonitorSwarmsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MonitorSwarmsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.id = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MonitorSwarmsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonitorSwarmsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MonitorSwarmsResponse message.
     * @function verify
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MonitorSwarmsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        return null;
    };

    /**
     * Creates a MonitorSwarmsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MonitorSwarmsResponse} MonitorSwarmsResponse
     */
    MonitorSwarmsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.MonitorSwarmsResponse)
            return object;
        let message = new $root.MonitorSwarmsResponse();
        switch (object.type) {
        case "CREATE_SWARM":
        case 0:
            message.type = 0;
            break;
        case "UPDATE_SWARM":
        case 1:
            message.type = 1;
            break;
        case "DELETE_SWARM":
        case 2:
            message.type = 2;
            break;
        }
        if (object.id != null)
            message.id = String(object.id);
        return message;
    };

    /**
     * Creates a plain object from a MonitorSwarmsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MonitorSwarmsResponse
     * @static
     * @param {MonitorSwarmsResponse} message MonitorSwarmsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MonitorSwarmsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "CREATE_SWARM" : 0;
            object.id = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.SwarmEventType[message.type] : message.type;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this MonitorSwarmsResponse to JSON.
     * @function toJSON
     * @memberof MonitorSwarmsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MonitorSwarmsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MonitorSwarmsResponse;
})();

export const BootstrapDHTRequest = $root.BootstrapDHTRequest = (() => {

    /**
     * Properties of a BootstrapDHTRequest.
     * @exports IBootstrapDHTRequest
     * @interface IBootstrapDHTRequest
     * @property {Array.<string>|null} [transportUris] BootstrapDHTRequest transportUris
     */

    /**
     * Constructs a new BootstrapDHTRequest.
     * @exports BootstrapDHTRequest
     * @classdesc Represents a BootstrapDHTRequest.
     * @implements IBootstrapDHTRequest
     * @constructor
     * @param {IBootstrapDHTRequest=} [properties] Properties to set
     */
    function BootstrapDHTRequest(properties) {
        this.transportUris = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapDHTRequest transportUris.
     * @member {Array.<string>} transportUris
     * @memberof BootstrapDHTRequest
     * @instance
     */
    BootstrapDHTRequest.prototype.transportUris = $util.emptyArray;

    /**
     * Creates a new BootstrapDHTRequest instance using the specified properties.
     * @function create
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest=} [properties] Properties to set
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest instance
     */
    BootstrapDHTRequest.create = function create(properties) {
        return new BootstrapDHTRequest(properties);
    };

    /**
     * Encodes the specified BootstrapDHTRequest message. Does not implicitly {@link BootstrapDHTRequest.verify|verify} messages.
     * @function encode
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest} message BootstrapDHTRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.transportUris != null && message.transportUris.length)
            for (let i = 0; i < message.transportUris.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transportUris[i]);
        return writer;
    };

    /**
     * Encodes the specified BootstrapDHTRequest message, length delimited. Does not implicitly {@link BootstrapDHTRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapDHTRequest
     * @static
     * @param {IBootstrapDHTRequest} message BootstrapDHTRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapDHTRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapDHTRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapDHTRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.transportUris && message.transportUris.length))
                    message.transportUris = [];
                message.transportUris.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapDHTRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapDHTRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapDHTRequest message.
     * @function verify
     * @memberof BootstrapDHTRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapDHTRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.transportUris != null && message.hasOwnProperty("transportUris")) {
            if (!Array.isArray(message.transportUris))
                return "transportUris: array expected";
            for (let i = 0; i < message.transportUris.length; ++i)
                if (!$util.isString(message.transportUris[i]))
                    return "transportUris: string[] expected";
        }
        return null;
    };

    /**
     * Creates a BootstrapDHTRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapDHTRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapDHTRequest} BootstrapDHTRequest
     */
    BootstrapDHTRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapDHTRequest)
            return object;
        let message = new $root.BootstrapDHTRequest();
        if (object.transportUris) {
            if (!Array.isArray(object.transportUris))
                throw TypeError(".BootstrapDHTRequest.transportUris: array expected");
            message.transportUris = [];
            for (let i = 0; i < object.transportUris.length; ++i)
                message.transportUris[i] = String(object.transportUris[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapDHTRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapDHTRequest
     * @static
     * @param {BootstrapDHTRequest} message BootstrapDHTRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapDHTRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.transportUris = [];
        if (message.transportUris && message.transportUris.length) {
            object.transportUris = [];
            for (let j = 0; j < message.transportUris.length; ++j)
                object.transportUris[j] = message.transportUris[j];
        }
        return object;
    };

    /**
     * Converts this BootstrapDHTRequest to JSON.
     * @function toJSON
     * @memberof BootstrapDHTRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapDHTRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapDHTRequest;
})();

export const BootstrapDHTResponse = $root.BootstrapDHTResponse = (() => {

    /**
     * Properties of a BootstrapDHTResponse.
     * @exports IBootstrapDHTResponse
     * @interface IBootstrapDHTResponse
     */

    /**
     * Constructs a new BootstrapDHTResponse.
     * @exports BootstrapDHTResponse
     * @classdesc Represents a BootstrapDHTResponse.
     * @implements IBootstrapDHTResponse
     * @constructor
     * @param {IBootstrapDHTResponse=} [properties] Properties to set
     */
    function BootstrapDHTResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BootstrapDHTResponse instance using the specified properties.
     * @function create
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse=} [properties] Properties to set
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse instance
     */
    BootstrapDHTResponse.create = function create(properties) {
        return new BootstrapDHTResponse(properties);
    };

    /**
     * Encodes the specified BootstrapDHTResponse message. Does not implicitly {@link BootstrapDHTResponse.verify|verify} messages.
     * @function encode
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse} message BootstrapDHTResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BootstrapDHTResponse message, length delimited. Does not implicitly {@link BootstrapDHTResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapDHTResponse
     * @static
     * @param {IBootstrapDHTResponse} message BootstrapDHTResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapDHTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapDHTResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapDHTResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapDHTResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapDHTResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapDHTResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapDHTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapDHTResponse message.
     * @function verify
     * @memberof BootstrapDHTResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapDHTResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BootstrapDHTResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapDHTResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapDHTResponse} BootstrapDHTResponse
     */
    BootstrapDHTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapDHTResponse)
            return object;
        return new $root.BootstrapDHTResponse();
    };

    /**
     * Creates a plain object from a BootstrapDHTResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapDHTResponse
     * @static
     * @param {BootstrapDHTResponse} message BootstrapDHTResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapDHTResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BootstrapDHTResponse to JSON.
     * @function toJSON
     * @memberof BootstrapDHTResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapDHTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapDHTResponse;
})();

export const NegotiateWRTCRequest = $root.NegotiateWRTCRequest = (() => {

    /**
     * Properties of a NegotiateWRTCRequest.
     * @exports INegotiateWRTCRequest
     * @interface INegotiateWRTCRequest
     * @property {WRTCSDPType|null} [type] NegotiateWRTCRequest type
     * @property {string|null} [sessionDescription] NegotiateWRTCRequest sessionDescription
     */

    /**
     * Constructs a new NegotiateWRTCRequest.
     * @exports NegotiateWRTCRequest
     * @classdesc Represents a NegotiateWRTCRequest.
     * @implements INegotiateWRTCRequest
     * @constructor
     * @param {INegotiateWRTCRequest=} [properties] Properties to set
     */
    function NegotiateWRTCRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NegotiateWRTCRequest type.
     * @member {WRTCSDPType} type
     * @memberof NegotiateWRTCRequest
     * @instance
     */
    NegotiateWRTCRequest.prototype.type = 0;

    /**
     * NegotiateWRTCRequest sessionDescription.
     * @member {string} sessionDescription
     * @memberof NegotiateWRTCRequest
     * @instance
     */
    NegotiateWRTCRequest.prototype.sessionDescription = "";

    /**
     * Creates a new NegotiateWRTCRequest instance using the specified properties.
     * @function create
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest=} [properties] Properties to set
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest instance
     */
    NegotiateWRTCRequest.create = function create(properties) {
        return new NegotiateWRTCRequest(properties);
    };

    /**
     * Encodes the specified NegotiateWRTCRequest message. Does not implicitly {@link NegotiateWRTCRequest.verify|verify} messages.
     * @function encode
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest} message NegotiateWRTCRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.sessionDescription != null && Object.hasOwnProperty.call(message, "sessionDescription"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionDescription);
        return writer;
    };

    /**
     * Encodes the specified NegotiateWRTCRequest message, length delimited. Does not implicitly {@link NegotiateWRTCRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {INegotiateWRTCRequest} message NegotiateWRTCRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NegotiateWRTCRequest message from the specified reader or buffer.
     * @function decode
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NegotiateWRTCRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.sessionDescription = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NegotiateWRTCRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NegotiateWRTCRequest message.
     * @function verify
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NegotiateWRTCRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.sessionDescription != null && message.hasOwnProperty("sessionDescription"))
            if (!$util.isString(message.sessionDescription))
                return "sessionDescription: string expected";
        return null;
    };

    /**
     * Creates a NegotiateWRTCRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NegotiateWRTCRequest} NegotiateWRTCRequest
     */
    NegotiateWRTCRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.NegotiateWRTCRequest)
            return object;
        let message = new $root.NegotiateWRTCRequest();
        switch (object.type) {
        case "OFFER":
        case 0:
            message.type = 0;
            break;
        case "ANSWER":
        case 1:
            message.type = 1;
            break;
        }
        if (object.sessionDescription != null)
            message.sessionDescription = String(object.sessionDescription);
        return message;
    };

    /**
     * Creates a plain object from a NegotiateWRTCRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NegotiateWRTCRequest
     * @static
     * @param {NegotiateWRTCRequest} message NegotiateWRTCRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NegotiateWRTCRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "OFFER" : 0;
            object.sessionDescription = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.WRTCSDPType[message.type] : message.type;
        if (message.sessionDescription != null && message.hasOwnProperty("sessionDescription"))
            object.sessionDescription = message.sessionDescription;
        return object;
    };

    /**
     * Converts this NegotiateWRTCRequest to JSON.
     * @function toJSON
     * @memberof NegotiateWRTCRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NegotiateWRTCRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NegotiateWRTCRequest;
})();

export const NegotiateWRTCResponse = $root.NegotiateWRTCResponse = (() => {

    /**
     * Properties of a NegotiateWRTCResponse.
     * @exports INegotiateWRTCResponse
     * @interface INegotiateWRTCResponse
     * @property {string|null} [candidate] NegotiateWRTCResponse candidate
     */

    /**
     * Constructs a new NegotiateWRTCResponse.
     * @exports NegotiateWRTCResponse
     * @classdesc Represents a NegotiateWRTCResponse.
     * @implements INegotiateWRTCResponse
     * @constructor
     * @param {INegotiateWRTCResponse=} [properties] Properties to set
     */
    function NegotiateWRTCResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NegotiateWRTCResponse candidate.
     * @member {string} candidate
     * @memberof NegotiateWRTCResponse
     * @instance
     */
    NegotiateWRTCResponse.prototype.candidate = "";

    /**
     * Creates a new NegotiateWRTCResponse instance using the specified properties.
     * @function create
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse=} [properties] Properties to set
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse instance
     */
    NegotiateWRTCResponse.create = function create(properties) {
        return new NegotiateWRTCResponse(properties);
    };

    /**
     * Encodes the specified NegotiateWRTCResponse message. Does not implicitly {@link NegotiateWRTCResponse.verify|verify} messages.
     * @function encode
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse} message NegotiateWRTCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.candidate != null && Object.hasOwnProperty.call(message, "candidate"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.candidate);
        return writer;
    };

    /**
     * Encodes the specified NegotiateWRTCResponse message, length delimited. Does not implicitly {@link NegotiateWRTCResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {INegotiateWRTCResponse} message NegotiateWRTCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NegotiateWRTCResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NegotiateWRTCResponse message from the specified reader or buffer.
     * @function decode
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NegotiateWRTCResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.candidate = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NegotiateWRTCResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NegotiateWRTCResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NegotiateWRTCResponse message.
     * @function verify
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NegotiateWRTCResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.candidate != null && message.hasOwnProperty("candidate"))
            if (!$util.isString(message.candidate))
                return "candidate: string expected";
        return null;
    };

    /**
     * Creates a NegotiateWRTCResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NegotiateWRTCResponse} NegotiateWRTCResponse
     */
    NegotiateWRTCResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.NegotiateWRTCResponse)
            return object;
        let message = new $root.NegotiateWRTCResponse();
        if (object.candidate != null)
            message.candidate = String(object.candidate);
        return message;
    };

    /**
     * Creates a plain object from a NegotiateWRTCResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NegotiateWRTCResponse
     * @static
     * @param {NegotiateWRTCResponse} message NegotiateWRTCResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NegotiateWRTCResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.candidate = "";
        if (message.candidate != null && message.hasOwnProperty("candidate"))
            object.candidate = message.candidate;
        return object;
    };

    /**
     * Converts this NegotiateWRTCResponse to JSON.
     * @function toJSON
     * @memberof NegotiateWRTCResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NegotiateWRTCResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NegotiateWRTCResponse;
})();

export const CreateChatServerRequest = $root.CreateChatServerRequest = (() => {

    /**
     * Properties of a CreateChatServerRequest.
     * @exports ICreateChatServerRequest
     * @interface ICreateChatServerRequest
     * @property {Uint8Array|null} [networkKey] CreateChatServerRequest networkKey
     * @property {IChatRoom|null} [chatRoom] CreateChatServerRequest chatRoom
     */

    /**
     * Constructs a new CreateChatServerRequest.
     * @exports CreateChatServerRequest
     * @classdesc Represents a CreateChatServerRequest.
     * @implements ICreateChatServerRequest
     * @constructor
     * @param {ICreateChatServerRequest=} [properties] Properties to set
     */
    function CreateChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateChatServerRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof CreateChatServerRequest
     * @instance
     */
    CreateChatServerRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * CreateChatServerRequest chatRoom.
     * @member {IChatRoom|null|undefined} chatRoom
     * @memberof CreateChatServerRequest
     * @instance
     */
    CreateChatServerRequest.prototype.chatRoom = null;

    /**
     * Creates a new CreateChatServerRequest instance using the specified properties.
     * @function create
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest=} [properties] Properties to set
     * @returns {CreateChatServerRequest} CreateChatServerRequest instance
     */
    CreateChatServerRequest.create = function create(properties) {
        return new CreateChatServerRequest(properties);
    };

    /**
     * Encodes the specified CreateChatServerRequest message. Does not implicitly {@link CreateChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest} message CreateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.chatRoom != null && Object.hasOwnProperty.call(message, "chatRoom"))
            $root.ChatRoom.encode(message.chatRoom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateChatServerRequest message, length delimited. Does not implicitly {@link CreateChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateChatServerRequest
     * @static
     * @param {ICreateChatServerRequest} message CreateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.chatRoom = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateChatServerRequest message.
     * @function verify
     * @memberof CreateChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom")) {
            let error = $root.ChatRoom.verify(message.chatRoom);
            if (error)
                return "chatRoom." + error;
        }
        return null;
    };

    /**
     * Creates a CreateChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateChatServerRequest} CreateChatServerRequest
     */
    CreateChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateChatServerRequest)
            return object;
        let message = new $root.CreateChatServerRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.chatRoom != null) {
            if (typeof object.chatRoom !== "object")
                throw TypeError(".CreateChatServerRequest.chatRoom: object expected");
            message.chatRoom = $root.ChatRoom.fromObject(object.chatRoom);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateChatServerRequest
     * @static
     * @param {CreateChatServerRequest} message CreateChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.chatRoom = null;
        }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom"))
            object.chatRoom = $root.ChatRoom.toObject(message.chatRoom, options);
        return object;
    };

    /**
     * Converts this CreateChatServerRequest to JSON.
     * @function toJSON
     * @memberof CreateChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateChatServerRequest;
})();

export const CreateChatServerResponse = $root.CreateChatServerResponse = (() => {

    /**
     * Properties of a CreateChatServerResponse.
     * @exports ICreateChatServerResponse
     * @interface ICreateChatServerResponse
     * @property {IChatServer|null} [chatServer] CreateChatServerResponse chatServer
     */

    /**
     * Constructs a new CreateChatServerResponse.
     * @exports CreateChatServerResponse
     * @classdesc Represents a CreateChatServerResponse.
     * @implements ICreateChatServerResponse
     * @constructor
     * @param {ICreateChatServerResponse=} [properties] Properties to set
     */
    function CreateChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof CreateChatServerResponse
     * @instance
     */
    CreateChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new CreateChatServerResponse instance using the specified properties.
     * @function create
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse=} [properties] Properties to set
     * @returns {CreateChatServerResponse} CreateChatServerResponse instance
     */
    CreateChatServerResponse.create = function create(properties) {
        return new CreateChatServerResponse(properties);
    };

    /**
     * Encodes the specified CreateChatServerResponse message. Does not implicitly {@link CreateChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse} message CreateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateChatServerResponse message, length delimited. Does not implicitly {@link CreateChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateChatServerResponse
     * @static
     * @param {ICreateChatServerResponse} message CreateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateChatServerResponse message.
     * @function verify
     * @memberof CreateChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates a CreateChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateChatServerResponse} CreateChatServerResponse
     */
    CreateChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateChatServerResponse)
            return object;
        let message = new $root.CreateChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".CreateChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateChatServerResponse
     * @static
     * @param {CreateChatServerResponse} message CreateChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this CreateChatServerResponse to JSON.
     * @function toJSON
     * @memberof CreateChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateChatServerResponse;
})();

export const UpdateChatServerRequest = $root.UpdateChatServerRequest = (() => {

    /**
     * Properties of an UpdateChatServerRequest.
     * @exports IUpdateChatServerRequest
     * @interface IUpdateChatServerRequest
     * @property {number|null} [id] UpdateChatServerRequest id
     * @property {Uint8Array|null} [networkKey] UpdateChatServerRequest networkKey
     * @property {IChatRoom|null} [serverKey] UpdateChatServerRequest serverKey
     */

    /**
     * Constructs a new UpdateChatServerRequest.
     * @exports UpdateChatServerRequest
     * @classdesc Represents an UpdateChatServerRequest.
     * @implements IUpdateChatServerRequest
     * @constructor
     * @param {IUpdateChatServerRequest=} [properties] Properties to set
     */
    function UpdateChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateChatServerRequest id.
     * @member {number} id
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateChatServerRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * UpdateChatServerRequest serverKey.
     * @member {IChatRoom|null|undefined} serverKey
     * @memberof UpdateChatServerRequest
     * @instance
     */
    UpdateChatServerRequest.prototype.serverKey = null;

    /**
     * Creates a new UpdateChatServerRequest instance using the specified properties.
     * @function create
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest=} [properties] Properties to set
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest instance
     */
    UpdateChatServerRequest.create = function create(properties) {
        return new UpdateChatServerRequest(properties);
    };

    /**
     * Encodes the specified UpdateChatServerRequest message. Does not implicitly {@link UpdateChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest} message UpdateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
            $root.ChatRoom.encode(message.serverKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateChatServerRequest message, length delimited. Does not implicitly {@link UpdateChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateChatServerRequest
     * @static
     * @param {IUpdateChatServerRequest} message UpdateChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.serverKey = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateChatServerRequest message.
     * @function verify
     * @memberof UpdateChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.serverKey != null && message.hasOwnProperty("serverKey")) {
            let error = $root.ChatRoom.verify(message.serverKey);
            if (error)
                return "serverKey." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateChatServerRequest} UpdateChatServerRequest
     */
    UpdateChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateChatServerRequest)
            return object;
        let message = new $root.UpdateChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.serverKey != null) {
            if (typeof object.serverKey !== "object")
                throw TypeError(".UpdateChatServerRequest.serverKey: object expected");
            message.serverKey = $root.ChatRoom.fromObject(object.serverKey);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateChatServerRequest
     * @static
     * @param {UpdateChatServerRequest} message UpdateChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.serverKey = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.serverKey != null && message.hasOwnProperty("serverKey"))
            object.serverKey = $root.ChatRoom.toObject(message.serverKey, options);
        return object;
    };

    /**
     * Converts this UpdateChatServerRequest to JSON.
     * @function toJSON
     * @memberof UpdateChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateChatServerRequest;
})();

export const UpdateChatServerResponse = $root.UpdateChatServerResponse = (() => {

    /**
     * Properties of an UpdateChatServerResponse.
     * @exports IUpdateChatServerResponse
     * @interface IUpdateChatServerResponse
     * @property {IChatServer|null} [chatServer] UpdateChatServerResponse chatServer
     */

    /**
     * Constructs a new UpdateChatServerResponse.
     * @exports UpdateChatServerResponse
     * @classdesc Represents an UpdateChatServerResponse.
     * @implements IUpdateChatServerResponse
     * @constructor
     * @param {IUpdateChatServerResponse=} [properties] Properties to set
     */
    function UpdateChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof UpdateChatServerResponse
     * @instance
     */
    UpdateChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new UpdateChatServerResponse instance using the specified properties.
     * @function create
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse=} [properties] Properties to set
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse instance
     */
    UpdateChatServerResponse.create = function create(properties) {
        return new UpdateChatServerResponse(properties);
    };

    /**
     * Encodes the specified UpdateChatServerResponse message. Does not implicitly {@link UpdateChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse} message UpdateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateChatServerResponse message, length delimited. Does not implicitly {@link UpdateChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateChatServerResponse
     * @static
     * @param {IUpdateChatServerResponse} message UpdateChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateChatServerResponse message.
     * @function verify
     * @memberof UpdateChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateChatServerResponse} UpdateChatServerResponse
     */
    UpdateChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateChatServerResponse)
            return object;
        let message = new $root.UpdateChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".UpdateChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateChatServerResponse
     * @static
     * @param {UpdateChatServerResponse} message UpdateChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this UpdateChatServerResponse to JSON.
     * @function toJSON
     * @memberof UpdateChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateChatServerResponse;
})();

export const DeleteChatServerRequest = $root.DeleteChatServerRequest = (() => {

    /**
     * Properties of a DeleteChatServerRequest.
     * @exports IDeleteChatServerRequest
     * @interface IDeleteChatServerRequest
     * @property {number|null} [id] DeleteChatServerRequest id
     */

    /**
     * Constructs a new DeleteChatServerRequest.
     * @exports DeleteChatServerRequest
     * @classdesc Represents a DeleteChatServerRequest.
     * @implements IDeleteChatServerRequest
     * @constructor
     * @param {IDeleteChatServerRequest=} [properties] Properties to set
     */
    function DeleteChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteChatServerRequest id.
     * @member {number} id
     * @memberof DeleteChatServerRequest
     * @instance
     */
    DeleteChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteChatServerRequest instance using the specified properties.
     * @function create
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest=} [properties] Properties to set
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest instance
     */
    DeleteChatServerRequest.create = function create(properties) {
        return new DeleteChatServerRequest(properties);
    };

    /**
     * Encodes the specified DeleteChatServerRequest message. Does not implicitly {@link DeleteChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest} message DeleteChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteChatServerRequest message, length delimited. Does not implicitly {@link DeleteChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteChatServerRequest
     * @static
     * @param {IDeleteChatServerRequest} message DeleteChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteChatServerRequest message.
     * @function verify
     * @memberof DeleteChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteChatServerRequest} DeleteChatServerRequest
     */
    DeleteChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteChatServerRequest)
            return object;
        let message = new $root.DeleteChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteChatServerRequest
     * @static
     * @param {DeleteChatServerRequest} message DeleteChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteChatServerRequest to JSON.
     * @function toJSON
     * @memberof DeleteChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteChatServerRequest;
})();

export const DeleteChatServerResponse = $root.DeleteChatServerResponse = (() => {

    /**
     * Properties of a DeleteChatServerResponse.
     * @exports IDeleteChatServerResponse
     * @interface IDeleteChatServerResponse
     */

    /**
     * Constructs a new DeleteChatServerResponse.
     * @exports DeleteChatServerResponse
     * @classdesc Represents a DeleteChatServerResponse.
     * @implements IDeleteChatServerResponse
     * @constructor
     * @param {IDeleteChatServerResponse=} [properties] Properties to set
     */
    function DeleteChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteChatServerResponse instance using the specified properties.
     * @function create
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse=} [properties] Properties to set
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse instance
     */
    DeleteChatServerResponse.create = function create(properties) {
        return new DeleteChatServerResponse(properties);
    };

    /**
     * Encodes the specified DeleteChatServerResponse message. Does not implicitly {@link DeleteChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse} message DeleteChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteChatServerResponse message, length delimited. Does not implicitly {@link DeleteChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteChatServerResponse
     * @static
     * @param {IDeleteChatServerResponse} message DeleteChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteChatServerResponse message.
     * @function verify
     * @memberof DeleteChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteChatServerResponse} DeleteChatServerResponse
     */
    DeleteChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteChatServerResponse)
            return object;
        return new $root.DeleteChatServerResponse();
    };

    /**
     * Creates a plain object from a DeleteChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteChatServerResponse
     * @static
     * @param {DeleteChatServerResponse} message DeleteChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteChatServerResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteChatServerResponse to JSON.
     * @function toJSON
     * @memberof DeleteChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteChatServerResponse;
})();

export const GetChatServerRequest = $root.GetChatServerRequest = (() => {

    /**
     * Properties of a GetChatServerRequest.
     * @exports IGetChatServerRequest
     * @interface IGetChatServerRequest
     * @property {number|null} [id] GetChatServerRequest id
     */

    /**
     * Constructs a new GetChatServerRequest.
     * @exports GetChatServerRequest
     * @classdesc Represents a GetChatServerRequest.
     * @implements IGetChatServerRequest
     * @constructor
     * @param {IGetChatServerRequest=} [properties] Properties to set
     */
    function GetChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetChatServerRequest id.
     * @member {number} id
     * @memberof GetChatServerRequest
     * @instance
     */
    GetChatServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetChatServerRequest instance using the specified properties.
     * @function create
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest=} [properties] Properties to set
     * @returns {GetChatServerRequest} GetChatServerRequest instance
     */
    GetChatServerRequest.create = function create(properties) {
        return new GetChatServerRequest(properties);
    };

    /**
     * Encodes the specified GetChatServerRequest message. Does not implicitly {@link GetChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest} message GetChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetChatServerRequest message, length delimited. Does not implicitly {@link GetChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServerRequest
     * @static
     * @param {IGetChatServerRequest} message GetChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServerRequest} GetChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServerRequest} GetChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServerRequest message.
     * @function verify
     * @memberof GetChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServerRequest} GetChatServerRequest
     */
    GetChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServerRequest)
            return object;
        let message = new $root.GetChatServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServerRequest
     * @static
     * @param {GetChatServerRequest} message GetChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetChatServerRequest to JSON.
     * @function toJSON
     * @memberof GetChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServerRequest;
})();

export const GetChatServerResponse = $root.GetChatServerResponse = (() => {

    /**
     * Properties of a GetChatServerResponse.
     * @exports IGetChatServerResponse
     * @interface IGetChatServerResponse
     * @property {IChatServer|null} [chatServer] GetChatServerResponse chatServer
     */

    /**
     * Constructs a new GetChatServerResponse.
     * @exports GetChatServerResponse
     * @classdesc Represents a GetChatServerResponse.
     * @implements IGetChatServerResponse
     * @constructor
     * @param {IGetChatServerResponse=} [properties] Properties to set
     */
    function GetChatServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetChatServerResponse chatServer.
     * @member {IChatServer|null|undefined} chatServer
     * @memberof GetChatServerResponse
     * @instance
     */
    GetChatServerResponse.prototype.chatServer = null;

    /**
     * Creates a new GetChatServerResponse instance using the specified properties.
     * @function create
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse=} [properties] Properties to set
     * @returns {GetChatServerResponse} GetChatServerResponse instance
     */
    GetChatServerResponse.create = function create(properties) {
        return new GetChatServerResponse(properties);
    };

    /**
     * Encodes the specified GetChatServerResponse message. Does not implicitly {@link GetChatServerResponse.verify|verify} messages.
     * @function encode
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse} message GetChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServer != null && Object.hasOwnProperty.call(message, "chatServer"))
            $root.ChatServer.encode(message.chatServer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetChatServerResponse message, length delimited. Does not implicitly {@link GetChatServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetChatServerResponse
     * @static
     * @param {IGetChatServerResponse} message GetChatServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetChatServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetChatServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetChatServerResponse} GetChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetChatServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.chatServer = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetChatServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetChatServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetChatServerResponse} GetChatServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetChatServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetChatServerResponse message.
     * @function verify
     * @memberof GetChatServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetChatServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServer != null && message.hasOwnProperty("chatServer")) {
            let error = $root.ChatServer.verify(message.chatServer);
            if (error)
                return "chatServer." + error;
        }
        return null;
    };

    /**
     * Creates a GetChatServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetChatServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetChatServerResponse} GetChatServerResponse
     */
    GetChatServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetChatServerResponse)
            return object;
        let message = new $root.GetChatServerResponse();
        if (object.chatServer != null) {
            if (typeof object.chatServer !== "object")
                throw TypeError(".GetChatServerResponse.chatServer: object expected");
            message.chatServer = $root.ChatServer.fromObject(object.chatServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetChatServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetChatServerResponse
     * @static
     * @param {GetChatServerResponse} message GetChatServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetChatServerResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.chatServer = null;
        if (message.chatServer != null && message.hasOwnProperty("chatServer"))
            object.chatServer = $root.ChatServer.toObject(message.chatServer, options);
        return object;
    };

    /**
     * Converts this GetChatServerResponse to JSON.
     * @function toJSON
     * @memberof GetChatServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetChatServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetChatServerResponse;
})();

export const ListChatServersRequest = $root.ListChatServersRequest = (() => {

    /**
     * Properties of a ListChatServersRequest.
     * @exports IListChatServersRequest
     * @interface IListChatServersRequest
     */

    /**
     * Constructs a new ListChatServersRequest.
     * @exports ListChatServersRequest
     * @classdesc Represents a ListChatServersRequest.
     * @implements IListChatServersRequest
     * @constructor
     * @param {IListChatServersRequest=} [properties] Properties to set
     */
    function ListChatServersRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ListChatServersRequest instance using the specified properties.
     * @function create
     * @memberof ListChatServersRequest
     * @static
     * @param {IListChatServersRequest=} [properties] Properties to set
     * @returns {ListChatServersRequest} ListChatServersRequest instance
     */
    ListChatServersRequest.create = function create(properties) {
        return new ListChatServersRequest(properties);
    };

    /**
     * Encodes the specified ListChatServersRequest message. Does not implicitly {@link ListChatServersRequest.verify|verify} messages.
     * @function encode
     * @memberof ListChatServersRequest
     * @static
     * @param {IListChatServersRequest} message ListChatServersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListChatServersRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ListChatServersRequest message, length delimited. Does not implicitly {@link ListChatServersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListChatServersRequest
     * @static
     * @param {IListChatServersRequest} message ListChatServersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListChatServersRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListChatServersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ListChatServersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListChatServersRequest} ListChatServersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListChatServersRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListChatServersRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListChatServersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListChatServersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListChatServersRequest} ListChatServersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListChatServersRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListChatServersRequest message.
     * @function verify
     * @memberof ListChatServersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListChatServersRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ListChatServersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListChatServersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListChatServersRequest} ListChatServersRequest
     */
    ListChatServersRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ListChatServersRequest)
            return object;
        return new $root.ListChatServersRequest();
    };

    /**
     * Creates a plain object from a ListChatServersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListChatServersRequest
     * @static
     * @param {ListChatServersRequest} message ListChatServersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListChatServersRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ListChatServersRequest to JSON.
     * @function toJSON
     * @memberof ListChatServersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListChatServersRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListChatServersRequest;
})();

export const ListChatServersResponse = $root.ListChatServersResponse = (() => {

    /**
     * Properties of a ListChatServersResponse.
     * @exports IListChatServersResponse
     * @interface IListChatServersResponse
     * @property {Array.<IChatServer>|null} [chatServers] ListChatServersResponse chatServers
     */

    /**
     * Constructs a new ListChatServersResponse.
     * @exports ListChatServersResponse
     * @classdesc Represents a ListChatServersResponse.
     * @implements IListChatServersResponse
     * @constructor
     * @param {IListChatServersResponse=} [properties] Properties to set
     */
    function ListChatServersResponse(properties) {
        this.chatServers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListChatServersResponse chatServers.
     * @member {Array.<IChatServer>} chatServers
     * @memberof ListChatServersResponse
     * @instance
     */
    ListChatServersResponse.prototype.chatServers = $util.emptyArray;

    /**
     * Creates a new ListChatServersResponse instance using the specified properties.
     * @function create
     * @memberof ListChatServersResponse
     * @static
     * @param {IListChatServersResponse=} [properties] Properties to set
     * @returns {ListChatServersResponse} ListChatServersResponse instance
     */
    ListChatServersResponse.create = function create(properties) {
        return new ListChatServersResponse(properties);
    };

    /**
     * Encodes the specified ListChatServersResponse message. Does not implicitly {@link ListChatServersResponse.verify|verify} messages.
     * @function encode
     * @memberof ListChatServersResponse
     * @static
     * @param {IListChatServersResponse} message ListChatServersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListChatServersResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.chatServers != null && message.chatServers.length)
            for (let i = 0; i < message.chatServers.length; ++i)
                $root.ChatServer.encode(message.chatServers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListChatServersResponse message, length delimited. Does not implicitly {@link ListChatServersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListChatServersResponse
     * @static
     * @param {IListChatServersResponse} message ListChatServersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListChatServersResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListChatServersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListChatServersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListChatServersResponse} ListChatServersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListChatServersResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListChatServersResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.chatServers && message.chatServers.length))
                    message.chatServers = [];
                message.chatServers.push($root.ChatServer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListChatServersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListChatServersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListChatServersResponse} ListChatServersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListChatServersResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListChatServersResponse message.
     * @function verify
     * @memberof ListChatServersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListChatServersResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.chatServers != null && message.hasOwnProperty("chatServers")) {
            if (!Array.isArray(message.chatServers))
                return "chatServers: array expected";
            for (let i = 0; i < message.chatServers.length; ++i) {
                let error = $root.ChatServer.verify(message.chatServers[i]);
                if (error)
                    return "chatServers." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListChatServersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListChatServersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListChatServersResponse} ListChatServersResponse
     */
    ListChatServersResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListChatServersResponse)
            return object;
        let message = new $root.ListChatServersResponse();
        if (object.chatServers) {
            if (!Array.isArray(object.chatServers))
                throw TypeError(".ListChatServersResponse.chatServers: array expected");
            message.chatServers = [];
            for (let i = 0; i < object.chatServers.length; ++i) {
                if (typeof object.chatServers[i] !== "object")
                    throw TypeError(".ListChatServersResponse.chatServers: object expected");
                message.chatServers[i] = $root.ChatServer.fromObject(object.chatServers[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListChatServersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListChatServersResponse
     * @static
     * @param {ListChatServersResponse} message ListChatServersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListChatServersResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.chatServers = [];
        if (message.chatServers && message.chatServers.length) {
            object.chatServers = [];
            for (let j = 0; j < message.chatServers.length; ++j)
                object.chatServers[j] = $root.ChatServer.toObject(message.chatServers[j], options);
        }
        return object;
    };

    /**
     * Converts this ListChatServersResponse to JSON.
     * @function toJSON
     * @memberof ListChatServersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListChatServersResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListChatServersResponse;
})();

export const OpenChatServerRequest = $root.OpenChatServerRequest = (() => {

    /**
     * Properties of an OpenChatServerRequest.
     * @exports IOpenChatServerRequest
     * @interface IOpenChatServerRequest
     * @property {IChatServer|null} [server] OpenChatServerRequest server
     */

    /**
     * Constructs a new OpenChatServerRequest.
     * @exports OpenChatServerRequest
     * @classdesc Represents an OpenChatServerRequest.
     * @implements IOpenChatServerRequest
     * @constructor
     * @param {IOpenChatServerRequest=} [properties] Properties to set
     */
    function OpenChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenChatServerRequest server.
     * @member {IChatServer|null|undefined} server
     * @memberof OpenChatServerRequest
     * @instance
     */
    OpenChatServerRequest.prototype.server = null;

    /**
     * Creates a new OpenChatServerRequest instance using the specified properties.
     * @function create
     * @memberof OpenChatServerRequest
     * @static
     * @param {IOpenChatServerRequest=} [properties] Properties to set
     * @returns {OpenChatServerRequest} OpenChatServerRequest instance
     */
    OpenChatServerRequest.create = function create(properties) {
        return new OpenChatServerRequest(properties);
    };

    /**
     * Encodes the specified OpenChatServerRequest message. Does not implicitly {@link OpenChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenChatServerRequest
     * @static
     * @param {IOpenChatServerRequest} message OpenChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.server != null && Object.hasOwnProperty.call(message, "server"))
            $root.ChatServer.encode(message.server, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OpenChatServerRequest message, length delimited. Does not implicitly {@link OpenChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenChatServerRequest
     * @static
     * @param {IOpenChatServerRequest} message OpenChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenChatServerRequest} OpenChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.server = $root.ChatServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenChatServerRequest} OpenChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenChatServerRequest message.
     * @function verify
     * @memberof OpenChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.server != null && message.hasOwnProperty("server")) {
            let error = $root.ChatServer.verify(message.server);
            if (error)
                return "server." + error;
        }
        return null;
    };

    /**
     * Creates an OpenChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenChatServerRequest} OpenChatServerRequest
     */
    OpenChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenChatServerRequest)
            return object;
        let message = new $root.OpenChatServerRequest();
        if (object.server != null) {
            if (typeof object.server !== "object")
                throw TypeError(".OpenChatServerRequest.server: object expected");
            message.server = $root.ChatServer.fromObject(object.server);
        }
        return message;
    };

    /**
     * Creates a plain object from an OpenChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenChatServerRequest
     * @static
     * @param {OpenChatServerRequest} message OpenChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.server = null;
        if (message.server != null && message.hasOwnProperty("server"))
            object.server = $root.ChatServer.toObject(message.server, options);
        return object;
    };

    /**
     * Converts this OpenChatServerRequest to JSON.
     * @function toJSON
     * @memberof OpenChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OpenChatServerRequest;
})();

export const ChatServerEvent = $root.ChatServerEvent = (() => {

    /**
     * Properties of a ChatServerEvent.
     * @exports IChatServerEvent
     * @interface IChatServerEvent
     * @property {ChatServerEvent.IOpen|null} [open] ChatServerEvent open
     * @property {ChatServerEvent.IClose|null} [close] ChatServerEvent close
     */

    /**
     * Constructs a new ChatServerEvent.
     * @exports ChatServerEvent
     * @classdesc Represents a ChatServerEvent.
     * @implements IChatServerEvent
     * @constructor
     * @param {IChatServerEvent=} [properties] Properties to set
     */
    function ChatServerEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatServerEvent open.
     * @member {ChatServerEvent.IOpen|null|undefined} open
     * @memberof ChatServerEvent
     * @instance
     */
    ChatServerEvent.prototype.open = null;

    /**
     * ChatServerEvent close.
     * @member {ChatServerEvent.IClose|null|undefined} close
     * @memberof ChatServerEvent
     * @instance
     */
    ChatServerEvent.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * ChatServerEvent body.
     * @member {"open"|"close"|undefined} body
     * @memberof ChatServerEvent
     * @instance
     */
    Object.defineProperty(ChatServerEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new ChatServerEvent instance using the specified properties.
     * @function create
     * @memberof ChatServerEvent
     * @static
     * @param {IChatServerEvent=} [properties] Properties to set
     * @returns {ChatServerEvent} ChatServerEvent instance
     */
    ChatServerEvent.create = function create(properties) {
        return new ChatServerEvent(properties);
    };

    /**
     * Encodes the specified ChatServerEvent message. Does not implicitly {@link ChatServerEvent.verify|verify} messages.
     * @function encode
     * @memberof ChatServerEvent
     * @static
     * @param {IChatServerEvent} message ChatServerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServerEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.ChatServerEvent.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.ChatServerEvent.Close.encode(message.close, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatServerEvent message, length delimited. Does not implicitly {@link ChatServerEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatServerEvent
     * @static
     * @param {IChatServerEvent} message ChatServerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServerEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatServerEvent message from the specified reader or buffer.
     * @function decode
     * @memberof ChatServerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatServerEvent} ChatServerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServerEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatServerEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.ChatServerEvent.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.close = $root.ChatServerEvent.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatServerEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatServerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatServerEvent} ChatServerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServerEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatServerEvent message.
     * @function verify
     * @memberof ChatServerEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatServerEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.ChatServerEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatServerEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ChatServerEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatServerEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatServerEvent} ChatServerEvent
     */
    ChatServerEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatServerEvent)
            return object;
        let message = new $root.ChatServerEvent();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".ChatServerEvent.open: object expected");
            message.open = $root.ChatServerEvent.Open.fromObject(object.open);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".ChatServerEvent.close: object expected");
            message.close = $root.ChatServerEvent.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatServerEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatServerEvent
     * @static
     * @param {ChatServerEvent} message ChatServerEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatServerEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.ChatServerEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.ChatServerEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this ChatServerEvent to JSON.
     * @function toJSON
     * @memberof ChatServerEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatServerEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ChatServerEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof ChatServerEvent
         * @interface IOpen
         * @property {number|null} [serverId] Open serverId
         */

        /**
         * Constructs a new Open.
         * @memberof ChatServerEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {ChatServerEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open serverId.
         * @member {number} serverId
         * @memberof ChatServerEvent.Open
         * @instance
         */
        Open.prototype.serverId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof ChatServerEvent.Open
         * @static
         * @param {ChatServerEvent.IOpen=} [properties] Properties to set
         * @returns {ChatServerEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link ChatServerEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof ChatServerEvent.Open
         * @static
         * @param {ChatServerEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && Object.hasOwnProperty.call(message, "serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serverId);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link ChatServerEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatServerEvent.Open
         * @static
         * @param {ChatServerEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof ChatServerEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatServerEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatServerEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatServerEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatServerEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof ChatServerEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId) && !(message.serverId && $util.isInteger(message.serverId.low) && $util.isInteger(message.serverId.high)))
                    return "serverId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatServerEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatServerEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatServerEvent.Open)
                return object;
            let message = new $root.ChatServerEvent.Open();
            if (object.serverId != null)
                if ($util.Long)
                    (message.serverId = $util.Long.fromValue(object.serverId)).unsigned = true;
                else if (typeof object.serverId === "string")
                    message.serverId = parseInt(object.serverId, 10);
                else if (typeof object.serverId === "number")
                    message.serverId = object.serverId;
                else if (typeof object.serverId === "object")
                    message.serverId = new $util.LongBits(object.serverId.low >>> 0, object.serverId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatServerEvent.Open
         * @static
         * @param {ChatServerEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serverId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverId = options.longs === String ? "0" : 0;
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (typeof message.serverId === "number")
                    object.serverId = options.longs === String ? String(message.serverId) : message.serverId;
                else
                    object.serverId = options.longs === String ? $util.Long.prototype.toString.call(message.serverId) : options.longs === Number ? new $util.LongBits(message.serverId.low >>> 0, message.serverId.high >>> 0).toNumber(true) : message.serverId;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof ChatServerEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    ChatServerEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof ChatServerEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof ChatServerEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {ChatServerEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof ChatServerEvent.Close
         * @static
         * @param {ChatServerEvent.IClose=} [properties] Properties to set
         * @returns {ChatServerEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link ChatServerEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof ChatServerEvent.Close
         * @static
         * @param {ChatServerEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link ChatServerEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatServerEvent.Close
         * @static
         * @param {ChatServerEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof ChatServerEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatServerEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatServerEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatServerEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatServerEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof ChatServerEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatServerEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatServerEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatServerEvent.Close)
                return object;
            return new $root.ChatServerEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatServerEvent.Close
         * @static
         * @param {ChatServerEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof ChatServerEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return ChatServerEvent;
})();

export const CallChatServerRequest = $root.CallChatServerRequest = (() => {

    /**
     * Properties of a CallChatServerRequest.
     * @exports ICallChatServerRequest
     * @interface ICallChatServerRequest
     * @property {number|null} [serverId] CallChatServerRequest serverId
     * @property {CallChatServerRequest.IClose|null} [close] CallChatServerRequest close
     */

    /**
     * Constructs a new CallChatServerRequest.
     * @exports CallChatServerRequest
     * @classdesc Represents a CallChatServerRequest.
     * @implements ICallChatServerRequest
     * @constructor
     * @param {ICallChatServerRequest=} [properties] Properties to set
     */
    function CallChatServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CallChatServerRequest serverId.
     * @member {number} serverId
     * @memberof CallChatServerRequest
     * @instance
     */
    CallChatServerRequest.prototype.serverId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * CallChatServerRequest close.
     * @member {CallChatServerRequest.IClose|null|undefined} close
     * @memberof CallChatServerRequest
     * @instance
     */
    CallChatServerRequest.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CallChatServerRequest body.
     * @member {"close"|undefined} body
     * @memberof CallChatServerRequest
     * @instance
     */
    Object.defineProperty(CallChatServerRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CallChatServerRequest instance using the specified properties.
     * @function create
     * @memberof CallChatServerRequest
     * @static
     * @param {ICallChatServerRequest=} [properties] Properties to set
     * @returns {CallChatServerRequest} CallChatServerRequest instance
     */
    CallChatServerRequest.create = function create(properties) {
        return new CallChatServerRequest(properties);
    };

    /**
     * Encodes the specified CallChatServerRequest message. Does not implicitly {@link CallChatServerRequest.verify|verify} messages.
     * @function encode
     * @memberof CallChatServerRequest
     * @static
     * @param {ICallChatServerRequest} message CallChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.serverId != null && Object.hasOwnProperty.call(message, "serverId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serverId);
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.CallChatServerRequest.Close.encode(message.close, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CallChatServerRequest message, length delimited. Does not implicitly {@link CallChatServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CallChatServerRequest
     * @static
     * @param {ICallChatServerRequest} message CallChatServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CallChatServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CallChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CallChatServerRequest} CallChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.serverId = reader.uint64();
                break;
            case 2:
                message.close = $root.CallChatServerRequest.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CallChatServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CallChatServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CallChatServerRequest} CallChatServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CallChatServerRequest message.
     * @function verify
     * @memberof CallChatServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CallChatServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.serverId != null && message.hasOwnProperty("serverId"))
            if (!$util.isInteger(message.serverId) && !(message.serverId && $util.isInteger(message.serverId.low) && $util.isInteger(message.serverId.high)))
                return "serverId: integer|Long expected";
        if (message.close != null && message.hasOwnProperty("close")) {
            properties.body = 1;
            {
                let error = $root.CallChatServerRequest.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CallChatServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CallChatServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CallChatServerRequest} CallChatServerRequest
     */
    CallChatServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CallChatServerRequest)
            return object;
        let message = new $root.CallChatServerRequest();
        if (object.serverId != null)
            if ($util.Long)
                (message.serverId = $util.Long.fromValue(object.serverId)).unsigned = true;
            else if (typeof object.serverId === "string")
                message.serverId = parseInt(object.serverId, 10);
            else if (typeof object.serverId === "number")
                message.serverId = object.serverId;
            else if (typeof object.serverId === "object")
                message.serverId = new $util.LongBits(object.serverId.low >>> 0, object.serverId.high >>> 0).toNumber(true);
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".CallChatServerRequest.close: object expected");
            message.close = $root.CallChatServerRequest.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a CallChatServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CallChatServerRequest
     * @static
     * @param {CallChatServerRequest} message CallChatServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CallChatServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.serverId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.serverId = options.longs === String ? "0" : 0;
        if (message.serverId != null && message.hasOwnProperty("serverId"))
            if (typeof message.serverId === "number")
                object.serverId = options.longs === String ? String(message.serverId) : message.serverId;
            else
                object.serverId = options.longs === String ? $util.Long.prototype.toString.call(message.serverId) : options.longs === Number ? new $util.LongBits(message.serverId.low >>> 0, message.serverId.high >>> 0).toNumber(true) : message.serverId;
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.CallChatServerRequest.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this CallChatServerRequest to JSON.
     * @function toJSON
     * @memberof CallChatServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CallChatServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    CallChatServerRequest.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof CallChatServerRequest
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof CallChatServerRequest
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {CallChatServerRequest.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {CallChatServerRequest.IClose=} [properties] Properties to set
         * @returns {CallChatServerRequest.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link CallChatServerRequest.Close.verify|verify} messages.
         * @function encode
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {CallChatServerRequest.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link CallChatServerRequest.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {CallChatServerRequest.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CallChatServerRequest.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatServerRequest.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CallChatServerRequest.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CallChatServerRequest.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.CallChatServerRequest.Close)
                return object;
            return new $root.CallChatServerRequest.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CallChatServerRequest.Close
         * @static
         * @param {CallChatServerRequest.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof CallChatServerRequest.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return CallChatServerRequest;
})();

export const OpenChatClientRequest = $root.OpenChatClientRequest = (() => {

    /**
     * Properties of an OpenChatClientRequest.
     * @exports IOpenChatClientRequest
     * @interface IOpenChatClientRequest
     * @property {Uint8Array|null} [networkKey] OpenChatClientRequest networkKey
     * @property {Uint8Array|null} [serverKey] OpenChatClientRequest serverKey
     */

    /**
     * Constructs a new OpenChatClientRequest.
     * @exports OpenChatClientRequest
     * @classdesc Represents an OpenChatClientRequest.
     * @implements IOpenChatClientRequest
     * @constructor
     * @param {IOpenChatClientRequest=} [properties] Properties to set
     */
    function OpenChatClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenChatClientRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof OpenChatClientRequest
     * @instance
     */
    OpenChatClientRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * OpenChatClientRequest serverKey.
     * @member {Uint8Array} serverKey
     * @memberof OpenChatClientRequest
     * @instance
     */
    OpenChatClientRequest.prototype.serverKey = $util.newBuffer([]);

    /**
     * Creates a new OpenChatClientRequest instance using the specified properties.
     * @function create
     * @memberof OpenChatClientRequest
     * @static
     * @param {IOpenChatClientRequest=} [properties] Properties to set
     * @returns {OpenChatClientRequest} OpenChatClientRequest instance
     */
    OpenChatClientRequest.create = function create(properties) {
        return new OpenChatClientRequest(properties);
    };

    /**
     * Encodes the specified OpenChatClientRequest message. Does not implicitly {@link OpenChatClientRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenChatClientRequest
     * @static
     * @param {IOpenChatClientRequest} message OpenChatClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenChatClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKey);
        if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverKey);
        return writer;
    };

    /**
     * Encodes the specified OpenChatClientRequest message, length delimited. Does not implicitly {@link OpenChatClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenChatClientRequest
     * @static
     * @param {IOpenChatClientRequest} message OpenChatClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenChatClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenChatClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenChatClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenChatClientRequest} OpenChatClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenChatClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenChatClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkKey = reader.bytes();
                break;
            case 2:
                message.serverKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenChatClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenChatClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenChatClientRequest} OpenChatClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenChatClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenChatClientRequest message.
     * @function verify
     * @memberof OpenChatClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenChatClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.serverKey != null && message.hasOwnProperty("serverKey"))
            if (!(message.serverKey && typeof message.serverKey.length === "number" || $util.isString(message.serverKey)))
                return "serverKey: buffer expected";
        return null;
    };

    /**
     * Creates an OpenChatClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenChatClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenChatClientRequest} OpenChatClientRequest
     */
    OpenChatClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenChatClientRequest)
            return object;
        let message = new $root.OpenChatClientRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.serverKey != null)
            if (typeof object.serverKey === "string")
                $util.base64.decode(object.serverKey, message.serverKey = $util.newBuffer($util.base64.length(object.serverKey)), 0);
            else if (object.serverKey.length)
                message.serverKey = object.serverKey;
        return message;
    };

    /**
     * Creates a plain object from an OpenChatClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenChatClientRequest
     * @static
     * @param {OpenChatClientRequest} message OpenChatClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenChatClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            if (options.bytes === String)
                object.serverKey = "";
            else {
                object.serverKey = [];
                if (options.bytes !== Array)
                    object.serverKey = $util.newBuffer(object.serverKey);
            }
        }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.serverKey != null && message.hasOwnProperty("serverKey"))
            object.serverKey = options.bytes === String ? $util.base64.encode(message.serverKey, 0, message.serverKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverKey) : message.serverKey;
        return object;
    };

    /**
     * Converts this OpenChatClientRequest to JSON.
     * @function toJSON
     * @memberof OpenChatClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenChatClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OpenChatClientRequest;
})();

export const ChatClientEvent = $root.ChatClientEvent = (() => {

    /**
     * Properties of a ChatClientEvent.
     * @exports IChatClientEvent
     * @interface IChatClientEvent
     * @property {ChatClientEvent.IOpen|null} [open] ChatClientEvent open
     * @property {ChatClientEvent.IMessage|null} [message] ChatClientEvent message
     * @property {ChatClientEvent.IClose|null} [close] ChatClientEvent close
     */

    /**
     * Constructs a new ChatClientEvent.
     * @exports ChatClientEvent
     * @classdesc Represents a ChatClientEvent.
     * @implements IChatClientEvent
     * @constructor
     * @param {IChatClientEvent=} [properties] Properties to set
     */
    function ChatClientEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatClientEvent open.
     * @member {ChatClientEvent.IOpen|null|undefined} open
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.open = null;

    /**
     * ChatClientEvent message.
     * @member {ChatClientEvent.IMessage|null|undefined} message
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.message = null;

    /**
     * ChatClientEvent close.
     * @member {ChatClientEvent.IClose|null|undefined} close
     * @memberof ChatClientEvent
     * @instance
     */
    ChatClientEvent.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * ChatClientEvent body.
     * @member {"open"|"message"|"close"|undefined} body
     * @memberof ChatClientEvent
     * @instance
     */
    Object.defineProperty(ChatClientEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "message", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new ChatClientEvent instance using the specified properties.
     * @function create
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent=} [properties] Properties to set
     * @returns {ChatClientEvent} ChatClientEvent instance
     */
    ChatClientEvent.create = function create(properties) {
        return new ChatClientEvent(properties);
    };

    /**
     * Encodes the specified ChatClientEvent message. Does not implicitly {@link ChatClientEvent.verify|verify} messages.
     * @function encode
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent} message ChatClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.ChatClientEvent.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.ChatClientEvent.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.ChatClientEvent.Close.encode(message.close, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatClientEvent message, length delimited. Does not implicitly {@link ChatClientEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatClientEvent
     * @static
     * @param {IChatClientEvent} message ChatClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatClientEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatClientEvent message from the specified reader or buffer.
     * @function decode
     * @memberof ChatClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatClientEvent} ChatClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.ChatClientEvent.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.message = $root.ChatClientEvent.Message.decode(reader, reader.uint32());
                break;
            case 3:
                message.close = $root.ChatClientEvent.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatClientEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatClientEvent} ChatClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatClientEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatClientEvent message.
     * @function verify
     * @memberof ChatClientEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatClientEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.message != null && message.hasOwnProperty("message")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.ChatClientEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ChatClientEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatClientEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatClientEvent} ChatClientEvent
     */
    ChatClientEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatClientEvent)
            return object;
        let message = new $root.ChatClientEvent();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".ChatClientEvent.open: object expected");
            message.open = $root.ChatClientEvent.Open.fromObject(object.open);
        }
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".ChatClientEvent.message: object expected");
            message.message = $root.ChatClientEvent.Message.fromObject(object.message);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".ChatClientEvent.close: object expected");
            message.close = $root.ChatClientEvent.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatClientEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatClientEvent
     * @static
     * @param {ChatClientEvent} message ChatClientEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatClientEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.ChatClientEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.ChatClientEvent.Message.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.ChatClientEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this ChatClientEvent to JSON.
     * @function toJSON
     * @memberof ChatClientEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatClientEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ChatClientEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof ChatClientEvent
         * @interface IOpen
         * @property {number|null} [clientId] Open clientId
         */

        /**
         * Constructs a new Open.
         * @memberof ChatClientEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {ChatClientEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open clientId.
         * @member {number} clientId
         * @memberof ChatClientEvent.Open
         * @instance
         */
        Open.prototype.clientId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen=} [properties] Properties to set
         * @returns {ChatClientEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link ChatClientEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.clientId);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link ChatClientEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof ChatClientEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                if (!$util.isInteger(message.clientId) && !(message.clientId && $util.isInteger(message.clientId.low) && $util.isInteger(message.clientId.high)))
                    return "clientId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Open)
                return object;
            let message = new $root.ChatClientEvent.Open();
            if (object.clientId != null)
                if ($util.Long)
                    (message.clientId = $util.Long.fromValue(object.clientId)).unsigned = true;
                else if (typeof object.clientId === "string")
                    message.clientId = parseInt(object.clientId, 10);
                else if (typeof object.clientId === "number")
                    message.clientId = object.clientId;
                else if (typeof object.clientId === "object")
                    message.clientId = new $util.LongBits(object.clientId.low >>> 0, object.clientId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Open
         * @static
         * @param {ChatClientEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.clientId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientId = options.longs === String ? "0" : 0;
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                if (typeof message.clientId === "number")
                    object.clientId = options.longs === String ? String(message.clientId) : message.clientId;
                else
                    object.clientId = options.longs === String ? $util.Long.prototype.toString.call(message.clientId) : options.longs === Number ? new $util.LongBits(message.clientId.low >>> 0, message.clientId.high >>> 0).toNumber(true) : message.clientId;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    ChatClientEvent.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof ChatClientEvent
         * @interface IMessage
         * @property {number|null} [sentTime] Message sentTime
         * @property {number|null} [serverTime] Message serverTime
         * @property {string|null} [nick] Message nick
         * @property {string|null} [body] Message body
         * @property {IMessageEntities|null} [entities] Message entities
         */

        /**
         * Constructs a new Message.
         * @memberof ChatClientEvent
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {ChatClientEvent.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message sentTime.
         * @member {number} sentTime
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.sentTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message serverTime.
         * @member {number} serverTime
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message nick.
         * @member {string} nick
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.nick = "";

        /**
         * Message body.
         * @member {string} body
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.body = "";

        /**
         * Message entities.
         * @member {IMessageEntities|null|undefined} entities
         * @memberof ChatClientEvent.Message
         * @instance
         */
        Message.prototype.entities = null;

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage=} [properties] Properties to set
         * @returns {ChatClientEvent.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link ChatClientEvent.Message.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sentTime);
            if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.serverTime);
            if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.body);
            if (message.entities != null && Object.hasOwnProperty.call(message, "entities"))
                $root.MessageEntities.encode(message.entities, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link ChatClientEvent.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sentTime = reader.int64();
                    break;
                case 2:
                    message.serverTime = reader.int64();
                    break;
                case 3:
                    message.nick = reader.string();
                    break;
                case 4:
                    message.body = reader.string();
                    break;
                case 5:
                    message.entities = $root.MessageEntities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof ChatClientEvent.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
                if (!$util.isInteger(message.sentTime) && !(message.sentTime && $util.isInteger(message.sentTime.low) && $util.isInteger(message.sentTime.high)))
                    return "sentTime: integer|Long expected";
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                    return "serverTime: integer|Long expected";
            if (message.nick != null && message.hasOwnProperty("nick"))
                if (!$util.isString(message.nick))
                    return "nick: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            if (message.entities != null && message.hasOwnProperty("entities")) {
                let error = $root.MessageEntities.verify(message.entities);
                if (error)
                    return "entities." + error;
            }
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Message)
                return object;
            let message = new $root.ChatClientEvent.Message();
            if (object.sentTime != null)
                if ($util.Long)
                    (message.sentTime = $util.Long.fromValue(object.sentTime)).unsigned = false;
                else if (typeof object.sentTime === "string")
                    message.sentTime = parseInt(object.sentTime, 10);
                else if (typeof object.sentTime === "number")
                    message.sentTime = object.sentTime;
                else if (typeof object.sentTime === "object")
                    message.sentTime = new $util.LongBits(object.sentTime.low >>> 0, object.sentTime.high >>> 0).toNumber();
            if (object.serverTime != null)
                if ($util.Long)
                    (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                else if (typeof object.serverTime === "string")
                    message.serverTime = parseInt(object.serverTime, 10);
                else if (typeof object.serverTime === "number")
                    message.serverTime = object.serverTime;
                else if (typeof object.serverTime === "object")
                    message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
            if (object.nick != null)
                message.nick = String(object.nick);
            if (object.body != null)
                message.body = String(object.body);
            if (object.entities != null) {
                if (typeof object.entities !== "object")
                    throw TypeError(".ChatClientEvent.Message.entities: object expected");
                message.entities = $root.MessageEntities.fromObject(object.entities);
            }
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Message
         * @static
         * @param {ChatClientEvent.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sentTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sentTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTime = options.longs === String ? "0" : 0;
                object.nick = "";
                object.body = "";
                object.entities = null;
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
                if (typeof message.sentTime === "number")
                    object.sentTime = options.longs === String ? String(message.sentTime) : message.sentTime;
                else
                    object.sentTime = options.longs === String ? $util.Long.prototype.toString.call(message.sentTime) : options.longs === Number ? new $util.LongBits(message.sentTime.low >>> 0, message.sentTime.high >>> 0).toNumber() : message.sentTime;
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (typeof message.serverTime === "number")
                    object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                else
                    object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
            if (message.nick != null && message.hasOwnProperty("nick"))
                object.nick = message.nick;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.entities != null && message.hasOwnProperty("entities"))
                object.entities = $root.MessageEntities.toObject(message.entities, options);
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    ChatClientEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof ChatClientEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof ChatClientEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {ChatClientEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose=} [properties] Properties to set
         * @returns {ChatClientEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link ChatClientEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link ChatClientEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof ChatClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatClientEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof ChatClientEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatClientEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatClientEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatClientEvent.Close)
                return object;
            return new $root.ChatClientEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatClientEvent.Close
         * @static
         * @param {ChatClientEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof ChatClientEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return ChatClientEvent;
})();

export const ChatRoom = $root.ChatRoom = (() => {

    /**
     * Properties of a ChatRoom.
     * @exports IChatRoom
     * @interface IChatRoom
     * @property {string|null} [name] ChatRoom name
     */

    /**
     * Constructs a new ChatRoom.
     * @exports ChatRoom
     * @classdesc Represents a ChatRoom.
     * @implements IChatRoom
     * @constructor
     * @param {IChatRoom=} [properties] Properties to set
     */
    function ChatRoom(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatRoom name.
     * @member {string} name
     * @memberof ChatRoom
     * @instance
     */
    ChatRoom.prototype.name = "";

    /**
     * Creates a new ChatRoom instance using the specified properties.
     * @function create
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom=} [properties] Properties to set
     * @returns {ChatRoom} ChatRoom instance
     */
    ChatRoom.create = function create(properties) {
        return new ChatRoom(properties);
    };

    /**
     * Encodes the specified ChatRoom message. Does not implicitly {@link ChatRoom.verify|verify} messages.
     * @function encode
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom} message ChatRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatRoom.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified ChatRoom message, length delimited. Does not implicitly {@link ChatRoom.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatRoom
     * @static
     * @param {IChatRoom} message ChatRoom message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatRoom.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatRoom message from the specified reader or buffer.
     * @function decode
     * @memberof ChatRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatRoom} ChatRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatRoom.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatRoom();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatRoom message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatRoom
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatRoom} ChatRoom
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatRoom.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatRoom message.
     * @function verify
     * @memberof ChatRoom
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatRoom.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates a ChatRoom message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatRoom
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatRoom} ChatRoom
     */
    ChatRoom.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatRoom)
            return object;
        let message = new $root.ChatRoom();
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from a ChatRoom message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatRoom
     * @static
     * @param {ChatRoom} message ChatRoom
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatRoom.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.name = "";
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this ChatRoom to JSON.
     * @function toJSON
     * @memberof ChatRoom
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatRoom.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatRoom;
})();

export const ChatServer = $root.ChatServer = (() => {

    /**
     * Properties of a ChatServer.
     * @exports IChatServer
     * @interface IChatServer
     * @property {number|null} [id] ChatServer id
     * @property {Uint8Array|null} [networkKey] ChatServer networkKey
     * @property {IKey|null} [key] ChatServer key
     * @property {IChatRoom|null} [chatRoom] ChatServer chatRoom
     */

    /**
     * Constructs a new ChatServer.
     * @exports ChatServer
     * @classdesc Represents a ChatServer.
     * @implements IChatServer
     * @constructor
     * @param {IChatServer=} [properties] Properties to set
     */
    function ChatServer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatServer id.
     * @member {number} id
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ChatServer networkKey.
     * @member {Uint8Array} networkKey
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.networkKey = $util.newBuffer([]);

    /**
     * ChatServer key.
     * @member {IKey|null|undefined} key
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.key = null;

    /**
     * ChatServer chatRoom.
     * @member {IChatRoom|null|undefined} chatRoom
     * @memberof ChatServer
     * @instance
     */
    ChatServer.prototype.chatRoom = null;

    /**
     * Creates a new ChatServer instance using the specified properties.
     * @function create
     * @memberof ChatServer
     * @static
     * @param {IChatServer=} [properties] Properties to set
     * @returns {ChatServer} ChatServer instance
     */
    ChatServer.create = function create(properties) {
        return new ChatServer(properties);
    };

    /**
     * Encodes the specified ChatServer message. Does not implicitly {@link ChatServer.verify|verify} messages.
     * @function encode
     * @memberof ChatServer
     * @static
     * @param {IChatServer} message ChatServer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.chatRoom != null && Object.hasOwnProperty.call(message, "chatRoom"))
            $root.ChatRoom.encode(message.chatRoom, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatServer message, length delimited. Does not implicitly {@link ChatServer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatServer
     * @static
     * @param {IChatServer} message ChatServer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatServer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatServer message from the specified reader or buffer.
     * @function decode
     * @memberof ChatServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatServer} ChatServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatServer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.networkKey = reader.bytes();
                break;
            case 3:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 4:
                message.chatRoom = $root.ChatRoom.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatServer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatServer} ChatServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatServer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatServer message.
     * @function verify
     * @memberof ChatServer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatServer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom")) {
            let error = $root.ChatRoom.verify(message.chatRoom);
            if (error)
                return "chatRoom." + error;
        }
        return null;
    };

    /**
     * Creates a ChatServer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatServer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatServer} ChatServer
     */
    ChatServer.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatServer)
            return object;
        let message = new $root.ChatServer();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".ChatServer.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.chatRoom != null) {
            if (typeof object.chatRoom !== "object")
                throw TypeError(".ChatServer.chatRoom: object expected");
            message.chatRoom = $root.ChatRoom.fromObject(object.chatRoom);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatServer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatServer
     * @static
     * @param {ChatServer} message ChatServer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatServer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            object.key = null;
            object.chatRoom = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.chatRoom != null && message.hasOwnProperty("chatRoom"))
            object.chatRoom = $root.ChatRoom.toObject(message.chatRoom, options);
        return object;
    };

    /**
     * Converts this ChatServer to JSON.
     * @function toJSON
     * @memberof ChatServer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatServer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatServer;
})();

export const MessageEntities = $root.MessageEntities = (() => {

    /**
     * Properties of a MessageEntities.
     * @exports IMessageEntities
     * @interface IMessageEntities
     * @property {Array.<MessageEntities.ILink>|null} [links] MessageEntities links
     * @property {Array.<MessageEntities.IEmote>|null} [emotes] MessageEntities emotes
     * @property {Array.<MessageEntities.INick>|null} [nicks] MessageEntities nicks
     * @property {Array.<MessageEntities.ITag>|null} [tags] MessageEntities tags
     * @property {Array.<MessageEntities.ICodeBlock>|null} [codeBlocks] MessageEntities codeBlocks
     * @property {Array.<MessageEntities.ISpoiler>|null} [spoilers] MessageEntities spoilers
     * @property {MessageEntities.IGenericEntity|null} [greenText] MessageEntities greenText
     * @property {MessageEntities.IGenericEntity|null} [selfMessage] MessageEntities selfMessage
     */

    /**
     * Constructs a new MessageEntities.
     * @exports MessageEntities
     * @classdesc Represents a MessageEntities.
     * @implements IMessageEntities
     * @constructor
     * @param {IMessageEntities=} [properties] Properties to set
     */
    function MessageEntities(properties) {
        this.links = [];
        this.emotes = [];
        this.nicks = [];
        this.tags = [];
        this.codeBlocks = [];
        this.spoilers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MessageEntities links.
     * @member {Array.<MessageEntities.ILink>} links
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.links = $util.emptyArray;

    /**
     * MessageEntities emotes.
     * @member {Array.<MessageEntities.IEmote>} emotes
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.emotes = $util.emptyArray;

    /**
     * MessageEntities nicks.
     * @member {Array.<MessageEntities.INick>} nicks
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.nicks = $util.emptyArray;

    /**
     * MessageEntities tags.
     * @member {Array.<MessageEntities.ITag>} tags
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.tags = $util.emptyArray;

    /**
     * MessageEntities codeBlocks.
     * @member {Array.<MessageEntities.ICodeBlock>} codeBlocks
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.codeBlocks = $util.emptyArray;

    /**
     * MessageEntities spoilers.
     * @member {Array.<MessageEntities.ISpoiler>} spoilers
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.spoilers = $util.emptyArray;

    /**
     * MessageEntities greenText.
     * @member {MessageEntities.IGenericEntity|null|undefined} greenText
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.greenText = null;

    /**
     * MessageEntities selfMessage.
     * @member {MessageEntities.IGenericEntity|null|undefined} selfMessage
     * @memberof MessageEntities
     * @instance
     */
    MessageEntities.prototype.selfMessage = null;

    /**
     * Creates a new MessageEntities instance using the specified properties.
     * @function create
     * @memberof MessageEntities
     * @static
     * @param {IMessageEntities=} [properties] Properties to set
     * @returns {MessageEntities} MessageEntities instance
     */
    MessageEntities.create = function create(properties) {
        return new MessageEntities(properties);
    };

    /**
     * Encodes the specified MessageEntities message. Does not implicitly {@link MessageEntities.verify|verify} messages.
     * @function encode
     * @memberof MessageEntities
     * @static
     * @param {IMessageEntities} message MessageEntities message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MessageEntities.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.links != null && message.links.length)
            for (let i = 0; i < message.links.length; ++i)
                $root.MessageEntities.Link.encode(message.links[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.emotes != null && message.emotes.length)
            for (let i = 0; i < message.emotes.length; ++i)
                $root.MessageEntities.Emote.encode(message.emotes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.nicks != null && message.nicks.length)
            for (let i = 0; i < message.nicks.length; ++i)
                $root.MessageEntities.Nick.encode(message.nicks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.tags != null && message.tags.length)
            for (let i = 0; i < message.tags.length; ++i)
                $root.MessageEntities.Tag.encode(message.tags[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.codeBlocks != null && message.codeBlocks.length)
            for (let i = 0; i < message.codeBlocks.length; ++i)
                $root.MessageEntities.CodeBlock.encode(message.codeBlocks[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.spoilers != null && message.spoilers.length)
            for (let i = 0; i < message.spoilers.length; ++i)
                $root.MessageEntities.Spoiler.encode(message.spoilers[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.greenText != null && Object.hasOwnProperty.call(message, "greenText"))
            $root.MessageEntities.GenericEntity.encode(message.greenText, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.selfMessage != null && Object.hasOwnProperty.call(message, "selfMessage"))
            $root.MessageEntities.GenericEntity.encode(message.selfMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MessageEntities message, length delimited. Does not implicitly {@link MessageEntities.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MessageEntities
     * @static
     * @param {IMessageEntities} message MessageEntities message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MessageEntities.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MessageEntities message from the specified reader or buffer.
     * @function decode
     * @memberof MessageEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MessageEntities} MessageEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MessageEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.links && message.links.length))
                    message.links = [];
                message.links.push($root.MessageEntities.Link.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.emotes && message.emotes.length))
                    message.emotes = [];
                message.emotes.push($root.MessageEntities.Emote.decode(reader, reader.uint32()));
                break;
            case 3:
                if (!(message.nicks && message.nicks.length))
                    message.nicks = [];
                message.nicks.push($root.MessageEntities.Nick.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.tags && message.tags.length))
                    message.tags = [];
                message.tags.push($root.MessageEntities.Tag.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.codeBlocks && message.codeBlocks.length))
                    message.codeBlocks = [];
                message.codeBlocks.push($root.MessageEntities.CodeBlock.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.spoilers && message.spoilers.length))
                    message.spoilers = [];
                message.spoilers.push($root.MessageEntities.Spoiler.decode(reader, reader.uint32()));
                break;
            case 7:
                message.greenText = $root.MessageEntities.GenericEntity.decode(reader, reader.uint32());
                break;
            case 8:
                message.selfMessage = $root.MessageEntities.GenericEntity.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MessageEntities message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MessageEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MessageEntities} MessageEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MessageEntities.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MessageEntities message.
     * @function verify
     * @memberof MessageEntities
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MessageEntities.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.links != null && message.hasOwnProperty("links")) {
            if (!Array.isArray(message.links))
                return "links: array expected";
            for (let i = 0; i < message.links.length; ++i) {
                let error = $root.MessageEntities.Link.verify(message.links[i]);
                if (error)
                    return "links." + error;
            }
        }
        if (message.emotes != null && message.hasOwnProperty("emotes")) {
            if (!Array.isArray(message.emotes))
                return "emotes: array expected";
            for (let i = 0; i < message.emotes.length; ++i) {
                let error = $root.MessageEntities.Emote.verify(message.emotes[i]);
                if (error)
                    return "emotes." + error;
            }
        }
        if (message.nicks != null && message.hasOwnProperty("nicks")) {
            if (!Array.isArray(message.nicks))
                return "nicks: array expected";
            for (let i = 0; i < message.nicks.length; ++i) {
                let error = $root.MessageEntities.Nick.verify(message.nicks[i]);
                if (error)
                    return "nicks." + error;
            }
        }
        if (message.tags != null && message.hasOwnProperty("tags")) {
            if (!Array.isArray(message.tags))
                return "tags: array expected";
            for (let i = 0; i < message.tags.length; ++i) {
                let error = $root.MessageEntities.Tag.verify(message.tags[i]);
                if (error)
                    return "tags." + error;
            }
        }
        if (message.codeBlocks != null && message.hasOwnProperty("codeBlocks")) {
            if (!Array.isArray(message.codeBlocks))
                return "codeBlocks: array expected";
            for (let i = 0; i < message.codeBlocks.length; ++i) {
                let error = $root.MessageEntities.CodeBlock.verify(message.codeBlocks[i]);
                if (error)
                    return "codeBlocks." + error;
            }
        }
        if (message.spoilers != null && message.hasOwnProperty("spoilers")) {
            if (!Array.isArray(message.spoilers))
                return "spoilers: array expected";
            for (let i = 0; i < message.spoilers.length; ++i) {
                let error = $root.MessageEntities.Spoiler.verify(message.spoilers[i]);
                if (error)
                    return "spoilers." + error;
            }
        }
        if (message.greenText != null && message.hasOwnProperty("greenText")) {
            let error = $root.MessageEntities.GenericEntity.verify(message.greenText);
            if (error)
                return "greenText." + error;
        }
        if (message.selfMessage != null && message.hasOwnProperty("selfMessage")) {
            let error = $root.MessageEntities.GenericEntity.verify(message.selfMessage);
            if (error)
                return "selfMessage." + error;
        }
        return null;
    };

    /**
     * Creates a MessageEntities message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MessageEntities
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MessageEntities} MessageEntities
     */
    MessageEntities.fromObject = function fromObject(object) {
        if (object instanceof $root.MessageEntities)
            return object;
        let message = new $root.MessageEntities();
        if (object.links) {
            if (!Array.isArray(object.links))
                throw TypeError(".MessageEntities.links: array expected");
            message.links = [];
            for (let i = 0; i < object.links.length; ++i) {
                if (typeof object.links[i] !== "object")
                    throw TypeError(".MessageEntities.links: object expected");
                message.links[i] = $root.MessageEntities.Link.fromObject(object.links[i]);
            }
        }
        if (object.emotes) {
            if (!Array.isArray(object.emotes))
                throw TypeError(".MessageEntities.emotes: array expected");
            message.emotes = [];
            for (let i = 0; i < object.emotes.length; ++i) {
                if (typeof object.emotes[i] !== "object")
                    throw TypeError(".MessageEntities.emotes: object expected");
                message.emotes[i] = $root.MessageEntities.Emote.fromObject(object.emotes[i]);
            }
        }
        if (object.nicks) {
            if (!Array.isArray(object.nicks))
                throw TypeError(".MessageEntities.nicks: array expected");
            message.nicks = [];
            for (let i = 0; i < object.nicks.length; ++i) {
                if (typeof object.nicks[i] !== "object")
                    throw TypeError(".MessageEntities.nicks: object expected");
                message.nicks[i] = $root.MessageEntities.Nick.fromObject(object.nicks[i]);
            }
        }
        if (object.tags) {
            if (!Array.isArray(object.tags))
                throw TypeError(".MessageEntities.tags: array expected");
            message.tags = [];
            for (let i = 0; i < object.tags.length; ++i) {
                if (typeof object.tags[i] !== "object")
                    throw TypeError(".MessageEntities.tags: object expected");
                message.tags[i] = $root.MessageEntities.Tag.fromObject(object.tags[i]);
            }
        }
        if (object.codeBlocks) {
            if (!Array.isArray(object.codeBlocks))
                throw TypeError(".MessageEntities.codeBlocks: array expected");
            message.codeBlocks = [];
            for (let i = 0; i < object.codeBlocks.length; ++i) {
                if (typeof object.codeBlocks[i] !== "object")
                    throw TypeError(".MessageEntities.codeBlocks: object expected");
                message.codeBlocks[i] = $root.MessageEntities.CodeBlock.fromObject(object.codeBlocks[i]);
            }
        }
        if (object.spoilers) {
            if (!Array.isArray(object.spoilers))
                throw TypeError(".MessageEntities.spoilers: array expected");
            message.spoilers = [];
            for (let i = 0; i < object.spoilers.length; ++i) {
                if (typeof object.spoilers[i] !== "object")
                    throw TypeError(".MessageEntities.spoilers: object expected");
                message.spoilers[i] = $root.MessageEntities.Spoiler.fromObject(object.spoilers[i]);
            }
        }
        if (object.greenText != null) {
            if (typeof object.greenText !== "object")
                throw TypeError(".MessageEntities.greenText: object expected");
            message.greenText = $root.MessageEntities.GenericEntity.fromObject(object.greenText);
        }
        if (object.selfMessage != null) {
            if (typeof object.selfMessage !== "object")
                throw TypeError(".MessageEntities.selfMessage: object expected");
            message.selfMessage = $root.MessageEntities.GenericEntity.fromObject(object.selfMessage);
        }
        return message;
    };

    /**
     * Creates a plain object from a MessageEntities message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MessageEntities
     * @static
     * @param {MessageEntities} message MessageEntities
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MessageEntities.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.links = [];
            object.emotes = [];
            object.nicks = [];
            object.tags = [];
            object.codeBlocks = [];
            object.spoilers = [];
        }
        if (options.defaults) {
            object.greenText = null;
            object.selfMessage = null;
        }
        if (message.links && message.links.length) {
            object.links = [];
            for (let j = 0; j < message.links.length; ++j)
                object.links[j] = $root.MessageEntities.Link.toObject(message.links[j], options);
        }
        if (message.emotes && message.emotes.length) {
            object.emotes = [];
            for (let j = 0; j < message.emotes.length; ++j)
                object.emotes[j] = $root.MessageEntities.Emote.toObject(message.emotes[j], options);
        }
        if (message.nicks && message.nicks.length) {
            object.nicks = [];
            for (let j = 0; j < message.nicks.length; ++j)
                object.nicks[j] = $root.MessageEntities.Nick.toObject(message.nicks[j], options);
        }
        if (message.tags && message.tags.length) {
            object.tags = [];
            for (let j = 0; j < message.tags.length; ++j)
                object.tags[j] = $root.MessageEntities.Tag.toObject(message.tags[j], options);
        }
        if (message.codeBlocks && message.codeBlocks.length) {
            object.codeBlocks = [];
            for (let j = 0; j < message.codeBlocks.length; ++j)
                object.codeBlocks[j] = $root.MessageEntities.CodeBlock.toObject(message.codeBlocks[j], options);
        }
        if (message.spoilers && message.spoilers.length) {
            object.spoilers = [];
            for (let j = 0; j < message.spoilers.length; ++j)
                object.spoilers[j] = $root.MessageEntities.Spoiler.toObject(message.spoilers[j], options);
        }
        if (message.greenText != null && message.hasOwnProperty("greenText"))
            object.greenText = $root.MessageEntities.GenericEntity.toObject(message.greenText, options);
        if (message.selfMessage != null && message.hasOwnProperty("selfMessage"))
            object.selfMessage = $root.MessageEntities.GenericEntity.toObject(message.selfMessage, options);
        return object;
    };

    /**
     * Converts this MessageEntities to JSON.
     * @function toJSON
     * @memberof MessageEntities
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MessageEntities.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    MessageEntities.Bounds = (function() {

        /**
         * Properties of a Bounds.
         * @memberof MessageEntities
         * @interface IBounds
         * @property {number|null} [start] Bounds start
         * @property {number|null} [end] Bounds end
         */

        /**
         * Constructs a new Bounds.
         * @memberof MessageEntities
         * @classdesc Represents a Bounds.
         * @implements IBounds
         * @constructor
         * @param {MessageEntities.IBounds=} [properties] Properties to set
         */
        function Bounds(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Bounds start.
         * @member {number} start
         * @memberof MessageEntities.Bounds
         * @instance
         */
        Bounds.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Bounds end.
         * @member {number} end
         * @memberof MessageEntities.Bounds
         * @instance
         */
        Bounds.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Bounds instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Bounds
         * @static
         * @param {MessageEntities.IBounds=} [properties] Properties to set
         * @returns {MessageEntities.Bounds} Bounds instance
         */
        Bounds.create = function create(properties) {
            return new Bounds(properties);
        };

        /**
         * Encodes the specified Bounds message. Does not implicitly {@link MessageEntities.Bounds.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Bounds
         * @static
         * @param {MessageEntities.IBounds} message Bounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Bounds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);
            return writer;
        };

        /**
         * Encodes the specified Bounds message, length delimited. Does not implicitly {@link MessageEntities.Bounds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Bounds
         * @static
         * @param {MessageEntities.IBounds} message Bounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Bounds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Bounds message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Bounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Bounds} Bounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Bounds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Bounds();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.start = reader.int64();
                    break;
                case 2:
                    message.end = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Bounds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Bounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Bounds} Bounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Bounds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Bounds message.
         * @function verify
         * @memberof MessageEntities.Bounds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Bounds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                    return "start: integer|Long expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                    return "end: integer|Long expected";
            return null;
        };

        /**
         * Creates a Bounds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Bounds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Bounds} Bounds
         */
        Bounds.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Bounds)
                return object;
            let message = new $root.MessageEntities.Bounds();
            if (object.start != null)
                if ($util.Long)
                    (message.start = $util.Long.fromValue(object.start)).unsigned = false;
                else if (typeof object.start === "string")
                    message.start = parseInt(object.start, 10);
                else if (typeof object.start === "number")
                    message.start = object.start;
                else if (typeof object.start === "object")
                    message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
            if (object.end != null)
                if ($util.Long)
                    (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                else if (typeof object.end === "string")
                    message.end = parseInt(object.end, 10);
                else if (typeof object.end === "number")
                    message.end = object.end;
                else if (typeof object.end === "object")
                    message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Bounds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Bounds
         * @static
         * @param {MessageEntities.Bounds} message Bounds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Bounds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.start = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.end = options.longs === String ? "0" : 0;
            }
            if (message.start != null && message.hasOwnProperty("start"))
                if (typeof message.start === "number")
                    object.start = options.longs === String ? String(message.start) : message.start;
                else
                    object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end === "number")
                    object.end = options.longs === String ? String(message.end) : message.end;
                else
                    object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
            return object;
        };

        /**
         * Converts this Bounds to JSON.
         * @function toJSON
         * @memberof MessageEntities.Bounds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Bounds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Bounds;
    })();

    MessageEntities.Link = (function() {

        /**
         * Properties of a Link.
         * @memberof MessageEntities
         * @interface ILink
         * @property {MessageEntities.IBounds|null} [bounds] Link bounds
         * @property {string|null} [url] Link url
         */

        /**
         * Constructs a new Link.
         * @memberof MessageEntities
         * @classdesc Represents a Link.
         * @implements ILink
         * @constructor
         * @param {MessageEntities.ILink=} [properties] Properties to set
         */
        function Link(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Link bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.Link
         * @instance
         */
        Link.prototype.bounds = null;

        /**
         * Link url.
         * @member {string} url
         * @memberof MessageEntities.Link
         * @instance
         */
        Link.prototype.url = "";

        /**
         * Creates a new Link instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Link
         * @static
         * @param {MessageEntities.ILink=} [properties] Properties to set
         * @returns {MessageEntities.Link} Link instance
         */
        Link.create = function create(properties) {
            return new Link(properties);
        };

        /**
         * Encodes the specified Link message. Does not implicitly {@link MessageEntities.Link.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Link
         * @static
         * @param {MessageEntities.ILink} message Link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Link.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified Link message, length delimited. Does not implicitly {@link MessageEntities.Link.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Link
         * @static
         * @param {MessageEntities.ILink} message Link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Link.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Link message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Link} Link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Link.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Link();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Link message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Link} Link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Link.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Link message.
         * @function verify
         * @memberof MessageEntities.Link
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Link.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a Link message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Link
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Link} Link
         */
        Link.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Link)
                return object;
            let message = new $root.MessageEntities.Link();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.Link.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a Link message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Link
         * @static
         * @param {MessageEntities.Link} message Link
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Link.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.bounds = null;
                object.url = "";
            }
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this Link to JSON.
         * @function toJSON
         * @memberof MessageEntities.Link
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Link.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Link;
    })();

    MessageEntities.Emote = (function() {

        /**
         * Properties of an Emote.
         * @memberof MessageEntities
         * @interface IEmote
         * @property {MessageEntities.IBounds|null} [bounds] Emote bounds
         * @property {string|null} [name] Emote name
         * @property {Array.<string>|null} [modifiers] Emote modifiers
         * @property {number|null} [combo] Emote combo
         */

        /**
         * Constructs a new Emote.
         * @memberof MessageEntities
         * @classdesc Represents an Emote.
         * @implements IEmote
         * @constructor
         * @param {MessageEntities.IEmote=} [properties] Properties to set
         */
        function Emote(properties) {
            this.modifiers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Emote bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.Emote
         * @instance
         */
        Emote.prototype.bounds = null;

        /**
         * Emote name.
         * @member {string} name
         * @memberof MessageEntities.Emote
         * @instance
         */
        Emote.prototype.name = "";

        /**
         * Emote modifiers.
         * @member {Array.<string>} modifiers
         * @memberof MessageEntities.Emote
         * @instance
         */
        Emote.prototype.modifiers = $util.emptyArray;

        /**
         * Emote combo.
         * @member {number} combo
         * @memberof MessageEntities.Emote
         * @instance
         */
        Emote.prototype.combo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Emote instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Emote
         * @static
         * @param {MessageEntities.IEmote=} [properties] Properties to set
         * @returns {MessageEntities.Emote} Emote instance
         */
        Emote.create = function create(properties) {
            return new Emote(properties);
        };

        /**
         * Encodes the specified Emote message. Does not implicitly {@link MessageEntities.Emote.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Emote
         * @static
         * @param {MessageEntities.IEmote} message Emote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Emote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.modifiers != null && message.modifiers.length)
                for (let i = 0; i < message.modifiers.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modifiers[i]);
            if (message.combo != null && Object.hasOwnProperty.call(message, "combo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.combo);
            return writer;
        };

        /**
         * Encodes the specified Emote message, length delimited. Does not implicitly {@link MessageEntities.Emote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Emote
         * @static
         * @param {MessageEntities.IEmote} message Emote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Emote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Emote message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Emote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Emote} Emote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Emote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Emote();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.modifiers && message.modifiers.length))
                        message.modifiers = [];
                    message.modifiers.push(reader.string());
                    break;
                case 4:
                    message.combo = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Emote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Emote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Emote} Emote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Emote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Emote message.
         * @function verify
         * @memberof MessageEntities.Emote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Emote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.modifiers != null && message.hasOwnProperty("modifiers")) {
                if (!Array.isArray(message.modifiers))
                    return "modifiers: array expected";
                for (let i = 0; i < message.modifiers.length; ++i)
                    if (!$util.isString(message.modifiers[i]))
                        return "modifiers: string[] expected";
            }
            if (message.combo != null && message.hasOwnProperty("combo"))
                if (!$util.isInteger(message.combo) && !(message.combo && $util.isInteger(message.combo.low) && $util.isInteger(message.combo.high)))
                    return "combo: integer|Long expected";
            return null;
        };

        /**
         * Creates an Emote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Emote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Emote} Emote
         */
        Emote.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Emote)
                return object;
            let message = new $root.MessageEntities.Emote();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.Emote.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.modifiers) {
                if (!Array.isArray(object.modifiers))
                    throw TypeError(".MessageEntities.Emote.modifiers: array expected");
                message.modifiers = [];
                for (let i = 0; i < object.modifiers.length; ++i)
                    message.modifiers[i] = String(object.modifiers[i]);
            }
            if (object.combo != null)
                if ($util.Long)
                    (message.combo = $util.Long.fromValue(object.combo)).unsigned = false;
                else if (typeof object.combo === "string")
                    message.combo = parseInt(object.combo, 10);
                else if (typeof object.combo === "number")
                    message.combo = object.combo;
                else if (typeof object.combo === "object")
                    message.combo = new $util.LongBits(object.combo.low >>> 0, object.combo.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Emote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Emote
         * @static
         * @param {MessageEntities.Emote} message Emote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Emote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.modifiers = [];
            if (options.defaults) {
                object.bounds = null;
                object.name = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.combo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.combo = options.longs === String ? "0" : 0;
            }
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.modifiers && message.modifiers.length) {
                object.modifiers = [];
                for (let j = 0; j < message.modifiers.length; ++j)
                    object.modifiers[j] = message.modifiers[j];
            }
            if (message.combo != null && message.hasOwnProperty("combo"))
                if (typeof message.combo === "number")
                    object.combo = options.longs === String ? String(message.combo) : message.combo;
                else
                    object.combo = options.longs === String ? $util.Long.prototype.toString.call(message.combo) : options.longs === Number ? new $util.LongBits(message.combo.low >>> 0, message.combo.high >>> 0).toNumber() : message.combo;
            return object;
        };

        /**
         * Converts this Emote to JSON.
         * @function toJSON
         * @memberof MessageEntities.Emote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Emote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Emote;
    })();

    MessageEntities.Nick = (function() {

        /**
         * Properties of a Nick.
         * @memberof MessageEntities
         * @interface INick
         * @property {MessageEntities.IBounds|null} [bounds] Nick bounds
         * @property {string|null} [nick] Nick nick
         */

        /**
         * Constructs a new Nick.
         * @memberof MessageEntities
         * @classdesc Represents a Nick.
         * @implements INick
         * @constructor
         * @param {MessageEntities.INick=} [properties] Properties to set
         */
        function Nick(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Nick bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.Nick
         * @instance
         */
        Nick.prototype.bounds = null;

        /**
         * Nick nick.
         * @member {string} nick
         * @memberof MessageEntities.Nick
         * @instance
         */
        Nick.prototype.nick = "";

        /**
         * Creates a new Nick instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Nick
         * @static
         * @param {MessageEntities.INick=} [properties] Properties to set
         * @returns {MessageEntities.Nick} Nick instance
         */
        Nick.create = function create(properties) {
            return new Nick(properties);
        };

        /**
         * Encodes the specified Nick message. Does not implicitly {@link MessageEntities.Nick.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Nick
         * @static
         * @param {MessageEntities.INick} message Nick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nick);
            return writer;
        };

        /**
         * Encodes the specified Nick message, length delimited. Does not implicitly {@link MessageEntities.Nick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Nick
         * @static
         * @param {MessageEntities.INick} message Nick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Nick message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Nick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Nick} Nick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Nick();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Nick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Nick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Nick} Nick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Nick message.
         * @function verify
         * @memberof MessageEntities.Nick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Nick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            if (message.nick != null && message.hasOwnProperty("nick"))
                if (!$util.isString(message.nick))
                    return "nick: string expected";
            return null;
        };

        /**
         * Creates a Nick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Nick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Nick} Nick
         */
        Nick.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Nick)
                return object;
            let message = new $root.MessageEntities.Nick();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.Nick.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            if (object.nick != null)
                message.nick = String(object.nick);
            return message;
        };

        /**
         * Creates a plain object from a Nick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Nick
         * @static
         * @param {MessageEntities.Nick} message Nick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Nick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.bounds = null;
                object.nick = "";
            }
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            if (message.nick != null && message.hasOwnProperty("nick"))
                object.nick = message.nick;
            return object;
        };

        /**
         * Converts this Nick to JSON.
         * @function toJSON
         * @memberof MessageEntities.Nick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Nick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Nick;
    })();

    MessageEntities.Tag = (function() {

        /**
         * Properties of a Tag.
         * @memberof MessageEntities
         * @interface ITag
         * @property {MessageEntities.IBounds|null} [bounds] Tag bounds
         * @property {string|null} [name] Tag name
         */

        /**
         * Constructs a new Tag.
         * @memberof MessageEntities
         * @classdesc Represents a Tag.
         * @implements ITag
         * @constructor
         * @param {MessageEntities.ITag=} [properties] Properties to set
         */
        function Tag(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tag bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.Tag
         * @instance
         */
        Tag.prototype.bounds = null;

        /**
         * Tag name.
         * @member {string} name
         * @memberof MessageEntities.Tag
         * @instance
         */
        Tag.prototype.name = "";

        /**
         * Creates a new Tag instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Tag
         * @static
         * @param {MessageEntities.ITag=} [properties] Properties to set
         * @returns {MessageEntities.Tag} Tag instance
         */
        Tag.create = function create(properties) {
            return new Tag(properties);
        };

        /**
         * Encodes the specified Tag message. Does not implicitly {@link MessageEntities.Tag.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Tag
         * @static
         * @param {MessageEntities.ITag} message Tag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Tag message, length delimited. Does not implicitly {@link MessageEntities.Tag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Tag
         * @static
         * @param {MessageEntities.ITag} message Tag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tag message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Tag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Tag} Tag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Tag();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Tag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Tag} Tag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tag message.
         * @function verify
         * @memberof MessageEntities.Tag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Tag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Tag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Tag} Tag
         */
        Tag.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Tag)
                return object;
            let message = new $root.MessageEntities.Tag();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.Tag.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Tag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Tag
         * @static
         * @param {MessageEntities.Tag} message Tag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.bounds = null;
                object.name = "";
            }
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Tag to JSON.
         * @function toJSON
         * @memberof MessageEntities.Tag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tag;
    })();

    MessageEntities.CodeBlock = (function() {

        /**
         * Properties of a CodeBlock.
         * @memberof MessageEntities
         * @interface ICodeBlock
         * @property {MessageEntities.IBounds|null} [bounds] CodeBlock bounds
         */

        /**
         * Constructs a new CodeBlock.
         * @memberof MessageEntities
         * @classdesc Represents a CodeBlock.
         * @implements ICodeBlock
         * @constructor
         * @param {MessageEntities.ICodeBlock=} [properties] Properties to set
         */
        function CodeBlock(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CodeBlock bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.CodeBlock
         * @instance
         */
        CodeBlock.prototype.bounds = null;

        /**
         * Creates a new CodeBlock instance using the specified properties.
         * @function create
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {MessageEntities.ICodeBlock=} [properties] Properties to set
         * @returns {MessageEntities.CodeBlock} CodeBlock instance
         */
        CodeBlock.create = function create(properties) {
            return new CodeBlock(properties);
        };

        /**
         * Encodes the specified CodeBlock message. Does not implicitly {@link MessageEntities.CodeBlock.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {MessageEntities.ICodeBlock} message CodeBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CodeBlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CodeBlock message, length delimited. Does not implicitly {@link MessageEntities.CodeBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {MessageEntities.ICodeBlock} message CodeBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CodeBlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CodeBlock message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.CodeBlock} CodeBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CodeBlock.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.CodeBlock();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CodeBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.CodeBlock} CodeBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CodeBlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CodeBlock message.
         * @function verify
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CodeBlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            return null;
        };

        /**
         * Creates a CodeBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.CodeBlock} CodeBlock
         */
        CodeBlock.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.CodeBlock)
                return object;
            let message = new $root.MessageEntities.CodeBlock();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.CodeBlock.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            return message;
        };

        /**
         * Creates a plain object from a CodeBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.CodeBlock
         * @static
         * @param {MessageEntities.CodeBlock} message CodeBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CodeBlock.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bounds = null;
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            return object;
        };

        /**
         * Converts this CodeBlock to JSON.
         * @function toJSON
         * @memberof MessageEntities.CodeBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CodeBlock.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CodeBlock;
    })();

    MessageEntities.Spoiler = (function() {

        /**
         * Properties of a Spoiler.
         * @memberof MessageEntities
         * @interface ISpoiler
         * @property {MessageEntities.IBounds|null} [bounds] Spoiler bounds
         */

        /**
         * Constructs a new Spoiler.
         * @memberof MessageEntities
         * @classdesc Represents a Spoiler.
         * @implements ISpoiler
         * @constructor
         * @param {MessageEntities.ISpoiler=} [properties] Properties to set
         */
        function Spoiler(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Spoiler bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.Spoiler
         * @instance
         */
        Spoiler.prototype.bounds = null;

        /**
         * Creates a new Spoiler instance using the specified properties.
         * @function create
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {MessageEntities.ISpoiler=} [properties] Properties to set
         * @returns {MessageEntities.Spoiler} Spoiler instance
         */
        Spoiler.create = function create(properties) {
            return new Spoiler(properties);
        };

        /**
         * Encodes the specified Spoiler message. Does not implicitly {@link MessageEntities.Spoiler.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {MessageEntities.ISpoiler} message Spoiler message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spoiler.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Spoiler message, length delimited. Does not implicitly {@link MessageEntities.Spoiler.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {MessageEntities.ISpoiler} message Spoiler message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spoiler.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Spoiler message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.Spoiler} Spoiler
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spoiler.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.Spoiler();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Spoiler message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.Spoiler} Spoiler
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spoiler.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Spoiler message.
         * @function verify
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Spoiler.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            return null;
        };

        /**
         * Creates a Spoiler message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.Spoiler} Spoiler
         */
        Spoiler.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.Spoiler)
                return object;
            let message = new $root.MessageEntities.Spoiler();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.Spoiler.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            return message;
        };

        /**
         * Creates a plain object from a Spoiler message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.Spoiler
         * @static
         * @param {MessageEntities.Spoiler} message Spoiler
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Spoiler.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bounds = null;
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            return object;
        };

        /**
         * Converts this Spoiler to JSON.
         * @function toJSON
         * @memberof MessageEntities.Spoiler
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Spoiler.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Spoiler;
    })();

    MessageEntities.GenericEntity = (function() {

        /**
         * Properties of a GenericEntity.
         * @memberof MessageEntities
         * @interface IGenericEntity
         * @property {MessageEntities.IBounds|null} [bounds] GenericEntity bounds
         */

        /**
         * Constructs a new GenericEntity.
         * @memberof MessageEntities
         * @classdesc Represents a GenericEntity.
         * @implements IGenericEntity
         * @constructor
         * @param {MessageEntities.IGenericEntity=} [properties] Properties to set
         */
        function GenericEntity(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenericEntity bounds.
         * @member {MessageEntities.IBounds|null|undefined} bounds
         * @memberof MessageEntities.GenericEntity
         * @instance
         */
        GenericEntity.prototype.bounds = null;

        /**
         * Creates a new GenericEntity instance using the specified properties.
         * @function create
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {MessageEntities.IGenericEntity=} [properties] Properties to set
         * @returns {MessageEntities.GenericEntity} GenericEntity instance
         */
        GenericEntity.create = function create(properties) {
            return new GenericEntity(properties);
        };

        /**
         * Encodes the specified GenericEntity message. Does not implicitly {@link MessageEntities.GenericEntity.verify|verify} messages.
         * @function encode
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {MessageEntities.IGenericEntity} message GenericEntity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenericEntity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                $root.MessageEntities.Bounds.encode(message.bounds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GenericEntity message, length delimited. Does not implicitly {@link MessageEntities.GenericEntity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {MessageEntities.IGenericEntity} message GenericEntity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenericEntity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenericEntity message from the specified reader or buffer.
         * @function decode
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MessageEntities.GenericEntity} GenericEntity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenericEntity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageEntities.GenericEntity();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bounds = $root.MessageEntities.Bounds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenericEntity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MessageEntities.GenericEntity} GenericEntity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenericEntity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenericEntity message.
         * @function verify
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenericEntity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bounds != null && message.hasOwnProperty("bounds")) {
                let error = $root.MessageEntities.Bounds.verify(message.bounds);
                if (error)
                    return "bounds." + error;
            }
            return null;
        };

        /**
         * Creates a GenericEntity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MessageEntities.GenericEntity} GenericEntity
         */
        GenericEntity.fromObject = function fromObject(object) {
            if (object instanceof $root.MessageEntities.GenericEntity)
                return object;
            let message = new $root.MessageEntities.GenericEntity();
            if (object.bounds != null) {
                if (typeof object.bounds !== "object")
                    throw TypeError(".MessageEntities.GenericEntity.bounds: object expected");
                message.bounds = $root.MessageEntities.Bounds.fromObject(object.bounds);
            }
            return message;
        };

        /**
         * Creates a plain object from a GenericEntity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MessageEntities.GenericEntity
         * @static
         * @param {MessageEntities.GenericEntity} message GenericEntity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenericEntity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bounds = null;
            if (message.bounds != null && message.hasOwnProperty("bounds"))
                object.bounds = $root.MessageEntities.Bounds.toObject(message.bounds, options);
            return object;
        };

        /**
         * Converts this GenericEntity to JSON.
         * @function toJSON
         * @memberof MessageEntities.GenericEntity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenericEntity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenericEntity;
    })();

    return MessageEntities;
})();

export const CallChatClientRequest = $root.CallChatClientRequest = (() => {

    /**
     * Properties of a CallChatClientRequest.
     * @exports ICallChatClientRequest
     * @interface ICallChatClientRequest
     * @property {number|null} [clientId] CallChatClientRequest clientId
     * @property {CallChatClientRequest.IMessage|null} [message] CallChatClientRequest message
     * @property {CallChatClientRequest.IClose|null} [close] CallChatClientRequest close
     */

    /**
     * Constructs a new CallChatClientRequest.
     * @exports CallChatClientRequest
     * @classdesc Represents a CallChatClientRequest.
     * @implements ICallChatClientRequest
     * @constructor
     * @param {ICallChatClientRequest=} [properties] Properties to set
     */
    function CallChatClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CallChatClientRequest clientId.
     * @member {number} clientId
     * @memberof CallChatClientRequest
     * @instance
     */
    CallChatClientRequest.prototype.clientId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * CallChatClientRequest message.
     * @member {CallChatClientRequest.IMessage|null|undefined} message
     * @memberof CallChatClientRequest
     * @instance
     */
    CallChatClientRequest.prototype.message = null;

    /**
     * CallChatClientRequest close.
     * @member {CallChatClientRequest.IClose|null|undefined} close
     * @memberof CallChatClientRequest
     * @instance
     */
    CallChatClientRequest.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CallChatClientRequest body.
     * @member {"message"|"close"|undefined} body
     * @memberof CallChatClientRequest
     * @instance
     */
    Object.defineProperty(CallChatClientRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["message", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CallChatClientRequest instance using the specified properties.
     * @function create
     * @memberof CallChatClientRequest
     * @static
     * @param {ICallChatClientRequest=} [properties] Properties to set
     * @returns {CallChatClientRequest} CallChatClientRequest instance
     */
    CallChatClientRequest.create = function create(properties) {
        return new CallChatClientRequest(properties);
    };

    /**
     * Encodes the specified CallChatClientRequest message. Does not implicitly {@link CallChatClientRequest.verify|verify} messages.
     * @function encode
     * @memberof CallChatClientRequest
     * @static
     * @param {ICallChatClientRequest} message CallChatClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.clientId);
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.CallChatClientRequest.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.CallChatClientRequest.Close.encode(message.close, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CallChatClientRequest message, length delimited. Does not implicitly {@link CallChatClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CallChatClientRequest
     * @static
     * @param {ICallChatClientRequest} message CallChatClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CallChatClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CallChatClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CallChatClientRequest} CallChatClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clientId = reader.uint64();
                break;
            case 2:
                message.message = $root.CallChatClientRequest.Message.decode(reader, reader.uint32());
                break;
            case 3:
                message.close = $root.CallChatClientRequest.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CallChatClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CallChatClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CallChatClientRequest} CallChatClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CallChatClientRequest message.
     * @function verify
     * @memberof CallChatClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CallChatClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            if (!$util.isInteger(message.clientId) && !(message.clientId && $util.isInteger(message.clientId.low) && $util.isInteger(message.clientId.high)))
                return "clientId: integer|Long expected";
        if (message.message != null && message.hasOwnProperty("message")) {
            properties.body = 1;
            {
                let error = $root.CallChatClientRequest.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.CallChatClientRequest.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CallChatClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CallChatClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CallChatClientRequest} CallChatClientRequest
     */
    CallChatClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CallChatClientRequest)
            return object;
        let message = new $root.CallChatClientRequest();
        if (object.clientId != null)
            if ($util.Long)
                (message.clientId = $util.Long.fromValue(object.clientId)).unsigned = true;
            else if (typeof object.clientId === "string")
                message.clientId = parseInt(object.clientId, 10);
            else if (typeof object.clientId === "number")
                message.clientId = object.clientId;
            else if (typeof object.clientId === "object")
                message.clientId = new $util.LongBits(object.clientId.low >>> 0, object.clientId.high >>> 0).toNumber(true);
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".CallChatClientRequest.message: object expected");
            message.message = $root.CallChatClientRequest.Message.fromObject(object.message);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".CallChatClientRequest.close: object expected");
            message.close = $root.CallChatClientRequest.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a CallChatClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CallChatClientRequest
     * @static
     * @param {CallChatClientRequest} message CallChatClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CallChatClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.clientId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.clientId = options.longs === String ? "0" : 0;
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            if (typeof message.clientId === "number")
                object.clientId = options.longs === String ? String(message.clientId) : message.clientId;
            else
                object.clientId = options.longs === String ? $util.Long.prototype.toString.call(message.clientId) : options.longs === Number ? new $util.LongBits(message.clientId.low >>> 0, message.clientId.high >>> 0).toNumber(true) : message.clientId;
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.CallChatClientRequest.Message.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.CallChatClientRequest.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this CallChatClientRequest to JSON.
     * @function toJSON
     * @memberof CallChatClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CallChatClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    CallChatClientRequest.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof CallChatClientRequest
         * @interface IMessage
         * @property {number|null} [time] Message time
         * @property {string|null} [body] Message body
         */

        /**
         * Constructs a new Message.
         * @memberof CallChatClientRequest
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {CallChatClientRequest.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message time.
         * @member {number} time
         * @memberof CallChatClientRequest.Message
         * @instance
         */
        Message.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message body.
         * @member {string} body
         * @memberof CallChatClientRequest.Message
         * @instance
         */
        Message.prototype.body = "";

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {CallChatClientRequest.IMessage=} [properties] Properties to set
         * @returns {CallChatClientRequest.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link CallChatClientRequest.Message.verify|verify} messages.
         * @function encode
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {CallChatClientRequest.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link CallChatClientRequest.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {CallChatClientRequest.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CallChatClientRequest.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatClientRequest.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CallChatClientRequest.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CallChatClientRequest.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.CallChatClientRequest.Message)
                return object;
            let message = new $root.CallChatClientRequest.Message();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.body != null)
                message.body = String(object.body);
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CallChatClientRequest.Message
         * @static
         * @param {CallChatClientRequest.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.body = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof CallChatClientRequest.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    CallChatClientRequest.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof CallChatClientRequest
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof CallChatClientRequest
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {CallChatClientRequest.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {CallChatClientRequest.IClose=} [properties] Properties to set
         * @returns {CallChatClientRequest.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link CallChatClientRequest.Close.verify|verify} messages.
         * @function encode
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {CallChatClientRequest.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link CallChatClientRequest.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {CallChatClientRequest.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CallChatClientRequest.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatClientRequest.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CallChatClientRequest.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CallChatClientRequest.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.CallChatClientRequest.Close)
                return object;
            return new $root.CallChatClientRequest.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CallChatClientRequest.Close
         * @static
         * @param {CallChatClientRequest.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof CallChatClientRequest.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return CallChatClientRequest;
})();

export const CallChatClientResponse = $root.CallChatClientResponse = (() => {

    /**
     * Properties of a CallChatClientResponse.
     * @exports ICallChatClientResponse
     * @interface ICallChatClientResponse
     */

    /**
     * Constructs a new CallChatClientResponse.
     * @exports CallChatClientResponse
     * @classdesc Represents a CallChatClientResponse.
     * @implements ICallChatClientResponse
     * @constructor
     * @param {ICallChatClientResponse=} [properties] Properties to set
     */
    function CallChatClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new CallChatClientResponse instance using the specified properties.
     * @function create
     * @memberof CallChatClientResponse
     * @static
     * @param {ICallChatClientResponse=} [properties] Properties to set
     * @returns {CallChatClientResponse} CallChatClientResponse instance
     */
    CallChatClientResponse.create = function create(properties) {
        return new CallChatClientResponse(properties);
    };

    /**
     * Encodes the specified CallChatClientResponse message. Does not implicitly {@link CallChatClientResponse.verify|verify} messages.
     * @function encode
     * @memberof CallChatClientResponse
     * @static
     * @param {ICallChatClientResponse} message CallChatClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified CallChatClientResponse message, length delimited. Does not implicitly {@link CallChatClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CallChatClientResponse
     * @static
     * @param {ICallChatClientResponse} message CallChatClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallChatClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CallChatClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CallChatClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CallChatClientResponse} CallChatClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallChatClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CallChatClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CallChatClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CallChatClientResponse} CallChatClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallChatClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CallChatClientResponse message.
     * @function verify
     * @memberof CallChatClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CallChatClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a CallChatClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CallChatClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CallChatClientResponse} CallChatClientResponse
     */
    CallChatClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CallChatClientResponse)
            return object;
        return new $root.CallChatClientResponse();
    };

    /**
     * Creates a plain object from a CallChatClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CallChatClientResponse
     * @static
     * @param {CallChatClientResponse} message CallChatClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CallChatClientResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this CallChatClientResponse to JSON.
     * @function toJSON
     * @memberof CallChatClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CallChatClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CallChatClientResponse;
})();

export const PProfRequest = $root.PProfRequest = (() => {

    /**
     * Properties of a PProfRequest.
     * @exports IPProfRequest
     * @interface IPProfRequest
     * @property {string|null} [name] PProfRequest name
     * @property {boolean|null} [debug] PProfRequest debug
     * @property {boolean|null} [gc] PProfRequest gc
     */

    /**
     * Constructs a new PProfRequest.
     * @exports PProfRequest
     * @classdesc Represents a PProfRequest.
     * @implements IPProfRequest
     * @constructor
     * @param {IPProfRequest=} [properties] Properties to set
     */
    function PProfRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PProfRequest name.
     * @member {string} name
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.name = "";

    /**
     * PProfRequest debug.
     * @member {boolean} debug
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.debug = false;

    /**
     * PProfRequest gc.
     * @member {boolean} gc
     * @memberof PProfRequest
     * @instance
     */
    PProfRequest.prototype.gc = false;

    /**
     * Creates a new PProfRequest instance using the specified properties.
     * @function create
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest=} [properties] Properties to set
     * @returns {PProfRequest} PProfRequest instance
     */
    PProfRequest.create = function create(properties) {
        return new PProfRequest(properties);
    };

    /**
     * Encodes the specified PProfRequest message. Does not implicitly {@link PProfRequest.verify|verify} messages.
     * @function encode
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest} message PProfRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.debug);
        if (message.gc != null && Object.hasOwnProperty.call(message, "gc"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.gc);
        return writer;
    };

    /**
     * Encodes the specified PProfRequest message, length delimited. Does not implicitly {@link PProfRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PProfRequest
     * @static
     * @param {IPProfRequest} message PProfRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PProfRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PProfRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PProfRequest} PProfRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PProfRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.debug = reader.bool();
                break;
            case 3:
                message.gc = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PProfRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PProfRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PProfRequest} PProfRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PProfRequest message.
     * @function verify
     * @memberof PProfRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PProfRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.debug != null && message.hasOwnProperty("debug"))
            if (typeof message.debug !== "boolean")
                return "debug: boolean expected";
        if (message.gc != null && message.hasOwnProperty("gc"))
            if (typeof message.gc !== "boolean")
                return "gc: boolean expected";
        return null;
    };

    /**
     * Creates a PProfRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PProfRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PProfRequest} PProfRequest
     */
    PProfRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PProfRequest)
            return object;
        let message = new $root.PProfRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.debug != null)
            message.debug = Boolean(object.debug);
        if (object.gc != null)
            message.gc = Boolean(object.gc);
        return message;
    };

    /**
     * Creates a plain object from a PProfRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PProfRequest
     * @static
     * @param {PProfRequest} message PProfRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PProfRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.debug = false;
            object.gc = false;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.debug != null && message.hasOwnProperty("debug"))
            object.debug = message.debug;
        if (message.gc != null && message.hasOwnProperty("gc"))
            object.gc = message.gc;
        return object;
    };

    /**
     * Converts this PProfRequest to JSON.
     * @function toJSON
     * @memberof PProfRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PProfRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PProfRequest;
})();

export const PProfResponse = $root.PProfResponse = (() => {

    /**
     * Properties of a PProfResponse.
     * @exports IPProfResponse
     * @interface IPProfResponse
     * @property {string|null} [name] PProfResponse name
     * @property {Uint8Array|null} [data] PProfResponse data
     */

    /**
     * Constructs a new PProfResponse.
     * @exports PProfResponse
     * @classdesc Represents a PProfResponse.
     * @implements IPProfResponse
     * @constructor
     * @param {IPProfResponse=} [properties] Properties to set
     */
    function PProfResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PProfResponse name.
     * @member {string} name
     * @memberof PProfResponse
     * @instance
     */
    PProfResponse.prototype.name = "";

    /**
     * PProfResponse data.
     * @member {Uint8Array} data
     * @memberof PProfResponse
     * @instance
     */
    PProfResponse.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new PProfResponse instance using the specified properties.
     * @function create
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse=} [properties] Properties to set
     * @returns {PProfResponse} PProfResponse instance
     */
    PProfResponse.create = function create(properties) {
        return new PProfResponse(properties);
    };

    /**
     * Encodes the specified PProfResponse message. Does not implicitly {@link PProfResponse.verify|verify} messages.
     * @function encode
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse} message PProfResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified PProfResponse message, length delimited. Does not implicitly {@link PProfResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PProfResponse
     * @static
     * @param {IPProfResponse} message PProfResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PProfResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PProfResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PProfResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PProfResponse} PProfResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PProfResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PProfResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PProfResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PProfResponse} PProfResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PProfResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PProfResponse message.
     * @function verify
     * @memberof PProfResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PProfResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a PProfResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PProfResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PProfResponse} PProfResponse
     */
    PProfResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PProfResponse)
            return object;
        let message = new $root.PProfResponse();
        if (object.name != null)
            message.name = String(object.name);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a PProfResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PProfResponse
     * @static
     * @param {PProfResponse} message PProfResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PProfResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this PProfResponse to JSON.
     * @function toJSON
     * @memberof PProfResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PProfResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PProfResponse;
})();

export const ReadMetricsRequest = $root.ReadMetricsRequest = (() => {

    /**
     * Properties of a ReadMetricsRequest.
     * @exports IReadMetricsRequest
     * @interface IReadMetricsRequest
     * @property {MetricsFormat|null} [format] ReadMetricsRequest format
     */

    /**
     * Constructs a new ReadMetricsRequest.
     * @exports ReadMetricsRequest
     * @classdesc Represents a ReadMetricsRequest.
     * @implements IReadMetricsRequest
     * @constructor
     * @param {IReadMetricsRequest=} [properties] Properties to set
     */
    function ReadMetricsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReadMetricsRequest format.
     * @member {MetricsFormat} format
     * @memberof ReadMetricsRequest
     * @instance
     */
    ReadMetricsRequest.prototype.format = 0;

    /**
     * Creates a new ReadMetricsRequest instance using the specified properties.
     * @function create
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest=} [properties] Properties to set
     * @returns {ReadMetricsRequest} ReadMetricsRequest instance
     */
    ReadMetricsRequest.create = function create(properties) {
        return new ReadMetricsRequest(properties);
    };

    /**
     * Encodes the specified ReadMetricsRequest message. Does not implicitly {@link ReadMetricsRequest.verify|verify} messages.
     * @function encode
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest} message ReadMetricsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.format != null && Object.hasOwnProperty.call(message, "format"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.format);
        return writer;
    };

    /**
     * Encodes the specified ReadMetricsRequest message, length delimited. Does not implicitly {@link ReadMetricsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReadMetricsRequest
     * @static
     * @param {IReadMetricsRequest} message ReadMetricsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReadMetricsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ReadMetricsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReadMetricsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.format = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReadMetricsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReadMetricsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReadMetricsRequest message.
     * @function verify
     * @memberof ReadMetricsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReadMetricsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.format != null && message.hasOwnProperty("format"))
            switch (message.format) {
            default:
                return "format: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
        return null;
    };

    /**
     * Creates a ReadMetricsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReadMetricsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReadMetricsRequest} ReadMetricsRequest
     */
    ReadMetricsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ReadMetricsRequest)
            return object;
        let message = new $root.ReadMetricsRequest();
        switch (object.format) {
        case "METRICS_FORMAT_TEXT":
        case 0:
            message.format = 0;
            break;
        case "METRICS_FORMAT_PROTO_DELIM":
        case 1:
            message.format = 1;
            break;
        case "METRICS_FORMAT_PROTO_TEXT":
        case 2:
            message.format = 2;
            break;
        case "METRICS_FORMAT_PROTO_COMPACT":
        case 3:
            message.format = 3;
            break;
        case "METRICS_FORMAT_OPEN_METRICS":
        case 4:
            message.format = 4;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ReadMetricsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReadMetricsRequest
     * @static
     * @param {ReadMetricsRequest} message ReadMetricsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReadMetricsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.format = options.enums === String ? "METRICS_FORMAT_TEXT" : 0;
        if (message.format != null && message.hasOwnProperty("format"))
            object.format = options.enums === String ? $root.MetricsFormat[message.format] : message.format;
        return object;
    };

    /**
     * Converts this ReadMetricsRequest to JSON.
     * @function toJSON
     * @memberof ReadMetricsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReadMetricsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReadMetricsRequest;
})();

export const ReadMetricsResponse = $root.ReadMetricsResponse = (() => {

    /**
     * Properties of a ReadMetricsResponse.
     * @exports IReadMetricsResponse
     * @interface IReadMetricsResponse
     * @property {Uint8Array|null} [data] ReadMetricsResponse data
     */

    /**
     * Constructs a new ReadMetricsResponse.
     * @exports ReadMetricsResponse
     * @classdesc Represents a ReadMetricsResponse.
     * @implements IReadMetricsResponse
     * @constructor
     * @param {IReadMetricsResponse=} [properties] Properties to set
     */
    function ReadMetricsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReadMetricsResponse data.
     * @member {Uint8Array} data
     * @memberof ReadMetricsResponse
     * @instance
     */
    ReadMetricsResponse.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new ReadMetricsResponse instance using the specified properties.
     * @function create
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse=} [properties] Properties to set
     * @returns {ReadMetricsResponse} ReadMetricsResponse instance
     */
    ReadMetricsResponse.create = function create(properties) {
        return new ReadMetricsResponse(properties);
    };

    /**
     * Encodes the specified ReadMetricsResponse message. Does not implicitly {@link ReadMetricsResponse.verify|verify} messages.
     * @function encode
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse} message ReadMetricsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified ReadMetricsResponse message, length delimited. Does not implicitly {@link ReadMetricsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReadMetricsResponse
     * @static
     * @param {IReadMetricsResponse} message ReadMetricsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReadMetricsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReadMetricsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ReadMetricsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReadMetricsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReadMetricsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReadMetricsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReadMetricsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReadMetricsResponse message.
     * @function verify
     * @memberof ReadMetricsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReadMetricsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a ReadMetricsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReadMetricsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReadMetricsResponse} ReadMetricsResponse
     */
    ReadMetricsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ReadMetricsResponse)
            return object;
        let message = new $root.ReadMetricsResponse();
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a ReadMetricsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReadMetricsResponse
     * @static
     * @param {ReadMetricsResponse} message ReadMetricsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReadMetricsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this ReadMetricsResponse to JSON.
     * @function toJSON
     * @memberof ReadMetricsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReadMetricsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReadMetricsResponse;
})();

export const GetDirectoryEventsRequest = $root.GetDirectoryEventsRequest = (() => {

    /**
     * Properties of a GetDirectoryEventsRequest.
     * @exports IGetDirectoryEventsRequest
     * @interface IGetDirectoryEventsRequest
     * @property {Uint8Array|null} [networkKey] GetDirectoryEventsRequest networkKey
     */

    /**
     * Constructs a new GetDirectoryEventsRequest.
     * @exports GetDirectoryEventsRequest
     * @classdesc Represents a GetDirectoryEventsRequest.
     * @implements IGetDirectoryEventsRequest
     * @constructor
     * @param {IGetDirectoryEventsRequest=} [properties] Properties to set
     */
    function GetDirectoryEventsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetDirectoryEventsRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof GetDirectoryEventsRequest
     * @instance
     */
    GetDirectoryEventsRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * Creates a new GetDirectoryEventsRequest instance using the specified properties.
     * @function create
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {IGetDirectoryEventsRequest=} [properties] Properties to set
     * @returns {GetDirectoryEventsRequest} GetDirectoryEventsRequest instance
     */
    GetDirectoryEventsRequest.create = function create(properties) {
        return new GetDirectoryEventsRequest(properties);
    };

    /**
     * Encodes the specified GetDirectoryEventsRequest message. Does not implicitly {@link GetDirectoryEventsRequest.verify|verify} messages.
     * @function encode
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {IGetDirectoryEventsRequest} message GetDirectoryEventsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetDirectoryEventsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKey);
        return writer;
    };

    /**
     * Encodes the specified GetDirectoryEventsRequest message, length delimited. Does not implicitly {@link GetDirectoryEventsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {IGetDirectoryEventsRequest} message GetDirectoryEventsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetDirectoryEventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetDirectoryEventsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetDirectoryEventsRequest} GetDirectoryEventsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetDirectoryEventsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDirectoryEventsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetDirectoryEventsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetDirectoryEventsRequest} GetDirectoryEventsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetDirectoryEventsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetDirectoryEventsRequest message.
     * @function verify
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetDirectoryEventsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        return null;
    };

    /**
     * Creates a GetDirectoryEventsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetDirectoryEventsRequest} GetDirectoryEventsRequest
     */
    GetDirectoryEventsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetDirectoryEventsRequest)
            return object;
        let message = new $root.GetDirectoryEventsRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        return message;
    };

    /**
     * Creates a plain object from a GetDirectoryEventsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetDirectoryEventsRequest
     * @static
     * @param {GetDirectoryEventsRequest} message GetDirectoryEventsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetDirectoryEventsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        return object;
    };

    /**
     * Converts this GetDirectoryEventsRequest to JSON.
     * @function toJSON
     * @memberof GetDirectoryEventsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetDirectoryEventsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetDirectoryEventsRequest;
})();

export const TestDirectoryPublishRequest = $root.TestDirectoryPublishRequest = (() => {

    /**
     * Properties of a TestDirectoryPublishRequest.
     * @exports ITestDirectoryPublishRequest
     * @interface ITestDirectoryPublishRequest
     * @property {Uint8Array|null} [networkKey] TestDirectoryPublishRequest networkKey
     */

    /**
     * Constructs a new TestDirectoryPublishRequest.
     * @exports TestDirectoryPublishRequest
     * @classdesc Represents a TestDirectoryPublishRequest.
     * @implements ITestDirectoryPublishRequest
     * @constructor
     * @param {ITestDirectoryPublishRequest=} [properties] Properties to set
     */
    function TestDirectoryPublishRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestDirectoryPublishRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof TestDirectoryPublishRequest
     * @instance
     */
    TestDirectoryPublishRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * Creates a new TestDirectoryPublishRequest instance using the specified properties.
     * @function create
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {ITestDirectoryPublishRequest=} [properties] Properties to set
     * @returns {TestDirectoryPublishRequest} TestDirectoryPublishRequest instance
     */
    TestDirectoryPublishRequest.create = function create(properties) {
        return new TestDirectoryPublishRequest(properties);
    };

    /**
     * Encodes the specified TestDirectoryPublishRequest message. Does not implicitly {@link TestDirectoryPublishRequest.verify|verify} messages.
     * @function encode
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {ITestDirectoryPublishRequest} message TestDirectoryPublishRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestDirectoryPublishRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKey);
        return writer;
    };

    /**
     * Encodes the specified TestDirectoryPublishRequest message, length delimited. Does not implicitly {@link TestDirectoryPublishRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {ITestDirectoryPublishRequest} message TestDirectoryPublishRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestDirectoryPublishRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestDirectoryPublishRequest message from the specified reader or buffer.
     * @function decode
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestDirectoryPublishRequest} TestDirectoryPublishRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestDirectoryPublishRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestDirectoryPublishRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestDirectoryPublishRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestDirectoryPublishRequest} TestDirectoryPublishRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestDirectoryPublishRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestDirectoryPublishRequest message.
     * @function verify
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestDirectoryPublishRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        return null;
    };

    /**
     * Creates a TestDirectoryPublishRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestDirectoryPublishRequest} TestDirectoryPublishRequest
     */
    TestDirectoryPublishRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.TestDirectoryPublishRequest)
            return object;
        let message = new $root.TestDirectoryPublishRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        return message;
    };

    /**
     * Creates a plain object from a TestDirectoryPublishRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestDirectoryPublishRequest
     * @static
     * @param {TestDirectoryPublishRequest} message TestDirectoryPublishRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestDirectoryPublishRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        return object;
    };

    /**
     * Converts this TestDirectoryPublishRequest to JSON.
     * @function toJSON
     * @memberof TestDirectoryPublishRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestDirectoryPublishRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestDirectoryPublishRequest;
})();

export const TestDirectoryPublishResponse = $root.TestDirectoryPublishResponse = (() => {

    /**
     * Properties of a TestDirectoryPublishResponse.
     * @exports ITestDirectoryPublishResponse
     * @interface ITestDirectoryPublishResponse
     */

    /**
     * Constructs a new TestDirectoryPublishResponse.
     * @exports TestDirectoryPublishResponse
     * @classdesc Represents a TestDirectoryPublishResponse.
     * @implements ITestDirectoryPublishResponse
     * @constructor
     * @param {ITestDirectoryPublishResponse=} [properties] Properties to set
     */
    function TestDirectoryPublishResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new TestDirectoryPublishResponse instance using the specified properties.
     * @function create
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {ITestDirectoryPublishResponse=} [properties] Properties to set
     * @returns {TestDirectoryPublishResponse} TestDirectoryPublishResponse instance
     */
    TestDirectoryPublishResponse.create = function create(properties) {
        return new TestDirectoryPublishResponse(properties);
    };

    /**
     * Encodes the specified TestDirectoryPublishResponse message. Does not implicitly {@link TestDirectoryPublishResponse.verify|verify} messages.
     * @function encode
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {ITestDirectoryPublishResponse} message TestDirectoryPublishResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestDirectoryPublishResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified TestDirectoryPublishResponse message, length delimited. Does not implicitly {@link TestDirectoryPublishResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {ITestDirectoryPublishResponse} message TestDirectoryPublishResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestDirectoryPublishResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestDirectoryPublishResponse message from the specified reader or buffer.
     * @function decode
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestDirectoryPublishResponse} TestDirectoryPublishResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestDirectoryPublishResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestDirectoryPublishResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestDirectoryPublishResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestDirectoryPublishResponse} TestDirectoryPublishResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestDirectoryPublishResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestDirectoryPublishResponse message.
     * @function verify
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestDirectoryPublishResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a TestDirectoryPublishResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestDirectoryPublishResponse} TestDirectoryPublishResponse
     */
    TestDirectoryPublishResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.TestDirectoryPublishResponse)
            return object;
        return new $root.TestDirectoryPublishResponse();
    };

    /**
     * Creates a plain object from a TestDirectoryPublishResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestDirectoryPublishResponse
     * @static
     * @param {TestDirectoryPublishResponse} message TestDirectoryPublishResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestDirectoryPublishResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this TestDirectoryPublishResponse to JSON.
     * @function toJSON
     * @memberof TestDirectoryPublishResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestDirectoryPublishResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestDirectoryPublishResponse;
})();

export const DirectoryListing = $root.DirectoryListing = (() => {

    /**
     * Properties of a DirectoryListing.
     * @exports IDirectoryListing
     * @interface IDirectoryListing
     * @property {Uint8Array|null} [key] DirectoryListing key
     * @property {string|null} [mimeType] DirectoryListing mimeType
     * @property {string|null} [title] DirectoryListing title
     * @property {string|null} [description] DirectoryListing description
     * @property {Array.<string>|null} [tags] DirectoryListing tags
     * @property {Uint8Array|null} [extra] DirectoryListing extra
     */

    /**
     * Constructs a new DirectoryListing.
     * @exports DirectoryListing
     * @classdesc Represents a DirectoryListing.
     * @implements IDirectoryListing
     * @constructor
     * @param {IDirectoryListing=} [properties] Properties to set
     */
    function DirectoryListing(properties) {
        this.tags = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DirectoryListing key.
     * @member {Uint8Array} key
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.key = $util.newBuffer([]);

    /**
     * DirectoryListing mimeType.
     * @member {string} mimeType
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.mimeType = "";

    /**
     * DirectoryListing title.
     * @member {string} title
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.title = "";

    /**
     * DirectoryListing description.
     * @member {string} description
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.description = "";

    /**
     * DirectoryListing tags.
     * @member {Array.<string>} tags
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.tags = $util.emptyArray;

    /**
     * DirectoryListing extra.
     * @member {Uint8Array} extra
     * @memberof DirectoryListing
     * @instance
     */
    DirectoryListing.prototype.extra = $util.newBuffer([]);

    /**
     * Creates a new DirectoryListing instance using the specified properties.
     * @function create
     * @memberof DirectoryListing
     * @static
     * @param {IDirectoryListing=} [properties] Properties to set
     * @returns {DirectoryListing} DirectoryListing instance
     */
    DirectoryListing.create = function create(properties) {
        return new DirectoryListing(properties);
    };

    /**
     * Encodes the specified DirectoryListing message. Does not implicitly {@link DirectoryListing.verify|verify} messages.
     * @function encode
     * @memberof DirectoryListing
     * @static
     * @param {IDirectoryListing} message DirectoryListing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryListing.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimeType);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
        if (message.tags != null && message.tags.length)
            for (let i = 0; i < message.tags.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.extra);
        return writer;
    };

    /**
     * Encodes the specified DirectoryListing message, length delimited. Does not implicitly {@link DirectoryListing.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DirectoryListing
     * @static
     * @param {IDirectoryListing} message DirectoryListing message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DirectoryListing message from the specified reader or buffer.
     * @function decode
     * @memberof DirectoryListing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DirectoryListing} DirectoryListing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryListing();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.mimeType = reader.string();
                break;
            case 3:
                message.title = reader.string();
                break;
            case 4:
                message.description = reader.string();
                break;
            case 5:
                if (!(message.tags && message.tags.length))
                    message.tags = [];
                message.tags.push(reader.string());
                break;
            case 6:
                message.extra = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DirectoryListing message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DirectoryListing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DirectoryListing} DirectoryListing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DirectoryListing message.
     * @function verify
     * @memberof DirectoryListing
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DirectoryListing.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.mimeType != null && message.hasOwnProperty("mimeType"))
            if (!$util.isString(message.mimeType))
                return "mimeType: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.tags != null && message.hasOwnProperty("tags")) {
            if (!Array.isArray(message.tags))
                return "tags: array expected";
            for (let i = 0; i < message.tags.length; ++i)
                if (!$util.isString(message.tags[i]))
                    return "tags: string[] expected";
        }
        if (message.extra != null && message.hasOwnProperty("extra"))
            if (!(message.extra && typeof message.extra.length === "number" || $util.isString(message.extra)))
                return "extra: buffer expected";
        return null;
    };

    /**
     * Creates a DirectoryListing message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DirectoryListing
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DirectoryListing} DirectoryListing
     */
    DirectoryListing.fromObject = function fromObject(object) {
        if (object instanceof $root.DirectoryListing)
            return object;
        let message = new $root.DirectoryListing();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        if (object.mimeType != null)
            message.mimeType = String(object.mimeType);
        if (object.title != null)
            message.title = String(object.title);
        if (object.description != null)
            message.description = String(object.description);
        if (object.tags) {
            if (!Array.isArray(object.tags))
                throw TypeError(".DirectoryListing.tags: array expected");
            message.tags = [];
            for (let i = 0; i < object.tags.length; ++i)
                message.tags[i] = String(object.tags[i]);
        }
        if (object.extra != null)
            if (typeof object.extra === "string")
                $util.base64.decode(object.extra, message.extra = $util.newBuffer($util.base64.length(object.extra)), 0);
            else if (object.extra.length)
                message.extra = object.extra;
        return message;
    };

    /**
     * Creates a plain object from a DirectoryListing message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DirectoryListing
     * @static
     * @param {DirectoryListing} message DirectoryListing
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DirectoryListing.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.tags = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.mimeType = "";
            object.title = "";
            object.description = "";
            if (options.bytes === String)
                object.extra = "";
            else {
                object.extra = [];
                if (options.bytes !== Array)
                    object.extra = $util.newBuffer(object.extra);
            }
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.mimeType != null && message.hasOwnProperty("mimeType"))
            object.mimeType = message.mimeType;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.tags && message.tags.length) {
            object.tags = [];
            for (let j = 0; j < message.tags.length; ++j)
                object.tags[j] = message.tags[j];
        }
        if (message.extra != null && message.hasOwnProperty("extra"))
            object.extra = options.bytes === String ? $util.base64.encode(message.extra, 0, message.extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.extra) : message.extra;
        return object;
    };

    /**
     * Converts this DirectoryListing to JSON.
     * @function toJSON
     * @memberof DirectoryListing
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DirectoryListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DirectoryListing;
})();

export const DirectoryServerEvent = $root.DirectoryServerEvent = (() => {

    /**
     * Properties of a DirectoryServerEvent.
     * @exports IDirectoryServerEvent
     * @interface IDirectoryServerEvent
     * @property {DirectoryServerEvent.IPublish|null} [publish] DirectoryServerEvent publish
     * @property {DirectoryServerEvent.IUnpublish|null} [unpublish] DirectoryServerEvent unpublish
     * @property {DirectoryServerEvent.IViewerChange|null} [open] DirectoryServerEvent open
     * @property {DirectoryServerEvent.IPing|null} [ping] DirectoryServerEvent ping
     */

    /**
     * Constructs a new DirectoryServerEvent.
     * @exports DirectoryServerEvent
     * @classdesc Represents a DirectoryServerEvent.
     * @implements IDirectoryServerEvent
     * @constructor
     * @param {IDirectoryServerEvent=} [properties] Properties to set
     */
    function DirectoryServerEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DirectoryServerEvent publish.
     * @member {DirectoryServerEvent.IPublish|null|undefined} publish
     * @memberof DirectoryServerEvent
     * @instance
     */
    DirectoryServerEvent.prototype.publish = null;

    /**
     * DirectoryServerEvent unpublish.
     * @member {DirectoryServerEvent.IUnpublish|null|undefined} unpublish
     * @memberof DirectoryServerEvent
     * @instance
     */
    DirectoryServerEvent.prototype.unpublish = null;

    /**
     * DirectoryServerEvent open.
     * @member {DirectoryServerEvent.IViewerChange|null|undefined} open
     * @memberof DirectoryServerEvent
     * @instance
     */
    DirectoryServerEvent.prototype.open = null;

    /**
     * DirectoryServerEvent ping.
     * @member {DirectoryServerEvent.IPing|null|undefined} ping
     * @memberof DirectoryServerEvent
     * @instance
     */
    DirectoryServerEvent.prototype.ping = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * DirectoryServerEvent body.
     * @member {"publish"|"unpublish"|"open"|"ping"|undefined} body
     * @memberof DirectoryServerEvent
     * @instance
     */
    Object.defineProperty(DirectoryServerEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "open", "ping"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new DirectoryServerEvent instance using the specified properties.
     * @function create
     * @memberof DirectoryServerEvent
     * @static
     * @param {IDirectoryServerEvent=} [properties] Properties to set
     * @returns {DirectoryServerEvent} DirectoryServerEvent instance
     */
    DirectoryServerEvent.create = function create(properties) {
        return new DirectoryServerEvent(properties);
    };

    /**
     * Encodes the specified DirectoryServerEvent message. Does not implicitly {@link DirectoryServerEvent.verify|verify} messages.
     * @function encode
     * @memberof DirectoryServerEvent
     * @static
     * @param {IDirectoryServerEvent} message DirectoryServerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryServerEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.DirectoryServerEvent.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.DirectoryServerEvent.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.DirectoryServerEvent.ViewerChange.encode(message.open, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
            $root.DirectoryServerEvent.Ping.encode(message.ping, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DirectoryServerEvent message, length delimited. Does not implicitly {@link DirectoryServerEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DirectoryServerEvent
     * @static
     * @param {IDirectoryServerEvent} message DirectoryServerEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryServerEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DirectoryServerEvent message from the specified reader or buffer.
     * @function decode
     * @memberof DirectoryServerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DirectoryServerEvent} DirectoryServerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryServerEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryServerEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.DirectoryServerEvent.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.DirectoryServerEvent.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.open = $root.DirectoryServerEvent.ViewerChange.decode(reader, reader.uint32());
                break;
            case 4:
                message.ping = $root.DirectoryServerEvent.Ping.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DirectoryServerEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DirectoryServerEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DirectoryServerEvent} DirectoryServerEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryServerEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DirectoryServerEvent message.
     * @function verify
     * @memberof DirectoryServerEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DirectoryServerEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.DirectoryServerEvent.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryServerEvent.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryServerEvent.ViewerChange.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.ping != null && message.hasOwnProperty("ping")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryServerEvent.Ping.verify(message.ping);
                if (error)
                    return "ping." + error;
            }
        }
        return null;
    };

    /**
     * Creates a DirectoryServerEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DirectoryServerEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DirectoryServerEvent} DirectoryServerEvent
     */
    DirectoryServerEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.DirectoryServerEvent)
            return object;
        let message = new $root.DirectoryServerEvent();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".DirectoryServerEvent.publish: object expected");
            message.publish = $root.DirectoryServerEvent.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".DirectoryServerEvent.unpublish: object expected");
            message.unpublish = $root.DirectoryServerEvent.Unpublish.fromObject(object.unpublish);
        }
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".DirectoryServerEvent.open: object expected");
            message.open = $root.DirectoryServerEvent.ViewerChange.fromObject(object.open);
        }
        if (object.ping != null) {
            if (typeof object.ping !== "object")
                throw TypeError(".DirectoryServerEvent.ping: object expected");
            message.ping = $root.DirectoryServerEvent.Ping.fromObject(object.ping);
        }
        return message;
    };

    /**
     * Creates a plain object from a DirectoryServerEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DirectoryServerEvent
     * @static
     * @param {DirectoryServerEvent} message DirectoryServerEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DirectoryServerEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.DirectoryServerEvent.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.DirectoryServerEvent.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.DirectoryServerEvent.ViewerChange.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.ping != null && message.hasOwnProperty("ping")) {
            object.ping = $root.DirectoryServerEvent.Ping.toObject(message.ping, options);
            if (options.oneofs)
                object.body = "ping";
        }
        return object;
    };

    /**
     * Converts this DirectoryServerEvent to JSON.
     * @function toJSON
     * @memberof DirectoryServerEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DirectoryServerEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    DirectoryServerEvent.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof DirectoryServerEvent
         * @interface IPublish
         * @property {IDirectoryListing|null} [listing] Publish listing
         */

        /**
         * Constructs a new Publish.
         * @memberof DirectoryServerEvent
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {DirectoryServerEvent.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish listing.
         * @member {IDirectoryListing|null|undefined} listing
         * @memberof DirectoryServerEvent.Publish
         * @instance
         */
        Publish.prototype.listing = null;

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {DirectoryServerEvent.IPublish=} [properties] Properties to set
         * @returns {DirectoryServerEvent.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link DirectoryServerEvent.Publish.verify|verify} messages.
         * @function encode
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {DirectoryServerEvent.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listing != null && Object.hasOwnProperty.call(message, "listing"))
                $root.DirectoryListing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link DirectoryServerEvent.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {DirectoryServerEvent.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryServerEvent.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryServerEvent.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listing = $root.DirectoryListing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryServerEvent.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listing != null && message.hasOwnProperty("listing")) {
                let error = $root.DirectoryListing.verify(message.listing);
                if (error)
                    return "listing." + error;
            }
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryServerEvent.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryServerEvent.Publish)
                return object;
            let message = new $root.DirectoryServerEvent.Publish();
            if (object.listing != null) {
                if (typeof object.listing !== "object")
                    throw TypeError(".DirectoryServerEvent.Publish.listing: object expected");
                message.listing = $root.DirectoryListing.fromObject(object.listing);
            }
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryServerEvent.Publish
         * @static
         * @param {DirectoryServerEvent.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.listing = null;
            if (message.listing != null && message.hasOwnProperty("listing"))
                object.listing = $root.DirectoryListing.toObject(message.listing, options);
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof DirectoryServerEvent.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    DirectoryServerEvent.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof DirectoryServerEvent
         * @interface IUnpublish
         * @property {Uint8Array|null} [key] Unpublish key
         */

        /**
         * Constructs a new Unpublish.
         * @memberof DirectoryServerEvent
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {DirectoryServerEvent.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish key.
         * @member {Uint8Array} key
         * @memberof DirectoryServerEvent.Unpublish
         * @instance
         */
        Unpublish.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {DirectoryServerEvent.IUnpublish=} [properties] Properties to set
         * @returns {DirectoryServerEvent.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link DirectoryServerEvent.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {DirectoryServerEvent.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link DirectoryServerEvent.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {DirectoryServerEvent.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryServerEvent.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryServerEvent.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryServerEvent.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryServerEvent.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryServerEvent.Unpublish)
                return object;
            let message = new $root.DirectoryServerEvent.Unpublish();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryServerEvent.Unpublish
         * @static
         * @param {DirectoryServerEvent.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof DirectoryServerEvent.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    DirectoryServerEvent.ViewerChange = (function() {

        /**
         * Properties of a ViewerChange.
         * @memberof DirectoryServerEvent
         * @interface IViewerChange
         * @property {Uint8Array|null} [key] ViewerChange key
         * @property {number|null} [count] ViewerChange count
         */

        /**
         * Constructs a new ViewerChange.
         * @memberof DirectoryServerEvent
         * @classdesc Represents a ViewerChange.
         * @implements IViewerChange
         * @constructor
         * @param {DirectoryServerEvent.IViewerChange=} [properties] Properties to set
         */
        function ViewerChange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ViewerChange key.
         * @member {Uint8Array} key
         * @memberof DirectoryServerEvent.ViewerChange
         * @instance
         */
        ViewerChange.prototype.key = $util.newBuffer([]);

        /**
         * ViewerChange count.
         * @member {number} count
         * @memberof DirectoryServerEvent.ViewerChange
         * @instance
         */
        ViewerChange.prototype.count = 0;

        /**
         * Creates a new ViewerChange instance using the specified properties.
         * @function create
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {DirectoryServerEvent.IViewerChange=} [properties] Properties to set
         * @returns {DirectoryServerEvent.ViewerChange} ViewerChange instance
         */
        ViewerChange.create = function create(properties) {
            return new ViewerChange(properties);
        };

        /**
         * Encodes the specified ViewerChange message. Does not implicitly {@link DirectoryServerEvent.ViewerChange.verify|verify} messages.
         * @function encode
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {DirectoryServerEvent.IViewerChange} message ViewerChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewerChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ViewerChange message, length delimited. Does not implicitly {@link DirectoryServerEvent.ViewerChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {DirectoryServerEvent.IViewerChange} message ViewerChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ViewerChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ViewerChange message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryServerEvent.ViewerChange} ViewerChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewerChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryServerEvent.ViewerChange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ViewerChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryServerEvent.ViewerChange} ViewerChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ViewerChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ViewerChange message.
         * @function verify
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ViewerChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a ViewerChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryServerEvent.ViewerChange} ViewerChange
         */
        ViewerChange.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryServerEvent.ViewerChange)
                return object;
            let message = new $root.DirectoryServerEvent.ViewerChange();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ViewerChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryServerEvent.ViewerChange
         * @static
         * @param {DirectoryServerEvent.ViewerChange} message ViewerChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ViewerChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                object.count = 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this ViewerChange to JSON.
         * @function toJSON
         * @memberof DirectoryServerEvent.ViewerChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ViewerChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ViewerChange;
    })();

    DirectoryServerEvent.Ping = (function() {

        /**
         * Properties of a Ping.
         * @memberof DirectoryServerEvent
         * @interface IPing
         * @property {number|null} [time] Ping time
         */

        /**
         * Constructs a new Ping.
         * @memberof DirectoryServerEvent
         * @classdesc Represents a Ping.
         * @implements IPing
         * @constructor
         * @param {DirectoryServerEvent.IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ping time.
         * @member {number} time
         * @memberof DirectoryServerEvent.Ping
         * @instance
         */
        Ping.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {DirectoryServerEvent.IPing=} [properties] Properties to set
         * @returns {DirectoryServerEvent.Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };

        /**
         * Encodes the specified Ping message. Does not implicitly {@link DirectoryServerEvent.Ping.verify|verify} messages.
         * @function encode
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {DirectoryServerEvent.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link DirectoryServerEvent.Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {DirectoryServerEvent.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryServerEvent.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryServerEvent.Ping();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryServerEvent.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryServerEvent.Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryServerEvent.Ping)
                return object;
            let message = new $root.DirectoryServerEvent.Ping();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryServerEvent.Ping
         * @static
         * @param {DirectoryServerEvent.Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof DirectoryServerEvent.Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ping;
    })();

    return DirectoryServerEvent;
})();

export const CallDirectoryServerRequest = $root.CallDirectoryServerRequest = (() => {

    /**
     * Properties of a CallDirectoryServerRequest.
     * @exports ICallDirectoryServerRequest
     * @interface ICallDirectoryServerRequest
     * @property {Uint8Array|null} [networkKey] CallDirectoryServerRequest networkKey
     * @property {CallDirectoryServerRequest.IRemoveListing|null} [listing] CallDirectoryServerRequest listing
     */

    /**
     * Constructs a new CallDirectoryServerRequest.
     * @exports CallDirectoryServerRequest
     * @classdesc Represents a CallDirectoryServerRequest.
     * @implements ICallDirectoryServerRequest
     * @constructor
     * @param {ICallDirectoryServerRequest=} [properties] Properties to set
     */
    function CallDirectoryServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CallDirectoryServerRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof CallDirectoryServerRequest
     * @instance
     */
    CallDirectoryServerRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * CallDirectoryServerRequest listing.
     * @member {CallDirectoryServerRequest.IRemoveListing|null|undefined} listing
     * @memberof CallDirectoryServerRequest
     * @instance
     */
    CallDirectoryServerRequest.prototype.listing = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CallDirectoryServerRequest body.
     * @member {"listing"|undefined} body
     * @memberof CallDirectoryServerRequest
     * @instance
     */
    Object.defineProperty(CallDirectoryServerRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["listing"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CallDirectoryServerRequest instance using the specified properties.
     * @function create
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {ICallDirectoryServerRequest=} [properties] Properties to set
     * @returns {CallDirectoryServerRequest} CallDirectoryServerRequest instance
     */
    CallDirectoryServerRequest.create = function create(properties) {
        return new CallDirectoryServerRequest(properties);
    };

    /**
     * Encodes the specified CallDirectoryServerRequest message. Does not implicitly {@link CallDirectoryServerRequest.verify|verify} messages.
     * @function encode
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {ICallDirectoryServerRequest} message CallDirectoryServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallDirectoryServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKey);
        if (message.listing != null && Object.hasOwnProperty.call(message, "listing"))
            $root.CallDirectoryServerRequest.RemoveListing.encode(message.listing, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CallDirectoryServerRequest message, length delimited. Does not implicitly {@link CallDirectoryServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {ICallDirectoryServerRequest} message CallDirectoryServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CallDirectoryServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CallDirectoryServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CallDirectoryServerRequest} CallDirectoryServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallDirectoryServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallDirectoryServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkKey = reader.bytes();
                break;
            case 2:
                message.listing = $root.CallDirectoryServerRequest.RemoveListing.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CallDirectoryServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CallDirectoryServerRequest} CallDirectoryServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CallDirectoryServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CallDirectoryServerRequest message.
     * @function verify
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CallDirectoryServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.listing != null && message.hasOwnProperty("listing")) {
            properties.body = 1;
            {
                let error = $root.CallDirectoryServerRequest.RemoveListing.verify(message.listing);
                if (error)
                    return "listing." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CallDirectoryServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CallDirectoryServerRequest} CallDirectoryServerRequest
     */
    CallDirectoryServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CallDirectoryServerRequest)
            return object;
        let message = new $root.CallDirectoryServerRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.listing != null) {
            if (typeof object.listing !== "object")
                throw TypeError(".CallDirectoryServerRequest.listing: object expected");
            message.listing = $root.CallDirectoryServerRequest.RemoveListing.fromObject(object.listing);
        }
        return message;
    };

    /**
     * Creates a plain object from a CallDirectoryServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CallDirectoryServerRequest
     * @static
     * @param {CallDirectoryServerRequest} message CallDirectoryServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CallDirectoryServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.listing != null && message.hasOwnProperty("listing")) {
            object.listing = $root.CallDirectoryServerRequest.RemoveListing.toObject(message.listing, options);
            if (options.oneofs)
                object.body = "listing";
        }
        return object;
    };

    /**
     * Converts this CallDirectoryServerRequest to JSON.
     * @function toJSON
     * @memberof CallDirectoryServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CallDirectoryServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    CallDirectoryServerRequest.RemoveListing = (function() {

        /**
         * Properties of a RemoveListing.
         * @memberof CallDirectoryServerRequest
         * @interface IRemoveListing
         * @property {Uint8Array|null} [key] RemoveListing key
         */

        /**
         * Constructs a new RemoveListing.
         * @memberof CallDirectoryServerRequest
         * @classdesc Represents a RemoveListing.
         * @implements IRemoveListing
         * @constructor
         * @param {CallDirectoryServerRequest.IRemoveListing=} [properties] Properties to set
         */
        function RemoveListing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoveListing key.
         * @member {Uint8Array} key
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @instance
         */
        RemoveListing.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new RemoveListing instance using the specified properties.
         * @function create
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {CallDirectoryServerRequest.IRemoveListing=} [properties] Properties to set
         * @returns {CallDirectoryServerRequest.RemoveListing} RemoveListing instance
         */
        RemoveListing.create = function create(properties) {
            return new RemoveListing(properties);
        };

        /**
         * Encodes the specified RemoveListing message. Does not implicitly {@link CallDirectoryServerRequest.RemoveListing.verify|verify} messages.
         * @function encode
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {CallDirectoryServerRequest.IRemoveListing} message RemoveListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveListing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified RemoveListing message, length delimited. Does not implicitly {@link CallDirectoryServerRequest.RemoveListing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {CallDirectoryServerRequest.IRemoveListing} message RemoveListing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveListing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveListing message from the specified reader or buffer.
         * @function decode
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CallDirectoryServerRequest.RemoveListing} RemoveListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveListing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CallDirectoryServerRequest.RemoveListing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveListing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CallDirectoryServerRequest.RemoveListing} RemoveListing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveListing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveListing message.
         * @function verify
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveListing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a RemoveListing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CallDirectoryServerRequest.RemoveListing} RemoveListing
         */
        RemoveListing.fromObject = function fromObject(object) {
            if (object instanceof $root.CallDirectoryServerRequest.RemoveListing)
                return object;
            let message = new $root.CallDirectoryServerRequest.RemoveListing();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a RemoveListing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @static
         * @param {CallDirectoryServerRequest.RemoveListing} message RemoveListing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveListing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this RemoveListing to JSON.
         * @function toJSON
         * @memberof CallDirectoryServerRequest.RemoveListing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveListing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveListing;
    })();

    return CallDirectoryServerRequest;
})();

export const OpenDirectoryClientRequest = $root.OpenDirectoryClientRequest = (() => {

    /**
     * Properties of an OpenDirectoryClientRequest.
     * @exports IOpenDirectoryClientRequest
     * @interface IOpenDirectoryClientRequest
     * @property {Uint8Array|null} [networkKey] OpenDirectoryClientRequest networkKey
     * @property {Uint8Array|null} [serverKey] OpenDirectoryClientRequest serverKey
     */

    /**
     * Constructs a new OpenDirectoryClientRequest.
     * @exports OpenDirectoryClientRequest
     * @classdesc Represents an OpenDirectoryClientRequest.
     * @implements IOpenDirectoryClientRequest
     * @constructor
     * @param {IOpenDirectoryClientRequest=} [properties] Properties to set
     */
    function OpenDirectoryClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenDirectoryClientRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof OpenDirectoryClientRequest
     * @instance
     */
    OpenDirectoryClientRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * OpenDirectoryClientRequest serverKey.
     * @member {Uint8Array} serverKey
     * @memberof OpenDirectoryClientRequest
     * @instance
     */
    OpenDirectoryClientRequest.prototype.serverKey = $util.newBuffer([]);

    /**
     * Creates a new OpenDirectoryClientRequest instance using the specified properties.
     * @function create
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {IOpenDirectoryClientRequest=} [properties] Properties to set
     * @returns {OpenDirectoryClientRequest} OpenDirectoryClientRequest instance
     */
    OpenDirectoryClientRequest.create = function create(properties) {
        return new OpenDirectoryClientRequest(properties);
    };

    /**
     * Encodes the specified OpenDirectoryClientRequest message. Does not implicitly {@link OpenDirectoryClientRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {IOpenDirectoryClientRequest} message OpenDirectoryClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenDirectoryClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKey);
        if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverKey);
        return writer;
    };

    /**
     * Encodes the specified OpenDirectoryClientRequest message, length delimited. Does not implicitly {@link OpenDirectoryClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {IOpenDirectoryClientRequest} message OpenDirectoryClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenDirectoryClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenDirectoryClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenDirectoryClientRequest} OpenDirectoryClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenDirectoryClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenDirectoryClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkKey = reader.bytes();
                break;
            case 2:
                message.serverKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenDirectoryClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenDirectoryClientRequest} OpenDirectoryClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenDirectoryClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenDirectoryClientRequest message.
     * @function verify
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenDirectoryClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        if (message.serverKey != null && message.hasOwnProperty("serverKey"))
            if (!(message.serverKey && typeof message.serverKey.length === "number" || $util.isString(message.serverKey)))
                return "serverKey: buffer expected";
        return null;
    };

    /**
     * Creates an OpenDirectoryClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenDirectoryClientRequest} OpenDirectoryClientRequest
     */
    OpenDirectoryClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenDirectoryClientRequest)
            return object;
        let message = new $root.OpenDirectoryClientRequest();
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        if (object.serverKey != null)
            if (typeof object.serverKey === "string")
                $util.base64.decode(object.serverKey, message.serverKey = $util.newBuffer($util.base64.length(object.serverKey)), 0);
            else if (object.serverKey.length)
                message.serverKey = object.serverKey;
        return message;
    };

    /**
     * Creates a plain object from an OpenDirectoryClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenDirectoryClientRequest
     * @static
     * @param {OpenDirectoryClientRequest} message OpenDirectoryClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenDirectoryClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
            if (options.bytes === String)
                object.serverKey = "";
            else {
                object.serverKey = [];
                if (options.bytes !== Array)
                    object.serverKey = $util.newBuffer(object.serverKey);
            }
        }
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        if (message.serverKey != null && message.hasOwnProperty("serverKey"))
            object.serverKey = options.bytes === String ? $util.base64.encode(message.serverKey, 0, message.serverKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverKey) : message.serverKey;
        return object;
    };

    /**
     * Converts this OpenDirectoryClientRequest to JSON.
     * @function toJSON
     * @memberof OpenDirectoryClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenDirectoryClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OpenDirectoryClientRequest;
})();

export const DirectoryClientEvent = $root.DirectoryClientEvent = (() => {

    /**
     * Properties of a DirectoryClientEvent.
     * @exports IDirectoryClientEvent
     * @interface IDirectoryClientEvent
     * @property {DirectoryClientEvent.IPublish|null} [publish] DirectoryClientEvent publish
     * @property {DirectoryClientEvent.IUnpublish|null} [unpublish] DirectoryClientEvent unpublish
     * @property {DirectoryClientEvent.IJoin|null} [join] DirectoryClientEvent join
     * @property {DirectoryClientEvent.IPart|null} [part] DirectoryClientEvent part
     * @property {DirectoryClientEvent.IPing|null} [ping] DirectoryClientEvent ping
     */

    /**
     * Constructs a new DirectoryClientEvent.
     * @exports DirectoryClientEvent
     * @classdesc Represents a DirectoryClientEvent.
     * @implements IDirectoryClientEvent
     * @constructor
     * @param {IDirectoryClientEvent=} [properties] Properties to set
     */
    function DirectoryClientEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DirectoryClientEvent publish.
     * @member {DirectoryClientEvent.IPublish|null|undefined} publish
     * @memberof DirectoryClientEvent
     * @instance
     */
    DirectoryClientEvent.prototype.publish = null;

    /**
     * DirectoryClientEvent unpublish.
     * @member {DirectoryClientEvent.IUnpublish|null|undefined} unpublish
     * @memberof DirectoryClientEvent
     * @instance
     */
    DirectoryClientEvent.prototype.unpublish = null;

    /**
     * DirectoryClientEvent join.
     * @member {DirectoryClientEvent.IJoin|null|undefined} join
     * @memberof DirectoryClientEvent
     * @instance
     */
    DirectoryClientEvent.prototype.join = null;

    /**
     * DirectoryClientEvent part.
     * @member {DirectoryClientEvent.IPart|null|undefined} part
     * @memberof DirectoryClientEvent
     * @instance
     */
    DirectoryClientEvent.prototype.part = null;

    /**
     * DirectoryClientEvent ping.
     * @member {DirectoryClientEvent.IPing|null|undefined} ping
     * @memberof DirectoryClientEvent
     * @instance
     */
    DirectoryClientEvent.prototype.ping = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * DirectoryClientEvent body.
     * @member {"publish"|"unpublish"|"join"|"part"|"ping"|undefined} body
     * @memberof DirectoryClientEvent
     * @instance
     */
    Object.defineProperty(DirectoryClientEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "join", "part", "ping"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new DirectoryClientEvent instance using the specified properties.
     * @function create
     * @memberof DirectoryClientEvent
     * @static
     * @param {IDirectoryClientEvent=} [properties] Properties to set
     * @returns {DirectoryClientEvent} DirectoryClientEvent instance
     */
    DirectoryClientEvent.create = function create(properties) {
        return new DirectoryClientEvent(properties);
    };

    /**
     * Encodes the specified DirectoryClientEvent message. Does not implicitly {@link DirectoryClientEvent.verify|verify} messages.
     * @function encode
     * @memberof DirectoryClientEvent
     * @static
     * @param {IDirectoryClientEvent} message DirectoryClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryClientEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.DirectoryClientEvent.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.DirectoryClientEvent.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.join != null && Object.hasOwnProperty.call(message, "join"))
            $root.DirectoryClientEvent.Join.encode(message.join, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.part != null && Object.hasOwnProperty.call(message, "part"))
            $root.DirectoryClientEvent.Part.encode(message.part, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
            $root.DirectoryClientEvent.Ping.encode(message.ping, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DirectoryClientEvent message, length delimited. Does not implicitly {@link DirectoryClientEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DirectoryClientEvent
     * @static
     * @param {IDirectoryClientEvent} message DirectoryClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectoryClientEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DirectoryClientEvent message from the specified reader or buffer.
     * @function decode
     * @memberof DirectoryClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DirectoryClientEvent} DirectoryClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryClientEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.DirectoryClientEvent.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.DirectoryClientEvent.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.join = $root.DirectoryClientEvent.Join.decode(reader, reader.uint32());
                break;
            case 4:
                message.part = $root.DirectoryClientEvent.Part.decode(reader, reader.uint32());
                break;
            case 5:
                message.ping = $root.DirectoryClientEvent.Ping.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DirectoryClientEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DirectoryClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DirectoryClientEvent} DirectoryClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectoryClientEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DirectoryClientEvent message.
     * @function verify
     * @memberof DirectoryClientEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DirectoryClientEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.DirectoryClientEvent.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryClientEvent.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.join != null && message.hasOwnProperty("join")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryClientEvent.Join.verify(message.join);
                if (error)
                    return "join." + error;
            }
        }
        if (message.part != null && message.hasOwnProperty("part")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryClientEvent.Part.verify(message.part);
                if (error)
                    return "part." + error;
            }
        }
        if (message.ping != null && message.hasOwnProperty("ping")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.DirectoryClientEvent.Ping.verify(message.ping);
                if (error)
                    return "ping." + error;
            }
        }
        return null;
    };

    /**
     * Creates a DirectoryClientEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DirectoryClientEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DirectoryClientEvent} DirectoryClientEvent
     */
    DirectoryClientEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.DirectoryClientEvent)
            return object;
        let message = new $root.DirectoryClientEvent();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".DirectoryClientEvent.publish: object expected");
            message.publish = $root.DirectoryClientEvent.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".DirectoryClientEvent.unpublish: object expected");
            message.unpublish = $root.DirectoryClientEvent.Unpublish.fromObject(object.unpublish);
        }
        if (object.join != null) {
            if (typeof object.join !== "object")
                throw TypeError(".DirectoryClientEvent.join: object expected");
            message.join = $root.DirectoryClientEvent.Join.fromObject(object.join);
        }
        if (object.part != null) {
            if (typeof object.part !== "object")
                throw TypeError(".DirectoryClientEvent.part: object expected");
            message.part = $root.DirectoryClientEvent.Part.fromObject(object.part);
        }
        if (object.ping != null) {
            if (typeof object.ping !== "object")
                throw TypeError(".DirectoryClientEvent.ping: object expected");
            message.ping = $root.DirectoryClientEvent.Ping.fromObject(object.ping);
        }
        return message;
    };

    /**
     * Creates a plain object from a DirectoryClientEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DirectoryClientEvent
     * @static
     * @param {DirectoryClientEvent} message DirectoryClientEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DirectoryClientEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.DirectoryClientEvent.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.DirectoryClientEvent.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.join != null && message.hasOwnProperty("join")) {
            object.join = $root.DirectoryClientEvent.Join.toObject(message.join, options);
            if (options.oneofs)
                object.body = "join";
        }
        if (message.part != null && message.hasOwnProperty("part")) {
            object.part = $root.DirectoryClientEvent.Part.toObject(message.part, options);
            if (options.oneofs)
                object.body = "part";
        }
        if (message.ping != null && message.hasOwnProperty("ping")) {
            object.ping = $root.DirectoryClientEvent.Ping.toObject(message.ping, options);
            if (options.oneofs)
                object.body = "ping";
        }
        return object;
    };

    /**
     * Converts this DirectoryClientEvent to JSON.
     * @function toJSON
     * @memberof DirectoryClientEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DirectoryClientEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    DirectoryClientEvent.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof DirectoryClientEvent
         * @interface IPublish
         * @property {IDirectoryListing|null} [listing] Publish listing
         * @property {Uint8Array|null} [signature] Publish signature
         */

        /**
         * Constructs a new Publish.
         * @memberof DirectoryClientEvent
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {DirectoryClientEvent.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish listing.
         * @member {IDirectoryListing|null|undefined} listing
         * @memberof DirectoryClientEvent.Publish
         * @instance
         */
        Publish.prototype.listing = null;

        /**
         * Publish signature.
         * @member {Uint8Array} signature
         * @memberof DirectoryClientEvent.Publish
         * @instance
         */
        Publish.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {DirectoryClientEvent.IPublish=} [properties] Properties to set
         * @returns {DirectoryClientEvent.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link DirectoryClientEvent.Publish.verify|verify} messages.
         * @function encode
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {DirectoryClientEvent.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.listing != null && Object.hasOwnProperty.call(message, "listing"))
                $root.DirectoryListing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link DirectoryClientEvent.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {DirectoryClientEvent.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryClientEvent.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.listing = $root.DirectoryListing.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryClientEvent.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.listing != null && message.hasOwnProperty("listing")) {
                let error = $root.DirectoryListing.verify(message.listing);
                if (error)
                    return "listing." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryClientEvent.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryClientEvent.Publish)
                return object;
            let message = new $root.DirectoryClientEvent.Publish();
            if (object.listing != null) {
                if (typeof object.listing !== "object")
                    throw TypeError(".DirectoryClientEvent.Publish.listing: object expected");
                message.listing = $root.DirectoryListing.fromObject(object.listing);
            }
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryClientEvent.Publish
         * @static
         * @param {DirectoryClientEvent.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.listing = null;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.listing != null && message.hasOwnProperty("listing"))
                object.listing = $root.DirectoryListing.toObject(message.listing, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof DirectoryClientEvent.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    DirectoryClientEvent.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof DirectoryClientEvent
         * @interface IUnpublish
         * @property {Uint8Array|null} [key] Unpublish key
         */

        /**
         * Constructs a new Unpublish.
         * @memberof DirectoryClientEvent
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {DirectoryClientEvent.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish key.
         * @member {Uint8Array} key
         * @memberof DirectoryClientEvent.Unpublish
         * @instance
         */
        Unpublish.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {DirectoryClientEvent.IUnpublish=} [properties] Properties to set
         * @returns {DirectoryClientEvent.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link DirectoryClientEvent.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {DirectoryClientEvent.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link DirectoryClientEvent.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {DirectoryClientEvent.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryClientEvent.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryClientEvent.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryClientEvent.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryClientEvent.Unpublish)
                return object;
            let message = new $root.DirectoryClientEvent.Unpublish();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryClientEvent.Unpublish
         * @static
         * @param {DirectoryClientEvent.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof DirectoryClientEvent.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    DirectoryClientEvent.Join = (function() {

        /**
         * Properties of a Join.
         * @memberof DirectoryClientEvent
         * @interface IJoin
         * @property {Uint8Array|null} [key] Join key
         */

        /**
         * Constructs a new Join.
         * @memberof DirectoryClientEvent
         * @classdesc Represents a Join.
         * @implements IJoin
         * @constructor
         * @param {DirectoryClientEvent.IJoin=} [properties] Properties to set
         */
        function Join(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Join key.
         * @member {Uint8Array} key
         * @memberof DirectoryClientEvent.Join
         * @instance
         */
        Join.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new Join instance using the specified properties.
         * @function create
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {DirectoryClientEvent.IJoin=} [properties] Properties to set
         * @returns {DirectoryClientEvent.Join} Join instance
         */
        Join.create = function create(properties) {
            return new Join(properties);
        };

        /**
         * Encodes the specified Join message. Does not implicitly {@link DirectoryClientEvent.Join.verify|verify} messages.
         * @function encode
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {DirectoryClientEvent.IJoin} message Join message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Join.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified Join message, length delimited. Does not implicitly {@link DirectoryClientEvent.Join.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {DirectoryClientEvent.IJoin} message Join message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Join.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Join message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryClientEvent.Join} Join
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Join.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent.Join();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Join message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryClientEvent.Join} Join
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Join.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Join message.
         * @function verify
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Join.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a Join message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryClientEvent.Join} Join
         */
        Join.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryClientEvent.Join)
                return object;
            let message = new $root.DirectoryClientEvent.Join();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a Join message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryClientEvent.Join
         * @static
         * @param {DirectoryClientEvent.Join} message Join
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Join.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this Join to JSON.
         * @function toJSON
         * @memberof DirectoryClientEvent.Join
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Join.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Join;
    })();

    DirectoryClientEvent.Part = (function() {

        /**
         * Properties of a Part.
         * @memberof DirectoryClientEvent
         * @interface IPart
         * @property {Uint8Array|null} [key] Part key
         */

        /**
         * Constructs a new Part.
         * @memberof DirectoryClientEvent
         * @classdesc Represents a Part.
         * @implements IPart
         * @constructor
         * @param {DirectoryClientEvent.IPart=} [properties] Properties to set
         */
        function Part(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Part key.
         * @member {Uint8Array} key
         * @memberof DirectoryClientEvent.Part
         * @instance
         */
        Part.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new Part instance using the specified properties.
         * @function create
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {DirectoryClientEvent.IPart=} [properties] Properties to set
         * @returns {DirectoryClientEvent.Part} Part instance
         */
        Part.create = function create(properties) {
            return new Part(properties);
        };

        /**
         * Encodes the specified Part message. Does not implicitly {@link DirectoryClientEvent.Part.verify|verify} messages.
         * @function encode
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {DirectoryClientEvent.IPart} message Part message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Part.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified Part message, length delimited. Does not implicitly {@link DirectoryClientEvent.Part.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {DirectoryClientEvent.IPart} message Part message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Part.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Part message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryClientEvent.Part} Part
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Part.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent.Part();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Part message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryClientEvent.Part} Part
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Part.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Part message.
         * @function verify
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Part.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a Part message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryClientEvent.Part} Part
         */
        Part.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryClientEvent.Part)
                return object;
            let message = new $root.DirectoryClientEvent.Part();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a Part message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryClientEvent.Part
         * @static
         * @param {DirectoryClientEvent.Part} message Part
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Part.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this Part to JSON.
         * @function toJSON
         * @memberof DirectoryClientEvent.Part
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Part.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Part;
    })();

    DirectoryClientEvent.Ping = (function() {

        /**
         * Properties of a Ping.
         * @memberof DirectoryClientEvent
         * @interface IPing
         * @property {number|null} [time] Ping time
         */

        /**
         * Constructs a new Ping.
         * @memberof DirectoryClientEvent
         * @classdesc Represents a Ping.
         * @implements IPing
         * @constructor
         * @param {DirectoryClientEvent.IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ping time.
         * @member {number} time
         * @memberof DirectoryClientEvent.Ping
         * @instance
         */
        Ping.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {DirectoryClientEvent.IPing=} [properties] Properties to set
         * @returns {DirectoryClientEvent.Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };

        /**
         * Encodes the specified Ping message. Does not implicitly {@link DirectoryClientEvent.Ping.verify|verify} messages.
         * @function encode
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {DirectoryClientEvent.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link DirectoryClientEvent.Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {DirectoryClientEvent.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DirectoryClientEvent.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectoryClientEvent.Ping();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DirectoryClientEvent.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DirectoryClientEvent.Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.DirectoryClientEvent.Ping)
                return object;
            let message = new $root.DirectoryClientEvent.Ping();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DirectoryClientEvent.Ping
         * @static
         * @param {DirectoryClientEvent.Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof DirectoryClientEvent.Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ping;
    })();

    return DirectoryClientEvent;
})();

export const HashTableMessage = $root.HashTableMessage = (() => {

    /**
     * Properties of a HashTableMessage.
     * @exports IHashTableMessage
     * @interface IHashTableMessage
     * @property {HashTableMessage.IPublish|null} [publish] HashTableMessage publish
     * @property {HashTableMessage.IUnpublish|null} [unpublish] HashTableMessage unpublish
     * @property {HashTableMessage.IGetRequest|null} [getRequest] HashTableMessage getRequest
     * @property {HashTableMessage.IGetResponse|null} [getResponse] HashTableMessage getResponse
     */

    /**
     * Constructs a new HashTableMessage.
     * @exports HashTableMessage
     * @classdesc Represents a HashTableMessage.
     * @implements IHashTableMessage
     * @constructor
     * @param {IHashTableMessage=} [properties] Properties to set
     */
    function HashTableMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HashTableMessage publish.
     * @member {HashTableMessage.IPublish|null|undefined} publish
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.publish = null;

    /**
     * HashTableMessage unpublish.
     * @member {HashTableMessage.IUnpublish|null|undefined} unpublish
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.unpublish = null;

    /**
     * HashTableMessage getRequest.
     * @member {HashTableMessage.IGetRequest|null|undefined} getRequest
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.getRequest = null;

    /**
     * HashTableMessage getResponse.
     * @member {HashTableMessage.IGetResponse|null|undefined} getResponse
     * @memberof HashTableMessage
     * @instance
     */
    HashTableMessage.prototype.getResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * HashTableMessage body.
     * @member {"publish"|"unpublish"|"getRequest"|"getResponse"|undefined} body
     * @memberof HashTableMessage
     * @instance
     */
    Object.defineProperty(HashTableMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "getRequest", "getResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new HashTableMessage instance using the specified properties.
     * @function create
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage=} [properties] Properties to set
     * @returns {HashTableMessage} HashTableMessage instance
     */
    HashTableMessage.create = function create(properties) {
        return new HashTableMessage(properties);
    };

    /**
     * Encodes the specified HashTableMessage message. Does not implicitly {@link HashTableMessage.verify|verify} messages.
     * @function encode
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage} message HashTableMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashTableMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.HashTableMessage.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.HashTableMessage.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.getRequest != null && Object.hasOwnProperty.call(message, "getRequest"))
            $root.HashTableMessage.GetRequest.encode(message.getRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.getResponse != null && Object.hasOwnProperty.call(message, "getResponse"))
            $root.HashTableMessage.GetResponse.encode(message.getResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified HashTableMessage message, length delimited. Does not implicitly {@link HashTableMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HashTableMessage
     * @static
     * @param {IHashTableMessage} message HashTableMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashTableMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HashTableMessage message from the specified reader or buffer.
     * @function decode
     * @memberof HashTableMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HashTableMessage} HashTableMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashTableMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.HashTableMessage.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.HashTableMessage.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.getRequest = $root.HashTableMessage.GetRequest.decode(reader, reader.uint32());
                break;
            case 4:
                message.getResponse = $root.HashTableMessage.GetResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HashTableMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HashTableMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HashTableMessage} HashTableMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashTableMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HashTableMessage message.
     * @function verify
     * @memberof HashTableMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HashTableMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.HashTableMessage.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.getRequest != null && message.hasOwnProperty("getRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.GetRequest.verify(message.getRequest);
                if (error)
                    return "getRequest." + error;
            }
        }
        if (message.getResponse != null && message.hasOwnProperty("getResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.HashTableMessage.GetResponse.verify(message.getResponse);
                if (error)
                    return "getResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a HashTableMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HashTableMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HashTableMessage} HashTableMessage
     */
    HashTableMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.HashTableMessage)
            return object;
        let message = new $root.HashTableMessage();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".HashTableMessage.publish: object expected");
            message.publish = $root.HashTableMessage.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".HashTableMessage.unpublish: object expected");
            message.unpublish = $root.HashTableMessage.Unpublish.fromObject(object.unpublish);
        }
        if (object.getRequest != null) {
            if (typeof object.getRequest !== "object")
                throw TypeError(".HashTableMessage.getRequest: object expected");
            message.getRequest = $root.HashTableMessage.GetRequest.fromObject(object.getRequest);
        }
        if (object.getResponse != null) {
            if (typeof object.getResponse !== "object")
                throw TypeError(".HashTableMessage.getResponse: object expected");
            message.getResponse = $root.HashTableMessage.GetResponse.fromObject(object.getResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a HashTableMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HashTableMessage
     * @static
     * @param {HashTableMessage} message HashTableMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HashTableMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.HashTableMessage.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.HashTableMessage.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.getRequest != null && message.hasOwnProperty("getRequest")) {
            object.getRequest = $root.HashTableMessage.GetRequest.toObject(message.getRequest, options);
            if (options.oneofs)
                object.body = "getRequest";
        }
        if (message.getResponse != null && message.hasOwnProperty("getResponse")) {
            object.getResponse = $root.HashTableMessage.GetResponse.toObject(message.getResponse, options);
            if (options.oneofs)
                object.body = "getResponse";
        }
        return object;
    };

    /**
     * Converts this HashTableMessage to JSON.
     * @function toJSON
     * @memberof HashTableMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HashTableMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    HashTableMessage.Record = (function() {

        /**
         * Properties of a Record.
         * @memberof HashTableMessage
         * @interface IRecord
         * @property {Uint8Array|null} [key] Record key
         * @property {Uint8Array|null} [salt] Record salt
         * @property {Uint8Array|null} [value] Record value
         * @property {number|null} [timestamp] Record timestamp
         * @property {Uint8Array|null} [signature] Record signature
         */

        /**
         * Constructs a new Record.
         * @memberof HashTableMessage
         * @classdesc Represents a Record.
         * @implements IRecord
         * @constructor
         * @param {HashTableMessage.IRecord=} [properties] Properties to set
         */
        function Record(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Record key.
         * @member {Uint8Array} key
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.key = $util.newBuffer([]);

        /**
         * Record salt.
         * @member {Uint8Array} salt
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.salt = $util.newBuffer([]);

        /**
         * Record value.
         * @member {Uint8Array} value
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.value = $util.newBuffer([]);

        /**
         * Record timestamp.
         * @member {number} timestamp
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Record signature.
         * @member {Uint8Array} signature
         * @memberof HashTableMessage.Record
         * @instance
         */
        Record.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Record instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord=} [properties] Properties to set
         * @returns {HashTableMessage.Record} Record instance
         */
        Record.create = function create(properties) {
            return new Record(properties);
        };

        /**
         * Encodes the specified Record message. Does not implicitly {@link HashTableMessage.Record.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified Record message, length delimited. Does not implicitly {@link HashTableMessage.Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Record message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Record();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.value = reader.bytes();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Record message.
         * @function verify
         * @memberof HashTableMessage.Record
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Record.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Record} Record
         */
        Record.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Record)
                return object;
            let message = new $root.HashTableMessage.Record();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Record
         * @static
         * @param {HashTableMessage.Record} message Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this Record to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Record;
    })();

    HashTableMessage.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof HashTableMessage
         * @interface IPublish
         * @property {HashTableMessage.IRecord|null} [record] Publish record
         */

        /**
         * Constructs a new Publish.
         * @memberof HashTableMessage
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {HashTableMessage.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.Publish
         * @instance
         */
        Publish.prototype.record = null;

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish=} [properties] Properties to set
         * @returns {HashTableMessage.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link HashTableMessage.Publish.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link HashTableMessage.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof HashTableMessage.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Publish)
                return object;
            let message = new $root.HashTableMessage.Publish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.Publish.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Publish
         * @static
         * @param {HashTableMessage.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    HashTableMessage.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof HashTableMessage
         * @interface IUnpublish
         * @property {HashTableMessage.IRecord|null} [record] Unpublish record
         */

        /**
         * Constructs a new Unpublish.
         * @memberof HashTableMessage
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {HashTableMessage.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.Unpublish
         * @instance
         */
        Unpublish.prototype.record = null;

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish=} [properties] Properties to set
         * @returns {HashTableMessage.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link HashTableMessage.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link HashTableMessage.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.Unpublish)
                return object;
            let message = new $root.HashTableMessage.Unpublish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.Unpublish.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.Unpublish
         * @static
         * @param {HashTableMessage.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof HashTableMessage.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    HashTableMessage.GetRequest = (function() {

        /**
         * Properties of a GetRequest.
         * @memberof HashTableMessage
         * @interface IGetRequest
         * @property {number|null} [requestId] GetRequest requestId
         * @property {Uint8Array|null} [hash] GetRequest hash
         */

        /**
         * Constructs a new GetRequest.
         * @memberof HashTableMessage
         * @classdesc Represents a GetRequest.
         * @implements IGetRequest
         * @constructor
         * @param {HashTableMessage.IGetRequest=} [properties] Properties to set
         */
        function GetRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRequest requestId.
         * @member {number} requestId
         * @memberof HashTableMessage.GetRequest
         * @instance
         */
        GetRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetRequest hash.
         * @member {Uint8Array} hash
         * @memberof HashTableMessage.GetRequest
         * @instance
         */
        GetRequest.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new GetRequest instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest=} [properties] Properties to set
         * @returns {HashTableMessage.GetRequest} GetRequest instance
         */
        GetRequest.create = function create(properties) {
            return new GetRequest(properties);
        };

        /**
         * Encodes the specified GetRequest message. Does not implicitly {@link HashTableMessage.GetRequest.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest} message GetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified GetRequest message, length delimited. Does not implicitly {@link HashTableMessage.GetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.IGetRequest} message GetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.GetRequest} GetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.GetRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.GetRequest} GetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRequest message.
         * @function verify
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a GetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.GetRequest} GetRequest
         */
        GetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.GetRequest)
                return object;
            let message = new $root.HashTableMessage.GetRequest();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a GetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.GetRequest
         * @static
         * @param {HashTableMessage.GetRequest} message GetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this GetRequest to JSON.
         * @function toJSON
         * @memberof HashTableMessage.GetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRequest;
    })();

    HashTableMessage.GetResponse = (function() {

        /**
         * Properties of a GetResponse.
         * @memberof HashTableMessage
         * @interface IGetResponse
         * @property {number|null} [requestId] GetResponse requestId
         * @property {HashTableMessage.IRecord|null} [record] GetResponse record
         */

        /**
         * Constructs a new GetResponse.
         * @memberof HashTableMessage
         * @classdesc Represents a GetResponse.
         * @implements IGetResponse
         * @constructor
         * @param {HashTableMessage.IGetResponse=} [properties] Properties to set
         */
        function GetResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetResponse requestId.
         * @member {number} requestId
         * @memberof HashTableMessage.GetResponse
         * @instance
         */
        GetResponse.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetResponse record.
         * @member {HashTableMessage.IRecord|null|undefined} record
         * @memberof HashTableMessage.GetResponse
         * @instance
         */
        GetResponse.prototype.record = null;

        /**
         * Creates a new GetResponse instance using the specified properties.
         * @function create
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse=} [properties] Properties to set
         * @returns {HashTableMessage.GetResponse} GetResponse instance
         */
        GetResponse.create = function create(properties) {
            return new GetResponse(properties);
        };

        /**
         * Encodes the specified GetResponse message. Does not implicitly {@link HashTableMessage.GetResponse.verify|verify} messages.
         * @function encode
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse} message GetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.HashTableMessage.Record.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetResponse message, length delimited. Does not implicitly {@link HashTableMessage.GetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.IGetResponse} message GetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HashTableMessage.GetResponse} GetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashTableMessage.GetResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.record = $root.HashTableMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HashTableMessage.GetResponse} GetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetResponse message.
         * @function verify
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.HashTableMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a GetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HashTableMessage.GetResponse} GetResponse
         */
        GetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.HashTableMessage.GetResponse)
                return object;
            let message = new $root.HashTableMessage.GetResponse();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".HashTableMessage.GetResponse.record: object expected");
                message.record = $root.HashTableMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HashTableMessage.GetResponse
         * @static
         * @param {HashTableMessage.GetResponse} message GetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                object.record = null;
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.HashTableMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this GetResponse to JSON.
         * @function toJSON
         * @memberof HashTableMessage.GetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetResponse;
    })();

    return HashTableMessage;
})();

export const ServerConfig = $root.ServerConfig = (() => {

    /**
     * Properties of a ServerConfig.
     * @exports IServerConfig
     * @interface IServerConfig
     * @property {IKey|null} [key] ServerConfig key
     * @property {number|null} [nameChangeQuota] ServerConfig nameChangeQuota
     * @property {google.protobuf.IDuration|null} [tokenTtl] ServerConfig tokenTtl
     * @property {Array.<string>|null} [roles] ServerConfig roles
     */

    /**
     * Constructs a new ServerConfig.
     * @exports ServerConfig
     * @classdesc Represents a ServerConfig.
     * @implements IServerConfig
     * @constructor
     * @param {IServerConfig=} [properties] Properties to set
     */
    function ServerConfig(properties) {
        this.roles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServerConfig key.
     * @member {IKey|null|undefined} key
     * @memberof ServerConfig
     * @instance
     */
    ServerConfig.prototype.key = null;

    /**
     * ServerConfig nameChangeQuota.
     * @member {number} nameChangeQuota
     * @memberof ServerConfig
     * @instance
     */
    ServerConfig.prototype.nameChangeQuota = 0;

    /**
     * ServerConfig tokenTtl.
     * @member {google.protobuf.IDuration|null|undefined} tokenTtl
     * @memberof ServerConfig
     * @instance
     */
    ServerConfig.prototype.tokenTtl = null;

    /**
     * ServerConfig roles.
     * @member {Array.<string>} roles
     * @memberof ServerConfig
     * @instance
     */
    ServerConfig.prototype.roles = $util.emptyArray;

    /**
     * Creates a new ServerConfig instance using the specified properties.
     * @function create
     * @memberof ServerConfig
     * @static
     * @param {IServerConfig=} [properties] Properties to set
     * @returns {ServerConfig} ServerConfig instance
     */
    ServerConfig.create = function create(properties) {
        return new ServerConfig(properties);
    };

    /**
     * Encodes the specified ServerConfig message. Does not implicitly {@link ServerConfig.verify|verify} messages.
     * @function encode
     * @memberof ServerConfig
     * @static
     * @param {IServerConfig} message ServerConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.nameChangeQuota != null && Object.hasOwnProperty.call(message, "nameChangeQuota"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.nameChangeQuota);
        if (message.tokenTtl != null && Object.hasOwnProperty.call(message, "tokenTtl"))
            $root.google.protobuf.Duration.encode(message.tokenTtl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.roles != null && message.roles.length)
            for (let i = 0; i < message.roles.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.roles[i]);
        return writer;
    };

    /**
     * Encodes the specified ServerConfig message, length delimited. Does not implicitly {@link ServerConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServerConfig
     * @static
     * @param {IServerConfig} message ServerConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServerConfig message from the specified reader or buffer.
     * @function decode
     * @memberof ServerConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerConfig} ServerConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerConfig();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 2:
                message.nameChangeQuota = reader.uint32();
                break;
            case 3:
                message.tokenTtl = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.roles && message.roles.length))
                    message.roles = [];
                message.roles.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServerConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServerConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServerConfig} ServerConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServerConfig message.
     * @function verify
     * @memberof ServerConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServerConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.nameChangeQuota != null && message.hasOwnProperty("nameChangeQuota"))
            if (!$util.isInteger(message.nameChangeQuota))
                return "nameChangeQuota: integer expected";
        if (message.tokenTtl != null && message.hasOwnProperty("tokenTtl")) {
            let error = $root.google.protobuf.Duration.verify(message.tokenTtl);
            if (error)
                return "tokenTtl." + error;
        }
        if (message.roles != null && message.hasOwnProperty("roles")) {
            if (!Array.isArray(message.roles))
                return "roles: array expected";
            for (let i = 0; i < message.roles.length; ++i)
                if (!$util.isString(message.roles[i]))
                    return "roles: string[] expected";
        }
        return null;
    };

    /**
     * Creates a ServerConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServerConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServerConfig} ServerConfig
     */
    ServerConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.ServerConfig)
            return object;
        let message = new $root.ServerConfig();
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".ServerConfig.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.nameChangeQuota != null)
            message.nameChangeQuota = object.nameChangeQuota >>> 0;
        if (object.tokenTtl != null) {
            if (typeof object.tokenTtl !== "object")
                throw TypeError(".ServerConfig.tokenTtl: object expected");
            message.tokenTtl = $root.google.protobuf.Duration.fromObject(object.tokenTtl);
        }
        if (object.roles) {
            if (!Array.isArray(object.roles))
                throw TypeError(".ServerConfig.roles: array expected");
            message.roles = [];
            for (let i = 0; i < object.roles.length; ++i)
                message.roles[i] = String(object.roles[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a ServerConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServerConfig
     * @static
     * @param {ServerConfig} message ServerConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServerConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.roles = [];
        if (options.defaults) {
            object.key = null;
            object.nameChangeQuota = 0;
            object.tokenTtl = null;
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.nameChangeQuota != null && message.hasOwnProperty("nameChangeQuota"))
            object.nameChangeQuota = message.nameChangeQuota;
        if (message.tokenTtl != null && message.hasOwnProperty("tokenTtl"))
            object.tokenTtl = $root.google.protobuf.Duration.toObject(message.tokenTtl, options);
        if (message.roles && message.roles.length) {
            object.roles = [];
            for (let j = 0; j < message.roles.length; ++j)
                object.roles[j] = message.roles[j];
        }
        return object;
    };

    /**
     * Converts this ServerConfig to JSON.
     * @function toJSON
     * @memberof ServerConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServerConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServerConfig;
})();

export const NickservNick = $root.NickservNick = (() => {

    /**
     * Properties of a NickservNick.
     * @exports INickservNick
     * @interface INickservNick
     * @property {number|null} [id] NickservNick id
     * @property {Uint8Array|null} [key] NickservNick key
     * @property {string|null} [nick] NickservNick nick
     * @property {number|null} [remainingNameChangeQuota] NickservNick remainingNameChangeQuota
     * @property {number|null} [updatedTimestamp] NickservNick updatedTimestamp
     * @property {number|null} [createdTimestamp] NickservNick createdTimestamp
     * @property {Array.<string>|null} [roles] NickservNick roles
     */

    /**
     * Constructs a new NickservNick.
     * @exports NickservNick
     * @classdesc Represents a NickservNick.
     * @implements INickservNick
     * @constructor
     * @param {INickservNick=} [properties] Properties to set
     */
    function NickservNick(properties) {
        this.roles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NickservNick id.
     * @member {number} id
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NickservNick key.
     * @member {Uint8Array} key
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.key = $util.newBuffer([]);

    /**
     * NickservNick nick.
     * @member {string} nick
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.nick = "";

    /**
     * NickservNick remainingNameChangeQuota.
     * @member {number} remainingNameChangeQuota
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.remainingNameChangeQuota = 0;

    /**
     * NickservNick updatedTimestamp.
     * @member {number} updatedTimestamp
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.updatedTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NickservNick createdTimestamp.
     * @member {number} createdTimestamp
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.createdTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NickservNick roles.
     * @member {Array.<string>} roles
     * @memberof NickservNick
     * @instance
     */
    NickservNick.prototype.roles = $util.emptyArray;

    /**
     * Creates a new NickservNick instance using the specified properties.
     * @function create
     * @memberof NickservNick
     * @static
     * @param {INickservNick=} [properties] Properties to set
     * @returns {NickservNick} NickservNick instance
     */
    NickservNick.create = function create(properties) {
        return new NickservNick(properties);
    };

    /**
     * Encodes the specified NickservNick message. Does not implicitly {@link NickservNick.verify|verify} messages.
     * @function encode
     * @memberof NickservNick
     * @static
     * @param {INickservNick} message NickservNick message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickservNick.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
        if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
        if (message.remainingNameChangeQuota != null && Object.hasOwnProperty.call(message, "remainingNameChangeQuota"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.remainingNameChangeQuota);
        if (message.updatedTimestamp != null && Object.hasOwnProperty.call(message, "updatedTimestamp"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.updatedTimestamp);
        if (message.createdTimestamp != null && Object.hasOwnProperty.call(message, "createdTimestamp"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.createdTimestamp);
        if (message.roles != null && message.roles.length)
            for (let i = 0; i < message.roles.length; ++i)
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.roles[i]);
        return writer;
    };

    /**
     * Encodes the specified NickservNick message, length delimited. Does not implicitly {@link NickservNick.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NickservNick
     * @static
     * @param {INickservNick} message NickservNick message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickservNick.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NickservNick message from the specified reader or buffer.
     * @function decode
     * @memberof NickservNick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NickservNick} NickservNick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickservNick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickservNick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.key = reader.bytes();
                break;
            case 3:
                message.nick = reader.string();
                break;
            case 4:
                message.remainingNameChangeQuota = reader.uint32();
                break;
            case 5:
                message.updatedTimestamp = reader.uint64();
                break;
            case 6:
                message.createdTimestamp = reader.uint64();
                break;
            case 7:
                if (!(message.roles && message.roles.length))
                    message.roles = [];
                message.roles.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NickservNick message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NickservNick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NickservNick} NickservNick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickservNick.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NickservNick message.
     * @function verify
     * @memberof NickservNick
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NickservNick.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.nick != null && message.hasOwnProperty("nick"))
            if (!$util.isString(message.nick))
                return "nick: string expected";
        if (message.remainingNameChangeQuota != null && message.hasOwnProperty("remainingNameChangeQuota"))
            if (!$util.isInteger(message.remainingNameChangeQuota))
                return "remainingNameChangeQuota: integer expected";
        if (message.updatedTimestamp != null && message.hasOwnProperty("updatedTimestamp"))
            if (!$util.isInteger(message.updatedTimestamp) && !(message.updatedTimestamp && $util.isInteger(message.updatedTimestamp.low) && $util.isInteger(message.updatedTimestamp.high)))
                return "updatedTimestamp: integer|Long expected";
        if (message.createdTimestamp != null && message.hasOwnProperty("createdTimestamp"))
            if (!$util.isInteger(message.createdTimestamp) && !(message.createdTimestamp && $util.isInteger(message.createdTimestamp.low) && $util.isInteger(message.createdTimestamp.high)))
                return "createdTimestamp: integer|Long expected";
        if (message.roles != null && message.hasOwnProperty("roles")) {
            if (!Array.isArray(message.roles))
                return "roles: array expected";
            for (let i = 0; i < message.roles.length; ++i)
                if (!$util.isString(message.roles[i]))
                    return "roles: string[] expected";
        }
        return null;
    };

    /**
     * Creates a NickservNick message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NickservNick
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NickservNick} NickservNick
     */
    NickservNick.fromObject = function fromObject(object) {
        if (object instanceof $root.NickservNick)
            return object;
        let message = new $root.NickservNick();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        if (object.nick != null)
            message.nick = String(object.nick);
        if (object.remainingNameChangeQuota != null)
            message.remainingNameChangeQuota = object.remainingNameChangeQuota >>> 0;
        if (object.updatedTimestamp != null)
            if ($util.Long)
                (message.updatedTimestamp = $util.Long.fromValue(object.updatedTimestamp)).unsigned = true;
            else if (typeof object.updatedTimestamp === "string")
                message.updatedTimestamp = parseInt(object.updatedTimestamp, 10);
            else if (typeof object.updatedTimestamp === "number")
                message.updatedTimestamp = object.updatedTimestamp;
            else if (typeof object.updatedTimestamp === "object")
                message.updatedTimestamp = new $util.LongBits(object.updatedTimestamp.low >>> 0, object.updatedTimestamp.high >>> 0).toNumber(true);
        if (object.createdTimestamp != null)
            if ($util.Long)
                (message.createdTimestamp = $util.Long.fromValue(object.createdTimestamp)).unsigned = true;
            else if (typeof object.createdTimestamp === "string")
                message.createdTimestamp = parseInt(object.createdTimestamp, 10);
            else if (typeof object.createdTimestamp === "number")
                message.createdTimestamp = object.createdTimestamp;
            else if (typeof object.createdTimestamp === "object")
                message.createdTimestamp = new $util.LongBits(object.createdTimestamp.low >>> 0, object.createdTimestamp.high >>> 0).toNumber(true);
        if (object.roles) {
            if (!Array.isArray(object.roles))
                throw TypeError(".NickservNick.roles: array expected");
            message.roles = [];
            for (let i = 0; i < object.roles.length; ++i)
                message.roles[i] = String(object.roles[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a NickservNick message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NickservNick
     * @static
     * @param {NickservNick} message NickservNick
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NickservNick.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.roles = [];
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.nick = "";
            object.remainingNameChangeQuota = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.updatedTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.updatedTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.createdTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.createdTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.nick != null && message.hasOwnProperty("nick"))
            object.nick = message.nick;
        if (message.remainingNameChangeQuota != null && message.hasOwnProperty("remainingNameChangeQuota"))
            object.remainingNameChangeQuota = message.remainingNameChangeQuota;
        if (message.updatedTimestamp != null && message.hasOwnProperty("updatedTimestamp"))
            if (typeof message.updatedTimestamp === "number")
                object.updatedTimestamp = options.longs === String ? String(message.updatedTimestamp) : message.updatedTimestamp;
            else
                object.updatedTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTimestamp) : options.longs === Number ? new $util.LongBits(message.updatedTimestamp.low >>> 0, message.updatedTimestamp.high >>> 0).toNumber(true) : message.updatedTimestamp;
        if (message.createdTimestamp != null && message.hasOwnProperty("createdTimestamp"))
            if (typeof message.createdTimestamp === "number")
                object.createdTimestamp = options.longs === String ? String(message.createdTimestamp) : message.createdTimestamp;
            else
                object.createdTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.createdTimestamp) : options.longs === Number ? new $util.LongBits(message.createdTimestamp.low >>> 0, message.createdTimestamp.high >>> 0).toNumber(true) : message.createdTimestamp;
        if (message.roles && message.roles.length) {
            object.roles = [];
            for (let j = 0; j < message.roles.length; ++j)
                object.roles[j] = message.roles[j];
        }
        return object;
    };

    /**
     * Converts this NickservNick to JSON.
     * @function toJSON
     * @memberof NickservNick
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NickservNick.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NickservNick;
})();

export const NickServToken = $root.NickServToken = (() => {

    /**
     * Properties of a NickServToken.
     * @exports INickServToken
     * @interface INickServToken
     * @property {Uint8Array|null} [key] NickServToken key
     * @property {string|null} [nick] NickServToken nick
     * @property {google.protobuf.ITimestamp|null} [validUntil] NickServToken validUntil
     * @property {Uint8Array|null} [signature] NickServToken signature
     * @property {Array.<string>|null} [roles] NickServToken roles
     */

    /**
     * Constructs a new NickServToken.
     * @exports NickServToken
     * @classdesc Represents a NickServToken.
     * @implements INickServToken
     * @constructor
     * @param {INickServToken=} [properties] Properties to set
     */
    function NickServToken(properties) {
        this.roles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NickServToken key.
     * @member {Uint8Array} key
     * @memberof NickServToken
     * @instance
     */
    NickServToken.prototype.key = $util.newBuffer([]);

    /**
     * NickServToken nick.
     * @member {string} nick
     * @memberof NickServToken
     * @instance
     */
    NickServToken.prototype.nick = "";

    /**
     * NickServToken validUntil.
     * @member {google.protobuf.ITimestamp|null|undefined} validUntil
     * @memberof NickServToken
     * @instance
     */
    NickServToken.prototype.validUntil = null;

    /**
     * NickServToken signature.
     * @member {Uint8Array} signature
     * @memberof NickServToken
     * @instance
     */
    NickServToken.prototype.signature = $util.newBuffer([]);

    /**
     * NickServToken roles.
     * @member {Array.<string>} roles
     * @memberof NickServToken
     * @instance
     */
    NickServToken.prototype.roles = $util.emptyArray;

    /**
     * Creates a new NickServToken instance using the specified properties.
     * @function create
     * @memberof NickServToken
     * @static
     * @param {INickServToken=} [properties] Properties to set
     * @returns {NickServToken} NickServToken instance
     */
    NickServToken.create = function create(properties) {
        return new NickServToken(properties);
    };

    /**
     * Encodes the specified NickServToken message. Does not implicitly {@link NickServToken.verify|verify} messages.
     * @function encode
     * @memberof NickServToken
     * @static
     * @param {INickServToken} message NickServToken message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServToken.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nick);
        if (message.validUntil != null && Object.hasOwnProperty.call(message, "validUntil"))
            $root.google.protobuf.Timestamp.encode(message.validUntil, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
        if (message.roles != null && message.roles.length)
            for (let i = 0; i < message.roles.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.roles[i]);
        return writer;
    };

    /**
     * Encodes the specified NickServToken message, length delimited. Does not implicitly {@link NickServToken.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NickServToken
     * @static
     * @param {INickServToken} message NickServToken message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServToken.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NickServToken message from the specified reader or buffer.
     * @function decode
     * @memberof NickServToken
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NickServToken} NickServToken
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServToken.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServToken();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.nick = reader.string();
                break;
            case 3:
                message.validUntil = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                break;
            case 4:
                message.signature = reader.bytes();
                break;
            case 5:
                if (!(message.roles && message.roles.length))
                    message.roles = [];
                message.roles.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NickServToken message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NickServToken
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NickServToken} NickServToken
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServToken.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NickServToken message.
     * @function verify
     * @memberof NickServToken
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NickServToken.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.nick != null && message.hasOwnProperty("nick"))
            if (!$util.isString(message.nick))
                return "nick: string expected";
        if (message.validUntil != null && message.hasOwnProperty("validUntil")) {
            let error = $root.google.protobuf.Timestamp.verify(message.validUntil);
            if (error)
                return "validUntil." + error;
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        if (message.roles != null && message.hasOwnProperty("roles")) {
            if (!Array.isArray(message.roles))
                return "roles: array expected";
            for (let i = 0; i < message.roles.length; ++i)
                if (!$util.isString(message.roles[i]))
                    return "roles: string[] expected";
        }
        return null;
    };

    /**
     * Creates a NickServToken message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NickServToken
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NickServToken} NickServToken
     */
    NickServToken.fromObject = function fromObject(object) {
        if (object instanceof $root.NickServToken)
            return object;
        let message = new $root.NickServToken();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        if (object.nick != null)
            message.nick = String(object.nick);
        if (object.validUntil != null) {
            if (typeof object.validUntil !== "object")
                throw TypeError(".NickServToken.validUntil: object expected");
            message.validUntil = $root.google.protobuf.Timestamp.fromObject(object.validUntil);
        }
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        if (object.roles) {
            if (!Array.isArray(object.roles))
                throw TypeError(".NickServToken.roles: array expected");
            message.roles = [];
            for (let i = 0; i < object.roles.length; ++i)
                message.roles[i] = String(object.roles[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a NickServToken message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NickServToken
     * @static
     * @param {NickServToken} message NickServToken
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NickServToken.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.roles = [];
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.nick = "";
            object.validUntil = null;
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.nick != null && message.hasOwnProperty("nick"))
            object.nick = message.nick;
        if (message.validUntil != null && message.hasOwnProperty("validUntil"))
            object.validUntil = $root.google.protobuf.Timestamp.toObject(message.validUntil, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        if (message.roles && message.roles.length) {
            object.roles = [];
            for (let j = 0; j < message.roles.length; ++j)
                object.roles[j] = message.roles[j];
        }
        return object;
    };

    /**
     * Converts this NickServToken to JSON.
     * @function toJSON
     * @memberof NickServToken
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NickServToken.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NickServToken;
})();

export const NickServRPCCommand = $root.NickServRPCCommand = (() => {

    /**
     * Properties of a NickServRPCCommand.
     * @exports INickServRPCCommand
     * @interface INickServRPCCommand
     * @property {number|null} [requestId] NickServRPCCommand requestId
     * @property {Uint8Array|null} [sourcePublicKey] NickServRPCCommand sourcePublicKey
     * @property {NickServRPCCommand.ICreate|null} [create] NickServRPCCommand create
     * @property {NickServRPCCommand.IRetrieve|null} [retrieve] NickServRPCCommand retrieve
     * @property {NickServRPCCommand.IUpdate|null} [update] NickServRPCCommand update
     * @property {NickServRPCCommand.IDelete|null} ["delete"] NickServRPCCommand delete
     */

    /**
     * Constructs a new NickServRPCCommand.
     * @exports NickServRPCCommand
     * @classdesc Represents a NickServRPCCommand.
     * @implements INickServRPCCommand
     * @constructor
     * @param {INickServRPCCommand=} [properties] Properties to set
     */
    function NickServRPCCommand(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NickServRPCCommand requestId.
     * @member {number} requestId
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NickServRPCCommand sourcePublicKey.
     * @member {Uint8Array} sourcePublicKey
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype.sourcePublicKey = $util.newBuffer([]);

    /**
     * NickServRPCCommand create.
     * @member {NickServRPCCommand.ICreate|null|undefined} create
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype.create = null;

    /**
     * NickServRPCCommand retrieve.
     * @member {NickServRPCCommand.IRetrieve|null|undefined} retrieve
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype.retrieve = null;

    /**
     * NickServRPCCommand update.
     * @member {NickServRPCCommand.IUpdate|null|undefined} update
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype.update = null;

    /**
     * NickServRPCCommand delete.
     * @member {NickServRPCCommand.IDelete|null|undefined} delete
     * @memberof NickServRPCCommand
     * @instance
     */
    NickServRPCCommand.prototype["delete"] = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * NickServRPCCommand body.
     * @member {"create"|"retrieve"|"update"|"delete"|undefined} body
     * @memberof NickServRPCCommand
     * @instance
     */
    Object.defineProperty(NickServRPCCommand.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["create", "retrieve", "update", "delete"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new NickServRPCCommand instance using the specified properties.
     * @function create
     * @memberof NickServRPCCommand
     * @static
     * @param {INickServRPCCommand=} [properties] Properties to set
     * @returns {NickServRPCCommand} NickServRPCCommand instance
     */
    NickServRPCCommand.create = function create(properties) {
        return new NickServRPCCommand(properties);
    };

    /**
     * Encodes the specified NickServRPCCommand message. Does not implicitly {@link NickServRPCCommand.verify|verify} messages.
     * @function encode
     * @memberof NickServRPCCommand
     * @static
     * @param {INickServRPCCommand} message NickServRPCCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServRPCCommand.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
        if (message.sourcePublicKey != null && Object.hasOwnProperty.call(message, "sourcePublicKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sourcePublicKey);
        if (message.create != null && Object.hasOwnProperty.call(message, "create"))
            $root.NickServRPCCommand.Create.encode(message.create, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.retrieve != null && Object.hasOwnProperty.call(message, "retrieve"))
            $root.NickServRPCCommand.Retrieve.encode(message.retrieve, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.update != null && Object.hasOwnProperty.call(message, "update"))
            $root.NickServRPCCommand.Update.encode(message.update, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
            $root.NickServRPCCommand.Delete.encode(message["delete"], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NickServRPCCommand message, length delimited. Does not implicitly {@link NickServRPCCommand.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NickServRPCCommand
     * @static
     * @param {INickServRPCCommand} message NickServRPCCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServRPCCommand.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NickServRPCCommand message from the specified reader or buffer.
     * @function decode
     * @memberof NickServRPCCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NickServRPCCommand} NickServRPCCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServRPCCommand.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestId = reader.uint64();
                break;
            case 2:
                message.sourcePublicKey = reader.bytes();
                break;
            case 5:
                message.create = $root.NickServRPCCommand.Create.decode(reader, reader.uint32());
                break;
            case 6:
                message.retrieve = $root.NickServRPCCommand.Retrieve.decode(reader, reader.uint32());
                break;
            case 7:
                message.update = $root.NickServRPCCommand.Update.decode(reader, reader.uint32());
                break;
            case 8:
                message["delete"] = $root.NickServRPCCommand.Delete.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NickServRPCCommand message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NickServRPCCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NickServRPCCommand} NickServRPCCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServRPCCommand.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NickServRPCCommand message.
     * @function verify
     * @memberof NickServRPCCommand
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NickServRPCCommand.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                return "requestId: integer|Long expected";
        if (message.sourcePublicKey != null && message.hasOwnProperty("sourcePublicKey"))
            if (!(message.sourcePublicKey && typeof message.sourcePublicKey.length === "number" || $util.isString(message.sourcePublicKey)))
                return "sourcePublicKey: buffer expected";
        if (message.create != null && message.hasOwnProperty("create")) {
            properties.body = 1;
            {
                let error = $root.NickServRPCCommand.Create.verify(message.create);
                if (error)
                    return "create." + error;
            }
        }
        if (message.retrieve != null && message.hasOwnProperty("retrieve")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServRPCCommand.Retrieve.verify(message.retrieve);
                if (error)
                    return "retrieve." + error;
            }
        }
        if (message.update != null && message.hasOwnProperty("update")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServRPCCommand.Update.verify(message.update);
                if (error)
                    return "update." + error;
            }
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServRPCCommand.Delete.verify(message["delete"]);
                if (error)
                    return "delete." + error;
            }
        }
        return null;
    };

    /**
     * Creates a NickServRPCCommand message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NickServRPCCommand
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NickServRPCCommand} NickServRPCCommand
     */
    NickServRPCCommand.fromObject = function fromObject(object) {
        if (object instanceof $root.NickServRPCCommand)
            return object;
        let message = new $root.NickServRPCCommand();
        if (object.requestId != null)
            if ($util.Long)
                (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
            else if (typeof object.requestId === "string")
                message.requestId = parseInt(object.requestId, 10);
            else if (typeof object.requestId === "number")
                message.requestId = object.requestId;
            else if (typeof object.requestId === "object")
                message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
        if (object.sourcePublicKey != null)
            if (typeof object.sourcePublicKey === "string")
                $util.base64.decode(object.sourcePublicKey, message.sourcePublicKey = $util.newBuffer($util.base64.length(object.sourcePublicKey)), 0);
            else if (object.sourcePublicKey.length)
                message.sourcePublicKey = object.sourcePublicKey;
        if (object.create != null) {
            if (typeof object.create !== "object")
                throw TypeError(".NickServRPCCommand.create: object expected");
            message.create = $root.NickServRPCCommand.Create.fromObject(object.create);
        }
        if (object.retrieve != null) {
            if (typeof object.retrieve !== "object")
                throw TypeError(".NickServRPCCommand.retrieve: object expected");
            message.retrieve = $root.NickServRPCCommand.Retrieve.fromObject(object.retrieve);
        }
        if (object.update != null) {
            if (typeof object.update !== "object")
                throw TypeError(".NickServRPCCommand.update: object expected");
            message.update = $root.NickServRPCCommand.Update.fromObject(object.update);
        }
        if (object["delete"] != null) {
            if (typeof object["delete"] !== "object")
                throw TypeError(".NickServRPCCommand.delete: object expected");
            message["delete"] = $root.NickServRPCCommand.Delete.fromObject(object["delete"]);
        }
        return message;
    };

    /**
     * Creates a plain object from a NickServRPCCommand message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NickServRPCCommand
     * @static
     * @param {NickServRPCCommand} message NickServRPCCommand
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NickServRPCCommand.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.requestId = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.sourcePublicKey = "";
            else {
                object.sourcePublicKey = [];
                if (options.bytes !== Array)
                    object.sourcePublicKey = $util.newBuffer(object.sourcePublicKey);
            }
        }
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            if (typeof message.requestId === "number")
                object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
            else
                object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
        if (message.sourcePublicKey != null && message.hasOwnProperty("sourcePublicKey"))
            object.sourcePublicKey = options.bytes === String ? $util.base64.encode(message.sourcePublicKey, 0, message.sourcePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sourcePublicKey) : message.sourcePublicKey;
        if (message.create != null && message.hasOwnProperty("create")) {
            object.create = $root.NickServRPCCommand.Create.toObject(message.create, options);
            if (options.oneofs)
                object.body = "create";
        }
        if (message.retrieve != null && message.hasOwnProperty("retrieve")) {
            object.retrieve = $root.NickServRPCCommand.Retrieve.toObject(message.retrieve, options);
            if (options.oneofs)
                object.body = "retrieve";
        }
        if (message.update != null && message.hasOwnProperty("update")) {
            object.update = $root.NickServRPCCommand.Update.toObject(message.update, options);
            if (options.oneofs)
                object.body = "update";
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
            object["delete"] = $root.NickServRPCCommand.Delete.toObject(message["delete"], options);
            if (options.oneofs)
                object.body = "delete";
        }
        return object;
    };

    /**
     * Converts this NickServRPCCommand to JSON.
     * @function toJSON
     * @memberof NickServRPCCommand
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NickServRPCCommand.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    NickServRPCCommand.Create = (function() {

        /**
         * Properties of a Create.
         * @memberof NickServRPCCommand
         * @interface ICreate
         * @property {string|null} [nick] Create nick
         */

        /**
         * Constructs a new Create.
         * @memberof NickServRPCCommand
         * @classdesc Represents a Create.
         * @implements ICreate
         * @constructor
         * @param {NickServRPCCommand.ICreate=} [properties] Properties to set
         */
        function Create(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Create nick.
         * @member {string} nick
         * @memberof NickServRPCCommand.Create
         * @instance
         */
        Create.prototype.nick = "";

        /**
         * Creates a new Create instance using the specified properties.
         * @function create
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {NickServRPCCommand.ICreate=} [properties] Properties to set
         * @returns {NickServRPCCommand.Create} Create instance
         */
        Create.create = function create(properties) {
            return new Create(properties);
        };

        /**
         * Encodes the specified Create message. Does not implicitly {@link NickServRPCCommand.Create.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {NickServRPCCommand.ICreate} message Create message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Create.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nick);
            return writer;
        };

        /**
         * Encodes the specified Create message, length delimited. Does not implicitly {@link NickServRPCCommand.Create.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {NickServRPCCommand.ICreate} message Create message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Create.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Create message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCCommand.Create} Create
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Create.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Create();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nick = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Create message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCCommand.Create} Create
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Create.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Create message.
         * @function verify
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Create.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nick != null && message.hasOwnProperty("nick"))
                if (!$util.isString(message.nick))
                    return "nick: string expected";
            return null;
        };

        /**
         * Creates a Create message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCCommand.Create} Create
         */
        Create.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCCommand.Create)
                return object;
            let message = new $root.NickServRPCCommand.Create();
            if (object.nick != null)
                message.nick = String(object.nick);
            return message;
        };

        /**
         * Creates a plain object from a Create message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCCommand.Create
         * @static
         * @param {NickServRPCCommand.Create} message Create
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Create.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.nick = "";
            if (message.nick != null && message.hasOwnProperty("nick"))
                object.nick = message.nick;
            return object;
        };

        /**
         * Converts this Create to JSON.
         * @function toJSON
         * @memberof NickServRPCCommand.Create
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Create.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Create;
    })();

    NickServRPCCommand.Retrieve = (function() {

        /**
         * Properties of a Retrieve.
         * @memberof NickServRPCCommand
         * @interface IRetrieve
         */

        /**
         * Constructs a new Retrieve.
         * @memberof NickServRPCCommand
         * @classdesc Represents a Retrieve.
         * @implements IRetrieve
         * @constructor
         * @param {NickServRPCCommand.IRetrieve=} [properties] Properties to set
         */
        function Retrieve(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Retrieve instance using the specified properties.
         * @function create
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {NickServRPCCommand.IRetrieve=} [properties] Properties to set
         * @returns {NickServRPCCommand.Retrieve} Retrieve instance
         */
        Retrieve.create = function create(properties) {
            return new Retrieve(properties);
        };

        /**
         * Encodes the specified Retrieve message. Does not implicitly {@link NickServRPCCommand.Retrieve.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {NickServRPCCommand.IRetrieve} message Retrieve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Retrieve.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Retrieve message, length delimited. Does not implicitly {@link NickServRPCCommand.Retrieve.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {NickServRPCCommand.IRetrieve} message Retrieve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Retrieve.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Retrieve message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCCommand.Retrieve} Retrieve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Retrieve.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Retrieve();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Retrieve message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCCommand.Retrieve} Retrieve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Retrieve.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Retrieve message.
         * @function verify
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Retrieve.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Retrieve message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCCommand.Retrieve} Retrieve
         */
        Retrieve.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCCommand.Retrieve)
                return object;
            return new $root.NickServRPCCommand.Retrieve();
        };

        /**
         * Creates a plain object from a Retrieve message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCCommand.Retrieve
         * @static
         * @param {NickServRPCCommand.Retrieve} message Retrieve
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Retrieve.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Retrieve to JSON.
         * @function toJSON
         * @memberof NickServRPCCommand.Retrieve
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Retrieve.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Retrieve;
    })();

    NickServRPCCommand.Update = (function() {

        /**
         * Properties of an Update.
         * @memberof NickServRPCCommand
         * @interface IUpdate
         * @property {NickServRPCCommand.Update.IChangeNick|null} [nick] Update nick
         * @property {number|null} [nameChangeQuota] Update nameChangeQuota
         * @property {NickServRPCCommand.Update.IRoles|null} [roles] Update roles
         */

        /**
         * Constructs a new Update.
         * @memberof NickServRPCCommand
         * @classdesc Represents an Update.
         * @implements IUpdate
         * @constructor
         * @param {NickServRPCCommand.IUpdate=} [properties] Properties to set
         */
        function Update(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Update nick.
         * @member {NickServRPCCommand.Update.IChangeNick|null|undefined} nick
         * @memberof NickServRPCCommand.Update
         * @instance
         */
        Update.prototype.nick = null;

        /**
         * Update nameChangeQuota.
         * @member {number} nameChangeQuota
         * @memberof NickServRPCCommand.Update
         * @instance
         */
        Update.prototype.nameChangeQuota = 0;

        /**
         * Update roles.
         * @member {NickServRPCCommand.Update.IRoles|null|undefined} roles
         * @memberof NickServRPCCommand.Update
         * @instance
         */
        Update.prototype.roles = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Update param.
         * @member {"nick"|"nameChangeQuota"|"roles"|undefined} param
         * @memberof NickServRPCCommand.Update
         * @instance
         */
        Object.defineProperty(Update.prototype, "param", {
            get: $util.oneOfGetter($oneOfFields = ["nick", "nameChangeQuota", "roles"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Update instance using the specified properties.
         * @function create
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {NickServRPCCommand.IUpdate=} [properties] Properties to set
         * @returns {NickServRPCCommand.Update} Update instance
         */
        Update.create = function create(properties) {
            return new Update(properties);
        };

        /**
         * Encodes the specified Update message. Does not implicitly {@link NickServRPCCommand.Update.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {NickServRPCCommand.IUpdate} message Update message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Update.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                $root.NickServRPCCommand.Update.ChangeNick.encode(message.nick, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nameChangeQuota != null && Object.hasOwnProperty.call(message, "nameChangeQuota"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.nameChangeQuota);
            if (message.roles != null && Object.hasOwnProperty.call(message, "roles"))
                $root.NickServRPCCommand.Update.Roles.encode(message.roles, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Update message, length delimited. Does not implicitly {@link NickServRPCCommand.Update.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {NickServRPCCommand.IUpdate} message Update message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Update.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Update message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCCommand.Update} Update
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Update.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Update();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nick = $root.NickServRPCCommand.Update.ChangeNick.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nameChangeQuota = reader.uint32();
                    break;
                case 3:
                    message.roles = $root.NickServRPCCommand.Update.Roles.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Update message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCCommand.Update} Update
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Update.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Update message.
         * @function verify
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Update.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.nick != null && message.hasOwnProperty("nick")) {
                properties.param = 1;
                {
                    let error = $root.NickServRPCCommand.Update.ChangeNick.verify(message.nick);
                    if (error)
                        return "nick." + error;
                }
            }
            if (message.nameChangeQuota != null && message.hasOwnProperty("nameChangeQuota")) {
                if (properties.param === 1)
                    return "param: multiple values";
                properties.param = 1;
                if (!$util.isInteger(message.nameChangeQuota))
                    return "nameChangeQuota: integer expected";
            }
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (properties.param === 1)
                    return "param: multiple values";
                properties.param = 1;
                {
                    let error = $root.NickServRPCCommand.Update.Roles.verify(message.roles);
                    if (error)
                        return "roles." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Update message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCCommand.Update} Update
         */
        Update.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCCommand.Update)
                return object;
            let message = new $root.NickServRPCCommand.Update();
            if (object.nick != null) {
                if (typeof object.nick !== "object")
                    throw TypeError(".NickServRPCCommand.Update.nick: object expected");
                message.nick = $root.NickServRPCCommand.Update.ChangeNick.fromObject(object.nick);
            }
            if (object.nameChangeQuota != null)
                message.nameChangeQuota = object.nameChangeQuota >>> 0;
            if (object.roles != null) {
                if (typeof object.roles !== "object")
                    throw TypeError(".NickServRPCCommand.Update.roles: object expected");
                message.roles = $root.NickServRPCCommand.Update.Roles.fromObject(object.roles);
            }
            return message;
        };

        /**
         * Creates a plain object from an Update message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCCommand.Update
         * @static
         * @param {NickServRPCCommand.Update} message Update
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Update.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.nick != null && message.hasOwnProperty("nick")) {
                object.nick = $root.NickServRPCCommand.Update.ChangeNick.toObject(message.nick, options);
                if (options.oneofs)
                    object.param = "nick";
            }
            if (message.nameChangeQuota != null && message.hasOwnProperty("nameChangeQuota")) {
                object.nameChangeQuota = message.nameChangeQuota;
                if (options.oneofs)
                    object.param = "nameChangeQuota";
            }
            if (message.roles != null && message.hasOwnProperty("roles")) {
                object.roles = $root.NickServRPCCommand.Update.Roles.toObject(message.roles, options);
                if (options.oneofs)
                    object.param = "roles";
            }
            return object;
        };

        /**
         * Converts this Update to JSON.
         * @function toJSON
         * @memberof NickServRPCCommand.Update
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Update.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Update.Roles = (function() {

            /**
             * Properties of a Roles.
             * @memberof NickServRPCCommand.Update
             * @interface IRoles
             * @property {Array.<string>|null} [roles] Roles roles
             */

            /**
             * Constructs a new Roles.
             * @memberof NickServRPCCommand.Update
             * @classdesc Represents a Roles.
             * @implements IRoles
             * @constructor
             * @param {NickServRPCCommand.Update.IRoles=} [properties] Properties to set
             */
            function Roles(properties) {
                this.roles = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Roles roles.
             * @member {Array.<string>} roles
             * @memberof NickServRPCCommand.Update.Roles
             * @instance
             */
            Roles.prototype.roles = $util.emptyArray;

            /**
             * Creates a new Roles instance using the specified properties.
             * @function create
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {NickServRPCCommand.Update.IRoles=} [properties] Properties to set
             * @returns {NickServRPCCommand.Update.Roles} Roles instance
             */
            Roles.create = function create(properties) {
                return new Roles(properties);
            };

            /**
             * Encodes the specified Roles message. Does not implicitly {@link NickServRPCCommand.Update.Roles.verify|verify} messages.
             * @function encode
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {NickServRPCCommand.Update.IRoles} message Roles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Roles.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roles != null && message.roles.length)
                    for (let i = 0; i < message.roles.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.roles[i]);
                return writer;
            };

            /**
             * Encodes the specified Roles message, length delimited. Does not implicitly {@link NickServRPCCommand.Update.Roles.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {NickServRPCCommand.Update.IRoles} message Roles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Roles.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Roles message from the specified reader or buffer.
             * @function decode
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NickServRPCCommand.Update.Roles} Roles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Roles.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Update.Roles();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Roles message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NickServRPCCommand.Update.Roles} Roles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Roles.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Roles message.
             * @function verify
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Roles.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roles != null && message.hasOwnProperty("roles")) {
                    if (!Array.isArray(message.roles))
                        return "roles: array expected";
                    for (let i = 0; i < message.roles.length; ++i)
                        if (!$util.isString(message.roles[i]))
                            return "roles: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Roles message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NickServRPCCommand.Update.Roles} Roles
             */
            Roles.fromObject = function fromObject(object) {
                if (object instanceof $root.NickServRPCCommand.Update.Roles)
                    return object;
                let message = new $root.NickServRPCCommand.Update.Roles();
                if (object.roles) {
                    if (!Array.isArray(object.roles))
                        throw TypeError(".NickServRPCCommand.Update.Roles.roles: array expected");
                    message.roles = [];
                    for (let i = 0; i < object.roles.length; ++i)
                        message.roles[i] = String(object.roles[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Roles message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NickServRPCCommand.Update.Roles
             * @static
             * @param {NickServRPCCommand.Update.Roles} message Roles
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Roles.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.roles = [];
                if (message.roles && message.roles.length) {
                    object.roles = [];
                    for (let j = 0; j < message.roles.length; ++j)
                        object.roles[j] = message.roles[j];
                }
                return object;
            };

            /**
             * Converts this Roles to JSON.
             * @function toJSON
             * @memberof NickServRPCCommand.Update.Roles
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Roles.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Roles;
        })();

        Update.ChangeNick = (function() {

            /**
             * Properties of a ChangeNick.
             * @memberof NickServRPCCommand.Update
             * @interface IChangeNick
             * @property {string|null} [oldNick] ChangeNick oldNick
             * @property {string|null} [newNick] ChangeNick newNick
             */

            /**
             * Constructs a new ChangeNick.
             * @memberof NickServRPCCommand.Update
             * @classdesc Represents a ChangeNick.
             * @implements IChangeNick
             * @constructor
             * @param {NickServRPCCommand.Update.IChangeNick=} [properties] Properties to set
             */
            function ChangeNick(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeNick oldNick.
             * @member {string} oldNick
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @instance
             */
            ChangeNick.prototype.oldNick = "";

            /**
             * ChangeNick newNick.
             * @member {string} newNick
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @instance
             */
            ChangeNick.prototype.newNick = "";

            /**
             * Creates a new ChangeNick instance using the specified properties.
             * @function create
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {NickServRPCCommand.Update.IChangeNick=} [properties] Properties to set
             * @returns {NickServRPCCommand.Update.ChangeNick} ChangeNick instance
             */
            ChangeNick.create = function create(properties) {
                return new ChangeNick(properties);
            };

            /**
             * Encodes the specified ChangeNick message. Does not implicitly {@link NickServRPCCommand.Update.ChangeNick.verify|verify} messages.
             * @function encode
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {NickServRPCCommand.Update.IChangeNick} message ChangeNick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeNick.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oldNick != null && Object.hasOwnProperty.call(message, "oldNick"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.oldNick);
                if (message.newNick != null && Object.hasOwnProperty.call(message, "newNick"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.newNick);
                return writer;
            };

            /**
             * Encodes the specified ChangeNick message, length delimited. Does not implicitly {@link NickServRPCCommand.Update.ChangeNick.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {NickServRPCCommand.Update.IChangeNick} message ChangeNick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeNick.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeNick message from the specified reader or buffer.
             * @function decode
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NickServRPCCommand.Update.ChangeNick} ChangeNick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeNick.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Update.ChangeNick();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oldNick = reader.string();
                        break;
                    case 2:
                        message.newNick = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChangeNick message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NickServRPCCommand.Update.ChangeNick} ChangeNick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeNick.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeNick message.
             * @function verify
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeNick.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.oldNick != null && message.hasOwnProperty("oldNick"))
                    if (!$util.isString(message.oldNick))
                        return "oldNick: string expected";
                if (message.newNick != null && message.hasOwnProperty("newNick"))
                    if (!$util.isString(message.newNick))
                        return "newNick: string expected";
                return null;
            };

            /**
             * Creates a ChangeNick message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NickServRPCCommand.Update.ChangeNick} ChangeNick
             */
            ChangeNick.fromObject = function fromObject(object) {
                if (object instanceof $root.NickServRPCCommand.Update.ChangeNick)
                    return object;
                let message = new $root.NickServRPCCommand.Update.ChangeNick();
                if (object.oldNick != null)
                    message.oldNick = String(object.oldNick);
                if (object.newNick != null)
                    message.newNick = String(object.newNick);
                return message;
            };

            /**
             * Creates a plain object from a ChangeNick message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @static
             * @param {NickServRPCCommand.Update.ChangeNick} message ChangeNick
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangeNick.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.oldNick = "";
                    object.newNick = "";
                }
                if (message.oldNick != null && message.hasOwnProperty("oldNick"))
                    object.oldNick = message.oldNick;
                if (message.newNick != null && message.hasOwnProperty("newNick"))
                    object.newNick = message.newNick;
                return object;
            };

            /**
             * Converts this ChangeNick to JSON.
             * @function toJSON
             * @memberof NickServRPCCommand.Update.ChangeNick
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChangeNick.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChangeNick;
        })();

        return Update;
    })();

    NickServRPCCommand.Delete = (function() {

        /**
         * Properties of a Delete.
         * @memberof NickServRPCCommand
         * @interface IDelete
         */

        /**
         * Constructs a new Delete.
         * @memberof NickServRPCCommand
         * @classdesc Represents a Delete.
         * @implements IDelete
         * @constructor
         * @param {NickServRPCCommand.IDelete=} [properties] Properties to set
         */
        function Delete(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Delete instance using the specified properties.
         * @function create
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {NickServRPCCommand.IDelete=} [properties] Properties to set
         * @returns {NickServRPCCommand.Delete} Delete instance
         */
        Delete.create = function create(properties) {
            return new Delete(properties);
        };

        /**
         * Encodes the specified Delete message. Does not implicitly {@link NickServRPCCommand.Delete.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {NickServRPCCommand.IDelete} message Delete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Delete.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Delete message, length delimited. Does not implicitly {@link NickServRPCCommand.Delete.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {NickServRPCCommand.IDelete} message Delete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Delete.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Delete message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCCommand.Delete} Delete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Delete.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCCommand.Delete();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Delete message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCCommand.Delete} Delete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Delete.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Delete message.
         * @function verify
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Delete.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Delete message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCCommand.Delete} Delete
         */
        Delete.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCCommand.Delete)
                return object;
            return new $root.NickServRPCCommand.Delete();
        };

        /**
         * Creates a plain object from a Delete message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCCommand.Delete
         * @static
         * @param {NickServRPCCommand.Delete} message Delete
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Delete.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Delete to JSON.
         * @function toJSON
         * @memberof NickServRPCCommand.Delete
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Delete.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Delete;
    })();

    return NickServRPCCommand;
})();

export const NickServRPCResponse = $root.NickServRPCResponse = (() => {

    /**
     * Properties of a NickServRPCResponse.
     * @exports INickServRPCResponse
     * @interface INickServRPCResponse
     * @property {number|null} [requestId] NickServRPCResponse requestId
     * @property {string|null} [error] NickServRPCResponse error
     * @property {NickServRPCResponse.IUpdate|null} [update] NickServRPCResponse update
     * @property {NickServRPCResponse.IDelete|null} ["delete"] NickServRPCResponse delete
     * @property {INickServToken|null} [create] NickServRPCResponse create
     * @property {INickServToken|null} [retrieve] NickServRPCResponse retrieve
     */

    /**
     * Constructs a new NickServRPCResponse.
     * @exports NickServRPCResponse
     * @classdesc Represents a NickServRPCResponse.
     * @implements INickServRPCResponse
     * @constructor
     * @param {INickServRPCResponse=} [properties] Properties to set
     */
    function NickServRPCResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NickServRPCResponse requestId.
     * @member {number} requestId
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NickServRPCResponse error.
     * @member {string} error
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype.error = "";

    /**
     * NickServRPCResponse update.
     * @member {NickServRPCResponse.IUpdate|null|undefined} update
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype.update = null;

    /**
     * NickServRPCResponse delete.
     * @member {NickServRPCResponse.IDelete|null|undefined} delete
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype["delete"] = null;

    /**
     * NickServRPCResponse create.
     * @member {INickServToken|null|undefined} create
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype.create = null;

    /**
     * NickServRPCResponse retrieve.
     * @member {INickServToken|null|undefined} retrieve
     * @memberof NickServRPCResponse
     * @instance
     */
    NickServRPCResponse.prototype.retrieve = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * NickServRPCResponse body.
     * @member {"error"|"update"|"delete"|"create"|"retrieve"|undefined} body
     * @memberof NickServRPCResponse
     * @instance
     */
    Object.defineProperty(NickServRPCResponse.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["error", "update", "delete", "create", "retrieve"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new NickServRPCResponse instance using the specified properties.
     * @function create
     * @memberof NickServRPCResponse
     * @static
     * @param {INickServRPCResponse=} [properties] Properties to set
     * @returns {NickServRPCResponse} NickServRPCResponse instance
     */
    NickServRPCResponse.create = function create(properties) {
        return new NickServRPCResponse(properties);
    };

    /**
     * Encodes the specified NickServRPCResponse message. Does not implicitly {@link NickServRPCResponse.verify|verify} messages.
     * @function encode
     * @memberof NickServRPCResponse
     * @static
     * @param {INickServRPCResponse} message NickServRPCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServRPCResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
        if (message.update != null && Object.hasOwnProperty.call(message, "update"))
            $root.NickServRPCResponse.Update.encode(message.update, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
            $root.NickServRPCResponse.Delete.encode(message["delete"], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.create != null && Object.hasOwnProperty.call(message, "create"))
            $root.NickServToken.encode(message.create, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.retrieve != null && Object.hasOwnProperty.call(message, "retrieve"))
            $root.NickServToken.encode(message.retrieve, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NickServRPCResponse message, length delimited. Does not implicitly {@link NickServRPCResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NickServRPCResponse
     * @static
     * @param {INickServRPCResponse} message NickServRPCResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NickServRPCResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NickServRPCResponse message from the specified reader or buffer.
     * @function decode
     * @memberof NickServRPCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NickServRPCResponse} NickServRPCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServRPCResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestId = reader.uint64();
                break;
            case 2:
                message.error = reader.string();
                break;
            case 3:
                message.update = $root.NickServRPCResponse.Update.decode(reader, reader.uint32());
                break;
            case 4:
                message["delete"] = $root.NickServRPCResponse.Delete.decode(reader, reader.uint32());
                break;
            case 5:
                message.create = $root.NickServToken.decode(reader, reader.uint32());
                break;
            case 6:
                message.retrieve = $root.NickServToken.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NickServRPCResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NickServRPCResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NickServRPCResponse} NickServRPCResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NickServRPCResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NickServRPCResponse message.
     * @function verify
     * @memberof NickServRPCResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NickServRPCResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                return "requestId: integer|Long expected";
        if (message.error != null && message.hasOwnProperty("error")) {
            properties.body = 1;
            if (!$util.isString(message.error))
                return "error: string expected";
        }
        if (message.update != null && message.hasOwnProperty("update")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServRPCResponse.Update.verify(message.update);
                if (error)
                    return "update." + error;
            }
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServRPCResponse.Delete.verify(message["delete"]);
                if (error)
                    return "delete." + error;
            }
        }
        if (message.create != null && message.hasOwnProperty("create")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServToken.verify(message.create);
                if (error)
                    return "create." + error;
            }
        }
        if (message.retrieve != null && message.hasOwnProperty("retrieve")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NickServToken.verify(message.retrieve);
                if (error)
                    return "retrieve." + error;
            }
        }
        return null;
    };

    /**
     * Creates a NickServRPCResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NickServRPCResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NickServRPCResponse} NickServRPCResponse
     */
    NickServRPCResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.NickServRPCResponse)
            return object;
        let message = new $root.NickServRPCResponse();
        if (object.requestId != null)
            if ($util.Long)
                (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
            else if (typeof object.requestId === "string")
                message.requestId = parseInt(object.requestId, 10);
            else if (typeof object.requestId === "number")
                message.requestId = object.requestId;
            else if (typeof object.requestId === "object")
                message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
        if (object.error != null)
            message.error = String(object.error);
        if (object.update != null) {
            if (typeof object.update !== "object")
                throw TypeError(".NickServRPCResponse.update: object expected");
            message.update = $root.NickServRPCResponse.Update.fromObject(object.update);
        }
        if (object["delete"] != null) {
            if (typeof object["delete"] !== "object")
                throw TypeError(".NickServRPCResponse.delete: object expected");
            message["delete"] = $root.NickServRPCResponse.Delete.fromObject(object["delete"]);
        }
        if (object.create != null) {
            if (typeof object.create !== "object")
                throw TypeError(".NickServRPCResponse.create: object expected");
            message.create = $root.NickServToken.fromObject(object.create);
        }
        if (object.retrieve != null) {
            if (typeof object.retrieve !== "object")
                throw TypeError(".NickServRPCResponse.retrieve: object expected");
            message.retrieve = $root.NickServToken.fromObject(object.retrieve);
        }
        return message;
    };

    /**
     * Creates a plain object from a NickServRPCResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NickServRPCResponse
     * @static
     * @param {NickServRPCResponse} message NickServRPCResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NickServRPCResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.requestId = options.longs === String ? "0" : 0;
        if (message.requestId != null && message.hasOwnProperty("requestId"))
            if (typeof message.requestId === "number")
                object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
            else
                object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
        if (message.error != null && message.hasOwnProperty("error")) {
            object.error = message.error;
            if (options.oneofs)
                object.body = "error";
        }
        if (message.update != null && message.hasOwnProperty("update")) {
            object.update = $root.NickServRPCResponse.Update.toObject(message.update, options);
            if (options.oneofs)
                object.body = "update";
        }
        if (message["delete"] != null && message.hasOwnProperty("delete")) {
            object["delete"] = $root.NickServRPCResponse.Delete.toObject(message["delete"], options);
            if (options.oneofs)
                object.body = "delete";
        }
        if (message.create != null && message.hasOwnProperty("create")) {
            object.create = $root.NickServToken.toObject(message.create, options);
            if (options.oneofs)
                object.body = "create";
        }
        if (message.retrieve != null && message.hasOwnProperty("retrieve")) {
            object.retrieve = $root.NickServToken.toObject(message.retrieve, options);
            if (options.oneofs)
                object.body = "retrieve";
        }
        return object;
    };

    /**
     * Converts this NickServRPCResponse to JSON.
     * @function toJSON
     * @memberof NickServRPCResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NickServRPCResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    NickServRPCResponse.Update = (function() {

        /**
         * Properties of an Update.
         * @memberof NickServRPCResponse
         * @interface IUpdate
         */

        /**
         * Constructs a new Update.
         * @memberof NickServRPCResponse
         * @classdesc Represents an Update.
         * @implements IUpdate
         * @constructor
         * @param {NickServRPCResponse.IUpdate=} [properties] Properties to set
         */
        function Update(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Update instance using the specified properties.
         * @function create
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {NickServRPCResponse.IUpdate=} [properties] Properties to set
         * @returns {NickServRPCResponse.Update} Update instance
         */
        Update.create = function create(properties) {
            return new Update(properties);
        };

        /**
         * Encodes the specified Update message. Does not implicitly {@link NickServRPCResponse.Update.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {NickServRPCResponse.IUpdate} message Update message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Update.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Update message, length delimited. Does not implicitly {@link NickServRPCResponse.Update.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {NickServRPCResponse.IUpdate} message Update message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Update.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Update message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCResponse.Update} Update
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Update.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCResponse.Update();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Update message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCResponse.Update} Update
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Update.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Update message.
         * @function verify
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Update.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an Update message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCResponse.Update} Update
         */
        Update.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCResponse.Update)
                return object;
            return new $root.NickServRPCResponse.Update();
        };

        /**
         * Creates a plain object from an Update message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCResponse.Update
         * @static
         * @param {NickServRPCResponse.Update} message Update
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Update.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Update to JSON.
         * @function toJSON
         * @memberof NickServRPCResponse.Update
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Update.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Update;
    })();

    NickServRPCResponse.Delete = (function() {

        /**
         * Properties of a Delete.
         * @memberof NickServRPCResponse
         * @interface IDelete
         */

        /**
         * Constructs a new Delete.
         * @memberof NickServRPCResponse
         * @classdesc Represents a Delete.
         * @implements IDelete
         * @constructor
         * @param {NickServRPCResponse.IDelete=} [properties] Properties to set
         */
        function Delete(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Delete instance using the specified properties.
         * @function create
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {NickServRPCResponse.IDelete=} [properties] Properties to set
         * @returns {NickServRPCResponse.Delete} Delete instance
         */
        Delete.create = function create(properties) {
            return new Delete(properties);
        };

        /**
         * Encodes the specified Delete message. Does not implicitly {@link NickServRPCResponse.Delete.verify|verify} messages.
         * @function encode
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {NickServRPCResponse.IDelete} message Delete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Delete.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Delete message, length delimited. Does not implicitly {@link NickServRPCResponse.Delete.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {NickServRPCResponse.IDelete} message Delete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Delete.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Delete message from the specified reader or buffer.
         * @function decode
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NickServRPCResponse.Delete} Delete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Delete.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NickServRPCResponse.Delete();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Delete message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NickServRPCResponse.Delete} Delete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Delete.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Delete message.
         * @function verify
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Delete.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Delete message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NickServRPCResponse.Delete} Delete
         */
        Delete.fromObject = function fromObject(object) {
            if (object instanceof $root.NickServRPCResponse.Delete)
                return object;
            return new $root.NickServRPCResponse.Delete();
        };

        /**
         * Creates a plain object from a Delete message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NickServRPCResponse.Delete
         * @static
         * @param {NickServRPCResponse.Delete} message Delete
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Delete.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Delete to JSON.
         * @function toJSON
         * @memberof NickServRPCResponse.Delete
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Delete.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Delete;
    })();

    return NickServRPCResponse;
})();

export const PeerIndexMessage = $root.PeerIndexMessage = (() => {

    /**
     * Properties of a PeerIndexMessage.
     * @exports IPeerIndexMessage
     * @interface IPeerIndexMessage
     * @property {PeerIndexMessage.IPublish|null} [publish] PeerIndexMessage publish
     * @property {PeerIndexMessage.IUnpublish|null} [unpublish] PeerIndexMessage unpublish
     * @property {PeerIndexMessage.ISearchRequest|null} [searchRequest] PeerIndexMessage searchRequest
     * @property {PeerIndexMessage.ISearchResponse|null} [searchResponse] PeerIndexMessage searchResponse
     */

    /**
     * Constructs a new PeerIndexMessage.
     * @exports PeerIndexMessage
     * @classdesc Represents a PeerIndexMessage.
     * @implements IPeerIndexMessage
     * @constructor
     * @param {IPeerIndexMessage=} [properties] Properties to set
     */
    function PeerIndexMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerIndexMessage publish.
     * @member {PeerIndexMessage.IPublish|null|undefined} publish
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.publish = null;

    /**
     * PeerIndexMessage unpublish.
     * @member {PeerIndexMessage.IUnpublish|null|undefined} unpublish
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.unpublish = null;

    /**
     * PeerIndexMessage searchRequest.
     * @member {PeerIndexMessage.ISearchRequest|null|undefined} searchRequest
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.searchRequest = null;

    /**
     * PeerIndexMessage searchResponse.
     * @member {PeerIndexMessage.ISearchResponse|null|undefined} searchResponse
     * @memberof PeerIndexMessage
     * @instance
     */
    PeerIndexMessage.prototype.searchResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PeerIndexMessage body.
     * @member {"publish"|"unpublish"|"searchRequest"|"searchResponse"|undefined} body
     * @memberof PeerIndexMessage
     * @instance
     */
    Object.defineProperty(PeerIndexMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["publish", "unpublish", "searchRequest", "searchResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PeerIndexMessage instance using the specified properties.
     * @function create
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage=} [properties] Properties to set
     * @returns {PeerIndexMessage} PeerIndexMessage instance
     */
    PeerIndexMessage.create = function create(properties) {
        return new PeerIndexMessage(properties);
    };

    /**
     * Encodes the specified PeerIndexMessage message. Does not implicitly {@link PeerIndexMessage.verify|verify} messages.
     * @function encode
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage} message PeerIndexMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerIndexMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publish != null && Object.hasOwnProperty.call(message, "publish"))
            $root.PeerIndexMessage.Publish.encode(message.publish, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.unpublish != null && Object.hasOwnProperty.call(message, "unpublish"))
            $root.PeerIndexMessage.Unpublish.encode(message.unpublish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.searchRequest != null && Object.hasOwnProperty.call(message, "searchRequest"))
            $root.PeerIndexMessage.SearchRequest.encode(message.searchRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.searchResponse != null && Object.hasOwnProperty.call(message, "searchResponse"))
            $root.PeerIndexMessage.SearchResponse.encode(message.searchResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerIndexMessage message, length delimited. Does not implicitly {@link PeerIndexMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerIndexMessage
     * @static
     * @param {IPeerIndexMessage} message PeerIndexMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerIndexMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerIndexMessage message from the specified reader or buffer.
     * @function decode
     * @memberof PeerIndexMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerIndexMessage} PeerIndexMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerIndexMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.publish = $root.PeerIndexMessage.Publish.decode(reader, reader.uint32());
                break;
            case 2:
                message.unpublish = $root.PeerIndexMessage.Unpublish.decode(reader, reader.uint32());
                break;
            case 3:
                message.searchRequest = $root.PeerIndexMessage.SearchRequest.decode(reader, reader.uint32());
                break;
            case 4:
                message.searchResponse = $root.PeerIndexMessage.SearchResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerIndexMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerIndexMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerIndexMessage} PeerIndexMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerIndexMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerIndexMessage message.
     * @function verify
     * @memberof PeerIndexMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerIndexMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.Publish.verify(message.publish);
                if (error)
                    return "publish." + error;
            }
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.Unpublish.verify(message.unpublish);
                if (error)
                    return "unpublish." + error;
            }
        }
        if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.SearchRequest.verify(message.searchRequest);
                if (error)
                    return "searchRequest." + error;
            }
        }
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerIndexMessage.SearchResponse.verify(message.searchResponse);
                if (error)
                    return "searchResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PeerIndexMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerIndexMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerIndexMessage} PeerIndexMessage
     */
    PeerIndexMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerIndexMessage)
            return object;
        let message = new $root.PeerIndexMessage();
        if (object.publish != null) {
            if (typeof object.publish !== "object")
                throw TypeError(".PeerIndexMessage.publish: object expected");
            message.publish = $root.PeerIndexMessage.Publish.fromObject(object.publish);
        }
        if (object.unpublish != null) {
            if (typeof object.unpublish !== "object")
                throw TypeError(".PeerIndexMessage.unpublish: object expected");
            message.unpublish = $root.PeerIndexMessage.Unpublish.fromObject(object.unpublish);
        }
        if (object.searchRequest != null) {
            if (typeof object.searchRequest !== "object")
                throw TypeError(".PeerIndexMessage.searchRequest: object expected");
            message.searchRequest = $root.PeerIndexMessage.SearchRequest.fromObject(object.searchRequest);
        }
        if (object.searchResponse != null) {
            if (typeof object.searchResponse !== "object")
                throw TypeError(".PeerIndexMessage.searchResponse: object expected");
            message.searchResponse = $root.PeerIndexMessage.SearchResponse.fromObject(object.searchResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerIndexMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerIndexMessage
     * @static
     * @param {PeerIndexMessage} message PeerIndexMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerIndexMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.publish != null && message.hasOwnProperty("publish")) {
            object.publish = $root.PeerIndexMessage.Publish.toObject(message.publish, options);
            if (options.oneofs)
                object.body = "publish";
        }
        if (message.unpublish != null && message.hasOwnProperty("unpublish")) {
            object.unpublish = $root.PeerIndexMessage.Unpublish.toObject(message.unpublish, options);
            if (options.oneofs)
                object.body = "unpublish";
        }
        if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
            object.searchRequest = $root.PeerIndexMessage.SearchRequest.toObject(message.searchRequest, options);
            if (options.oneofs)
                object.body = "searchRequest";
        }
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
            object.searchResponse = $root.PeerIndexMessage.SearchResponse.toObject(message.searchResponse, options);
            if (options.oneofs)
                object.body = "searchResponse";
        }
        return object;
    };

    /**
     * Converts this PeerIndexMessage to JSON.
     * @function toJSON
     * @memberof PeerIndexMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerIndexMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PeerIndexMessage.Record = (function() {

        /**
         * Properties of a Record.
         * @memberof PeerIndexMessage
         * @interface IRecord
         * @property {Uint8Array|null} [hash] Record hash
         * @property {Uint8Array|null} [key] Record key
         * @property {Uint8Array|null} [hostId] Record hostId
         * @property {number|null} [port] Record port
         * @property {number|null} [timestamp] Record timestamp
         * @property {Uint8Array|null} [signature] Record signature
         */

        /**
         * Constructs a new Record.
         * @memberof PeerIndexMessage
         * @classdesc Represents a Record.
         * @implements IRecord
         * @constructor
         * @param {PeerIndexMessage.IRecord=} [properties] Properties to set
         */
        function Record(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Record hash.
         * @member {Uint8Array} hash
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.hash = $util.newBuffer([]);

        /**
         * Record key.
         * @member {Uint8Array} key
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.key = $util.newBuffer([]);

        /**
         * Record hostId.
         * @member {Uint8Array} hostId
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.hostId = $util.newBuffer([]);

        /**
         * Record port.
         * @member {number} port
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.port = 0;

        /**
         * Record timestamp.
         * @member {number} timestamp
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Record signature.
         * @member {Uint8Array} signature
         * @memberof PeerIndexMessage.Record
         * @instance
         */
        Record.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Record instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord=} [properties] Properties to set
         * @returns {PeerIndexMessage.Record} Record instance
         */
        Record.create = function create(properties) {
            return new Record(properties);
        };

        /**
         * Encodes the specified Record message. Does not implicitly {@link PeerIndexMessage.Record.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hostId);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.port);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified Record message, length delimited. Does not implicitly {@link PeerIndexMessage.Record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.IRecord} message Record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Record message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Record();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                case 3:
                    message.hostId = reader.bytes();
                    break;
                case 4:
                    message.port = reader.uint32();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Record} Record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Record message.
         * @function verify
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Record.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.hostId != null && message.hasOwnProperty("hostId"))
                if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                    return "hostId: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a Record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Record} Record
         */
        Record.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Record)
                return object;
            let message = new $root.PeerIndexMessage.Record();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.hostId != null)
                if (typeof object.hostId === "string")
                    $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
                else if (object.hostId.length)
                    message.hostId = object.hostId;
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a Record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Record
         * @static
         * @param {PeerIndexMessage.Record} message Record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.hostId = "";
                else {
                    object.hostId = [];
                    if (options.bytes !== Array)
                        object.hostId = $util.newBuffer(object.hostId);
                }
                object.port = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.hostId != null && message.hasOwnProperty("hostId"))
                object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this Record to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Record;
    })();

    PeerIndexMessage.Publish = (function() {

        /**
         * Properties of a Publish.
         * @memberof PeerIndexMessage
         * @interface IPublish
         * @property {PeerIndexMessage.IRecord|null} [record] Publish record
         */

        /**
         * Constructs a new Publish.
         * @memberof PeerIndexMessage
         * @classdesc Represents a Publish.
         * @implements IPublish
         * @constructor
         * @param {PeerIndexMessage.IPublish=} [properties] Properties to set
         */
        function Publish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Publish record.
         * @member {PeerIndexMessage.IRecord|null|undefined} record
         * @memberof PeerIndexMessage.Publish
         * @instance
         */
        Publish.prototype.record = null;

        /**
         * Creates a new Publish instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish=} [properties] Properties to set
         * @returns {PeerIndexMessage.Publish} Publish instance
         */
        Publish.create = function create(properties) {
            return new Publish(properties);
        };

        /**
         * Encodes the specified Publish message. Does not implicitly {@link PeerIndexMessage.Publish.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.PeerIndexMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Publish message, length delimited. Does not implicitly {@link PeerIndexMessage.Publish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.IPublish} message Publish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Publish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Publish message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Publish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.PeerIndexMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Publish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Publish} Publish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Publish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Publish message.
         * @function verify
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Publish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.PeerIndexMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates a Publish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Publish} Publish
         */
        Publish.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Publish)
                return object;
            let message = new $root.PeerIndexMessage.Publish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".PeerIndexMessage.Publish.record: object expected");
                message.record = $root.PeerIndexMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from a Publish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Publish
         * @static
         * @param {PeerIndexMessage.Publish} message Publish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Publish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.PeerIndexMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Publish to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Publish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Publish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Publish;
    })();

    PeerIndexMessage.Unpublish = (function() {

        /**
         * Properties of an Unpublish.
         * @memberof PeerIndexMessage
         * @interface IUnpublish
         * @property {PeerIndexMessage.IRecord|null} [record] Unpublish record
         */

        /**
         * Constructs a new Unpublish.
         * @memberof PeerIndexMessage
         * @classdesc Represents an Unpublish.
         * @implements IUnpublish
         * @constructor
         * @param {PeerIndexMessage.IUnpublish=} [properties] Properties to set
         */
        function Unpublish(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unpublish record.
         * @member {PeerIndexMessage.IRecord|null|undefined} record
         * @memberof PeerIndexMessage.Unpublish
         * @instance
         */
        Unpublish.prototype.record = null;

        /**
         * Creates a new Unpublish instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish=} [properties] Properties to set
         * @returns {PeerIndexMessage.Unpublish} Unpublish instance
         */
        Unpublish.create = function create(properties) {
            return new Unpublish(properties);
        };

        /**
         * Encodes the specified Unpublish message. Does not implicitly {@link PeerIndexMessage.Unpublish.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                $root.PeerIndexMessage.Record.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Unpublish message, length delimited. Does not implicitly {@link PeerIndexMessage.Unpublish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.IUnpublish} message Unpublish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unpublish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.Unpublish();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.PeerIndexMessage.Record.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Unpublish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unpublish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unpublish message.
         * @function verify
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unpublish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                let error = $root.PeerIndexMessage.Record.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        /**
         * Creates an Unpublish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.Unpublish} Unpublish
         */
        Unpublish.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.Unpublish)
                return object;
            let message = new $root.PeerIndexMessage.Unpublish();
            if (object.record != null) {
                if (typeof object.record !== "object")
                    throw TypeError(".PeerIndexMessage.Unpublish.record: object expected");
                message.record = $root.PeerIndexMessage.Record.fromObject(object.record);
            }
            return message;
        };

        /**
         * Creates a plain object from an Unpublish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.Unpublish
         * @static
         * @param {PeerIndexMessage.Unpublish} message Unpublish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unpublish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.record = null;
            if (message.record != null && message.hasOwnProperty("record"))
                object.record = $root.PeerIndexMessage.Record.toObject(message.record, options);
            return object;
        };

        /**
         * Converts this Unpublish to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.Unpublish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unpublish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unpublish;
    })();

    PeerIndexMessage.SearchRequest = (function() {

        /**
         * Properties of a SearchRequest.
         * @memberof PeerIndexMessage
         * @interface ISearchRequest
         * @property {number|null} [requestId] SearchRequest requestId
         * @property {Uint8Array|null} [hash] SearchRequest hash
         */

        /**
         * Constructs a new SearchRequest.
         * @memberof PeerIndexMessage
         * @classdesc Represents a SearchRequest.
         * @implements ISearchRequest
         * @constructor
         * @param {PeerIndexMessage.ISearchRequest=} [properties] Properties to set
         */
        function SearchRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchRequest requestId.
         * @member {number} requestId
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         */
        SearchRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SearchRequest hash.
         * @member {Uint8Array} hash
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         */
        SearchRequest.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new SearchRequest instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest=} [properties] Properties to set
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest instance
         */
        SearchRequest.create = function create(properties) {
            return new SearchRequest(properties);
        };

        /**
         * Encodes the specified SearchRequest message. Does not implicitly {@link PeerIndexMessage.SearchRequest.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified SearchRequest message, length delimited. Does not implicitly {@link PeerIndexMessage.SearchRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.SearchRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchRequest message.
         * @function verify
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.SearchRequest} SearchRequest
         */
        SearchRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.SearchRequest)
                return object;
            let message = new $root.PeerIndexMessage.SearchRequest();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.SearchRequest
         * @static
         * @param {PeerIndexMessage.SearchRequest} message SearchRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this SearchRequest to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.SearchRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchRequest;
    })();

    PeerIndexMessage.SearchResponse = (function() {

        /**
         * Properties of a SearchResponse.
         * @memberof PeerIndexMessage
         * @interface ISearchResponse
         * @property {number|null} [requestId] SearchResponse requestId
         * @property {Array.<PeerIndexMessage.IRecord>|null} [records] SearchResponse records
         */

        /**
         * Constructs a new SearchResponse.
         * @memberof PeerIndexMessage
         * @classdesc Represents a SearchResponse.
         * @implements ISearchResponse
         * @constructor
         * @param {PeerIndexMessage.ISearchResponse=} [properties] Properties to set
         */
        function SearchResponse(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchResponse requestId.
         * @member {number} requestId
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         */
        SearchResponse.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SearchResponse records.
         * @member {Array.<PeerIndexMessage.IRecord>} records
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         */
        SearchResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new SearchResponse instance using the specified properties.
         * @function create
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse=} [properties] Properties to set
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse instance
         */
        SearchResponse.create = function create(properties) {
            return new SearchResponse(properties);
        };

        /**
         * Encodes the specified SearchResponse message. Does not implicitly {@link PeerIndexMessage.SearchResponse.verify|verify} messages.
         * @function encode
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    $root.PeerIndexMessage.Record.encode(message.records[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link PeerIndexMessage.SearchResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer.
         * @function decode
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerIndexMessage.SearchResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.PeerIndexMessage.Record.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchResponse message.
         * @function verify
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i) {
                    let error = $root.PeerIndexMessage.Record.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerIndexMessage.SearchResponse} SearchResponse
         */
        SearchResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerIndexMessage.SearchResponse)
                return object;
            let message = new $root.PeerIndexMessage.SearchResponse();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".PeerIndexMessage.SearchResponse.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".PeerIndexMessage.SearchResponse.records: object expected");
                    message.records[i] = $root.PeerIndexMessage.Record.fromObject(object.records[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerIndexMessage.SearchResponse
         * @static
         * @param {PeerIndexMessage.SearchResponse} message SearchResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.PeerIndexMessage.Record.toObject(message.records[j], options);
            }
            return object;
        };

        /**
         * Converts this SearchResponse to JSON.
         * @function toJSON
         * @memberof PeerIndexMessage.SearchResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchResponse;
    })();

    return PeerIndexMessage;
})();

export const CreateProfileRequest = $root.CreateProfileRequest = (() => {

    /**
     * Properties of a CreateProfileRequest.
     * @exports ICreateProfileRequest
     * @interface ICreateProfileRequest
     * @property {string|null} [name] CreateProfileRequest name
     * @property {string|null} [password] CreateProfileRequest password
     */

    /**
     * Constructs a new CreateProfileRequest.
     * @exports CreateProfileRequest
     * @classdesc Represents a CreateProfileRequest.
     * @implements ICreateProfileRequest
     * @constructor
     * @param {ICreateProfileRequest=} [properties] Properties to set
     */
    function CreateProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateProfileRequest name.
     * @member {string} name
     * @memberof CreateProfileRequest
     * @instance
     */
    CreateProfileRequest.prototype.name = "";

    /**
     * CreateProfileRequest password.
     * @member {string} password
     * @memberof CreateProfileRequest
     * @instance
     */
    CreateProfileRequest.prototype.password = "";

    /**
     * Creates a new CreateProfileRequest instance using the specified properties.
     * @function create
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest=} [properties] Properties to set
     * @returns {CreateProfileRequest} CreateProfileRequest instance
     */
    CreateProfileRequest.create = function create(properties) {
        return new CreateProfileRequest(properties);
    };

    /**
     * Encodes the specified CreateProfileRequest message. Does not implicitly {@link CreateProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest} message CreateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified CreateProfileRequest message, length delimited. Does not implicitly {@link CreateProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateProfileRequest
     * @static
     * @param {ICreateProfileRequest} message CreateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateProfileRequest} CreateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateProfileRequest} CreateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateProfileRequest message.
     * @function verify
     * @memberof CreateProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates a CreateProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateProfileRequest} CreateProfileRequest
     */
    CreateProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateProfileRequest)
            return object;
        let message = new $root.CreateProfileRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from a CreateProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateProfileRequest
     * @static
     * @param {CreateProfileRequest} message CreateProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.password = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this CreateProfileRequest to JSON.
     * @function toJSON
     * @memberof CreateProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateProfileRequest;
})();

export const CreateProfileResponse = $root.CreateProfileResponse = (() => {

    /**
     * Properties of a CreateProfileResponse.
     * @exports ICreateProfileResponse
     * @interface ICreateProfileResponse
     * @property {string|null} [sessionId] CreateProfileResponse sessionId
     * @property {IProfile|null} [profile] CreateProfileResponse profile
     */

    /**
     * Constructs a new CreateProfileResponse.
     * @exports CreateProfileResponse
     * @classdesc Represents a CreateProfileResponse.
     * @implements ICreateProfileResponse
     * @constructor
     * @param {ICreateProfileResponse=} [properties] Properties to set
     */
    function CreateProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateProfileResponse sessionId.
     * @member {string} sessionId
     * @memberof CreateProfileResponse
     * @instance
     */
    CreateProfileResponse.prototype.sessionId = "";

    /**
     * CreateProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof CreateProfileResponse
     * @instance
     */
    CreateProfileResponse.prototype.profile = null;

    /**
     * Creates a new CreateProfileResponse instance using the specified properties.
     * @function create
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse=} [properties] Properties to set
     * @returns {CreateProfileResponse} CreateProfileResponse instance
     */
    CreateProfileResponse.create = function create(properties) {
        return new CreateProfileResponse(properties);
    };

    /**
     * Encodes the specified CreateProfileResponse message. Does not implicitly {@link CreateProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse} message CreateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateProfileResponse message, length delimited. Does not implicitly {@link CreateProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateProfileResponse
     * @static
     * @param {ICreateProfileResponse} message CreateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateProfileResponse} CreateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateProfileResponse} CreateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateProfileResponse message.
     * @function verify
     * @memberof CreateProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a CreateProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateProfileResponse} CreateProfileResponse
     */
    CreateProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateProfileResponse)
            return object;
        let message = new $root.CreateProfileResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".CreateProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateProfileResponse
     * @static
     * @param {CreateProfileResponse} message CreateProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this CreateProfileResponse to JSON.
     * @function toJSON
     * @memberof CreateProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateProfileResponse;
})();

export const UpdateProfileRequest = $root.UpdateProfileRequest = (() => {

    /**
     * Properties of an UpdateProfileRequest.
     * @exports IUpdateProfileRequest
     * @interface IUpdateProfileRequest
     * @property {string|null} [name] UpdateProfileRequest name
     * @property {string|null} [password] UpdateProfileRequest password
     */

    /**
     * Constructs a new UpdateProfileRequest.
     * @exports UpdateProfileRequest
     * @classdesc Represents an UpdateProfileRequest.
     * @implements IUpdateProfileRequest
     * @constructor
     * @param {IUpdateProfileRequest=} [properties] Properties to set
     */
    function UpdateProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateProfileRequest name.
     * @member {string} name
     * @memberof UpdateProfileRequest
     * @instance
     */
    UpdateProfileRequest.prototype.name = "";

    /**
     * UpdateProfileRequest password.
     * @member {string} password
     * @memberof UpdateProfileRequest
     * @instance
     */
    UpdateProfileRequest.prototype.password = "";

    /**
     * Creates a new UpdateProfileRequest instance using the specified properties.
     * @function create
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest=} [properties] Properties to set
     * @returns {UpdateProfileRequest} UpdateProfileRequest instance
     */
    UpdateProfileRequest.create = function create(properties) {
        return new UpdateProfileRequest(properties);
    };

    /**
     * Encodes the specified UpdateProfileRequest message. Does not implicitly {@link UpdateProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest} message UpdateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified UpdateProfileRequest message, length delimited. Does not implicitly {@link UpdateProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateProfileRequest
     * @static
     * @param {IUpdateProfileRequest} message UpdateProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateProfileRequest message.
     * @function verify
     * @memberof UpdateProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates an UpdateProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateProfileRequest} UpdateProfileRequest
     */
    UpdateProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateProfileRequest)
            return object;
        let message = new $root.UpdateProfileRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from an UpdateProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateProfileRequest
     * @static
     * @param {UpdateProfileRequest} message UpdateProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.password = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this UpdateProfileRequest to JSON.
     * @function toJSON
     * @memberof UpdateProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateProfileRequest;
})();

export const UpdateProfileResponse = $root.UpdateProfileResponse = (() => {

    /**
     * Properties of an UpdateProfileResponse.
     * @exports IUpdateProfileResponse
     * @interface IUpdateProfileResponse
     * @property {IProfile|null} [profile] UpdateProfileResponse profile
     */

    /**
     * Constructs a new UpdateProfileResponse.
     * @exports UpdateProfileResponse
     * @classdesc Represents an UpdateProfileResponse.
     * @implements IUpdateProfileResponse
     * @constructor
     * @param {IUpdateProfileResponse=} [properties] Properties to set
     */
    function UpdateProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof UpdateProfileResponse
     * @instance
     */
    UpdateProfileResponse.prototype.profile = null;

    /**
     * Creates a new UpdateProfileResponse instance using the specified properties.
     * @function create
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse=} [properties] Properties to set
     * @returns {UpdateProfileResponse} UpdateProfileResponse instance
     */
    UpdateProfileResponse.create = function create(properties) {
        return new UpdateProfileResponse(properties);
    };

    /**
     * Encodes the specified UpdateProfileResponse message. Does not implicitly {@link UpdateProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse} message UpdateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateProfileResponse message, length delimited. Does not implicitly {@link UpdateProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateProfileResponse
     * @static
     * @param {IUpdateProfileResponse} message UpdateProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateProfileResponse message.
     * @function verify
     * @memberof UpdateProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateProfileResponse} UpdateProfileResponse
     */
    UpdateProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateProfileResponse)
            return object;
        let message = new $root.UpdateProfileResponse();
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".UpdateProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateProfileResponse
     * @static
     * @param {UpdateProfileResponse} message UpdateProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.profile = null;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this UpdateProfileResponse to JSON.
     * @function toJSON
     * @memberof UpdateProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateProfileResponse;
})();

export const DeleteProfileRequest = $root.DeleteProfileRequest = (() => {

    /**
     * Properties of a DeleteProfileRequest.
     * @exports IDeleteProfileRequest
     * @interface IDeleteProfileRequest
     * @property {number|null} [id] DeleteProfileRequest id
     */

    /**
     * Constructs a new DeleteProfileRequest.
     * @exports DeleteProfileRequest
     * @classdesc Represents a DeleteProfileRequest.
     * @implements IDeleteProfileRequest
     * @constructor
     * @param {IDeleteProfileRequest=} [properties] Properties to set
     */
    function DeleteProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteProfileRequest id.
     * @member {number} id
     * @memberof DeleteProfileRequest
     * @instance
     */
    DeleteProfileRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteProfileRequest instance using the specified properties.
     * @function create
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest=} [properties] Properties to set
     * @returns {DeleteProfileRequest} DeleteProfileRequest instance
     */
    DeleteProfileRequest.create = function create(properties) {
        return new DeleteProfileRequest(properties);
    };

    /**
     * Encodes the specified DeleteProfileRequest message. Does not implicitly {@link DeleteProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest} message DeleteProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteProfileRequest message, length delimited. Does not implicitly {@link DeleteProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteProfileRequest
     * @static
     * @param {IDeleteProfileRequest} message DeleteProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteProfileRequest message.
     * @function verify
     * @memberof DeleteProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteProfileRequest} DeleteProfileRequest
     */
    DeleteProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteProfileRequest)
            return object;
        let message = new $root.DeleteProfileRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteProfileRequest
     * @static
     * @param {DeleteProfileRequest} message DeleteProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteProfileRequest to JSON.
     * @function toJSON
     * @memberof DeleteProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteProfileRequest;
})();

export const DeleteProfileResponse = $root.DeleteProfileResponse = (() => {

    /**
     * Properties of a DeleteProfileResponse.
     * @exports IDeleteProfileResponse
     * @interface IDeleteProfileResponse
     */

    /**
     * Constructs a new DeleteProfileResponse.
     * @exports DeleteProfileResponse
     * @classdesc Represents a DeleteProfileResponse.
     * @implements IDeleteProfileResponse
     * @constructor
     * @param {IDeleteProfileResponse=} [properties] Properties to set
     */
    function DeleteProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteProfileResponse instance using the specified properties.
     * @function create
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse=} [properties] Properties to set
     * @returns {DeleteProfileResponse} DeleteProfileResponse instance
     */
    DeleteProfileResponse.create = function create(properties) {
        return new DeleteProfileResponse(properties);
    };

    /**
     * Encodes the specified DeleteProfileResponse message. Does not implicitly {@link DeleteProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse} message DeleteProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteProfileResponse message, length delimited. Does not implicitly {@link DeleteProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteProfileResponse
     * @static
     * @param {IDeleteProfileResponse} message DeleteProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteProfileResponse message.
     * @function verify
     * @memberof DeleteProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteProfileResponse} DeleteProfileResponse
     */
    DeleteProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteProfileResponse)
            return object;
        return new $root.DeleteProfileResponse();
    };

    /**
     * Creates a plain object from a DeleteProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteProfileResponse
     * @static
     * @param {DeleteProfileResponse} message DeleteProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteProfileResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteProfileResponse to JSON.
     * @function toJSON
     * @memberof DeleteProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteProfileResponse;
})();

export const LoadProfileRequest = $root.LoadProfileRequest = (() => {

    /**
     * Properties of a LoadProfileRequest.
     * @exports ILoadProfileRequest
     * @interface ILoadProfileRequest
     * @property {number|null} [id] LoadProfileRequest id
     * @property {string|null} [name] LoadProfileRequest name
     * @property {string|null} [password] LoadProfileRequest password
     */

    /**
     * Constructs a new LoadProfileRequest.
     * @exports LoadProfileRequest
     * @classdesc Represents a LoadProfileRequest.
     * @implements ILoadProfileRequest
     * @constructor
     * @param {ILoadProfileRequest=} [properties] Properties to set
     */
    function LoadProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadProfileRequest id.
     * @member {number} id
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * LoadProfileRequest name.
     * @member {string} name
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.name = "";

    /**
     * LoadProfileRequest password.
     * @member {string} password
     * @memberof LoadProfileRequest
     * @instance
     */
    LoadProfileRequest.prototype.password = "";

    /**
     * Creates a new LoadProfileRequest instance using the specified properties.
     * @function create
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest=} [properties] Properties to set
     * @returns {LoadProfileRequest} LoadProfileRequest instance
     */
    LoadProfileRequest.create = function create(properties) {
        return new LoadProfileRequest(properties);
    };

    /**
     * Encodes the specified LoadProfileRequest message. Does not implicitly {@link LoadProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest} message LoadProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
        return writer;
    };

    /**
     * Encodes the specified LoadProfileRequest message, length delimited. Does not implicitly {@link LoadProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadProfileRequest
     * @static
     * @param {ILoadProfileRequest} message LoadProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LoadProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadProfileRequest} LoadProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.password = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadProfileRequest} LoadProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadProfileRequest message.
     * @function verify
     * @memberof LoadProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.password != null && message.hasOwnProperty("password"))
            if (!$util.isString(message.password))
                return "password: string expected";
        return null;
    };

    /**
     * Creates a LoadProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadProfileRequest} LoadProfileRequest
     */
    LoadProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadProfileRequest)
            return object;
        let message = new $root.LoadProfileRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.password != null)
            message.password = String(object.password);
        return message;
    };

    /**
     * Creates a plain object from a LoadProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadProfileRequest
     * @static
     * @param {LoadProfileRequest} message LoadProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            object.password = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.password != null && message.hasOwnProperty("password"))
            object.password = message.password;
        return object;
    };

    /**
     * Converts this LoadProfileRequest to JSON.
     * @function toJSON
     * @memberof LoadProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadProfileRequest;
})();

export const LoadProfileResponse = $root.LoadProfileResponse = (() => {

    /**
     * Properties of a LoadProfileResponse.
     * @exports ILoadProfileResponse
     * @interface ILoadProfileResponse
     * @property {string|null} [sessionId] LoadProfileResponse sessionId
     * @property {IProfile|null} [profile] LoadProfileResponse profile
     */

    /**
     * Constructs a new LoadProfileResponse.
     * @exports LoadProfileResponse
     * @classdesc Represents a LoadProfileResponse.
     * @implements ILoadProfileResponse
     * @constructor
     * @param {ILoadProfileResponse=} [properties] Properties to set
     */
    function LoadProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadProfileResponse sessionId.
     * @member {string} sessionId
     * @memberof LoadProfileResponse
     * @instance
     */
    LoadProfileResponse.prototype.sessionId = "";

    /**
     * LoadProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof LoadProfileResponse
     * @instance
     */
    LoadProfileResponse.prototype.profile = null;

    /**
     * Creates a new LoadProfileResponse instance using the specified properties.
     * @function create
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse=} [properties] Properties to set
     * @returns {LoadProfileResponse} LoadProfileResponse instance
     */
    LoadProfileResponse.create = function create(properties) {
        return new LoadProfileResponse(properties);
    };

    /**
     * Encodes the specified LoadProfileResponse message. Does not implicitly {@link LoadProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse} message LoadProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LoadProfileResponse message, length delimited. Does not implicitly {@link LoadProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadProfileResponse
     * @static
     * @param {ILoadProfileResponse} message LoadProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LoadProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadProfileResponse} LoadProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadProfileResponse} LoadProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadProfileResponse message.
     * @function verify
     * @memberof LoadProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a LoadProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadProfileResponse} LoadProfileResponse
     */
    LoadProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadProfileResponse)
            return object;
        let message = new $root.LoadProfileResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".LoadProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a LoadProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadProfileResponse
     * @static
     * @param {LoadProfileResponse} message LoadProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this LoadProfileResponse to JSON.
     * @function toJSON
     * @memberof LoadProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadProfileResponse;
})();

export const GetProfileRequest = $root.GetProfileRequest = (() => {

    /**
     * Properties of a GetProfileRequest.
     * @exports IGetProfileRequest
     * @interface IGetProfileRequest
     * @property {string|null} [sessionId] GetProfileRequest sessionId
     */

    /**
     * Constructs a new GetProfileRequest.
     * @exports GetProfileRequest
     * @classdesc Represents a GetProfileRequest.
     * @implements IGetProfileRequest
     * @constructor
     * @param {IGetProfileRequest=} [properties] Properties to set
     */
    function GetProfileRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetProfileRequest sessionId.
     * @member {string} sessionId
     * @memberof GetProfileRequest
     * @instance
     */
    GetProfileRequest.prototype.sessionId = "";

    /**
     * Creates a new GetProfileRequest instance using the specified properties.
     * @function create
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest=} [properties] Properties to set
     * @returns {GetProfileRequest} GetProfileRequest instance
     */
    GetProfileRequest.create = function create(properties) {
        return new GetProfileRequest(properties);
    };

    /**
     * Encodes the specified GetProfileRequest message. Does not implicitly {@link GetProfileRequest.verify|verify} messages.
     * @function encode
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest} message GetProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        return writer;
    };

    /**
     * Encodes the specified GetProfileRequest message, length delimited. Does not implicitly {@link GetProfileRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfileRequest
     * @static
     * @param {IGetProfileRequest} message GetProfileRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfileRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfileRequest} GetProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfileRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfileRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfileRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfileRequest} GetProfileRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfileRequest message.
     * @function verify
     * @memberof GetProfileRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfileRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        return null;
    };

    /**
     * Creates a GetProfileRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfileRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfileRequest} GetProfileRequest
     */
    GetProfileRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfileRequest)
            return object;
        let message = new $root.GetProfileRequest();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        return message;
    };

    /**
     * Creates a plain object from a GetProfileRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfileRequest
     * @static
     * @param {GetProfileRequest} message GetProfileRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfileRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.sessionId = "";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        return object;
    };

    /**
     * Converts this GetProfileRequest to JSON.
     * @function toJSON
     * @memberof GetProfileRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfileRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfileRequest;
})();

export const GetProfileResponse = $root.GetProfileResponse = (() => {

    /**
     * Properties of a GetProfileResponse.
     * @exports IGetProfileResponse
     * @interface IGetProfileResponse
     * @property {IProfile|null} [profile] GetProfileResponse profile
     */

    /**
     * Constructs a new GetProfileResponse.
     * @exports GetProfileResponse
     * @classdesc Represents a GetProfileResponse.
     * @implements IGetProfileResponse
     * @constructor
     * @param {IGetProfileResponse=} [properties] Properties to set
     */
    function GetProfileResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetProfileResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof GetProfileResponse
     * @instance
     */
    GetProfileResponse.prototype.profile = null;

    /**
     * Creates a new GetProfileResponse instance using the specified properties.
     * @function create
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse=} [properties] Properties to set
     * @returns {GetProfileResponse} GetProfileResponse instance
     */
    GetProfileResponse.create = function create(properties) {
        return new GetProfileResponse(properties);
    };

    /**
     * Encodes the specified GetProfileResponse message. Does not implicitly {@link GetProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse} message GetProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetProfileResponse message, length delimited. Does not implicitly {@link GetProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetProfileResponse
     * @static
     * @param {IGetProfileResponse} message GetProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetProfileResponse} GetProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetProfileResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetProfileResponse} GetProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetProfileResponse message.
     * @function verify
     * @memberof GetProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a GetProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetProfileResponse} GetProfileResponse
     */
    GetProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetProfileResponse)
            return object;
        let message = new $root.GetProfileResponse();
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".GetProfileResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetProfileResponse
     * @static
     * @param {GetProfileResponse} message GetProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.profile = null;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this GetProfileResponse to JSON.
     * @function toJSON
     * @memberof GetProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetProfileResponse;
})();

export const ListProfilesRequest = $root.ListProfilesRequest = (() => {

    /**
     * Properties of a ListProfilesRequest.
     * @exports IListProfilesRequest
     * @interface IListProfilesRequest
     */

    /**
     * Constructs a new ListProfilesRequest.
     * @exports ListProfilesRequest
     * @classdesc Represents a ListProfilesRequest.
     * @implements IListProfilesRequest
     * @constructor
     * @param {IListProfilesRequest=} [properties] Properties to set
     */
    function ListProfilesRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ListProfilesRequest instance using the specified properties.
     * @function create
     * @memberof ListProfilesRequest
     * @static
     * @param {IListProfilesRequest=} [properties] Properties to set
     * @returns {ListProfilesRequest} ListProfilesRequest instance
     */
    ListProfilesRequest.create = function create(properties) {
        return new ListProfilesRequest(properties);
    };

    /**
     * Encodes the specified ListProfilesRequest message. Does not implicitly {@link ListProfilesRequest.verify|verify} messages.
     * @function encode
     * @memberof ListProfilesRequest
     * @static
     * @param {IListProfilesRequest} message ListProfilesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListProfilesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ListProfilesRequest message, length delimited. Does not implicitly {@link ListProfilesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListProfilesRequest
     * @static
     * @param {IListProfilesRequest} message ListProfilesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListProfilesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListProfilesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ListProfilesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListProfilesRequest} ListProfilesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListProfilesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListProfilesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListProfilesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListProfilesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListProfilesRequest} ListProfilesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListProfilesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListProfilesRequest message.
     * @function verify
     * @memberof ListProfilesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListProfilesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ListProfilesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListProfilesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListProfilesRequest} ListProfilesRequest
     */
    ListProfilesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ListProfilesRequest)
            return object;
        return new $root.ListProfilesRequest();
    };

    /**
     * Creates a plain object from a ListProfilesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListProfilesRequest
     * @static
     * @param {ListProfilesRequest} message ListProfilesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListProfilesRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ListProfilesRequest to JSON.
     * @function toJSON
     * @memberof ListProfilesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListProfilesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListProfilesRequest;
})();

export const ListProfilesResponse = $root.ListProfilesResponse = (() => {

    /**
     * Properties of a ListProfilesResponse.
     * @exports IListProfilesResponse
     * @interface IListProfilesResponse
     * @property {Array.<IProfileSummary>|null} [profiles] ListProfilesResponse profiles
     */

    /**
     * Constructs a new ListProfilesResponse.
     * @exports ListProfilesResponse
     * @classdesc Represents a ListProfilesResponse.
     * @implements IListProfilesResponse
     * @constructor
     * @param {IListProfilesResponse=} [properties] Properties to set
     */
    function ListProfilesResponse(properties) {
        this.profiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListProfilesResponse profiles.
     * @member {Array.<IProfileSummary>} profiles
     * @memberof ListProfilesResponse
     * @instance
     */
    ListProfilesResponse.prototype.profiles = $util.emptyArray;

    /**
     * Creates a new ListProfilesResponse instance using the specified properties.
     * @function create
     * @memberof ListProfilesResponse
     * @static
     * @param {IListProfilesResponse=} [properties] Properties to set
     * @returns {ListProfilesResponse} ListProfilesResponse instance
     */
    ListProfilesResponse.create = function create(properties) {
        return new ListProfilesResponse(properties);
    };

    /**
     * Encodes the specified ListProfilesResponse message. Does not implicitly {@link ListProfilesResponse.verify|verify} messages.
     * @function encode
     * @memberof ListProfilesResponse
     * @static
     * @param {IListProfilesResponse} message ListProfilesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListProfilesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profiles != null && message.profiles.length)
            for (let i = 0; i < message.profiles.length; ++i)
                $root.ProfileSummary.encode(message.profiles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListProfilesResponse message, length delimited. Does not implicitly {@link ListProfilesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListProfilesResponse
     * @static
     * @param {IListProfilesResponse} message ListProfilesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListProfilesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListProfilesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListProfilesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListProfilesResponse} ListProfilesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListProfilesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListProfilesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.profiles && message.profiles.length))
                    message.profiles = [];
                message.profiles.push($root.ProfileSummary.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListProfilesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListProfilesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListProfilesResponse} ListProfilesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListProfilesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListProfilesResponse message.
     * @function verify
     * @memberof ListProfilesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListProfilesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profiles != null && message.hasOwnProperty("profiles")) {
            if (!Array.isArray(message.profiles))
                return "profiles: array expected";
            for (let i = 0; i < message.profiles.length; ++i) {
                let error = $root.ProfileSummary.verify(message.profiles[i]);
                if (error)
                    return "profiles." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListProfilesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListProfilesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListProfilesResponse} ListProfilesResponse
     */
    ListProfilesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListProfilesResponse)
            return object;
        let message = new $root.ListProfilesResponse();
        if (object.profiles) {
            if (!Array.isArray(object.profiles))
                throw TypeError(".ListProfilesResponse.profiles: array expected");
            message.profiles = [];
            for (let i = 0; i < object.profiles.length; ++i) {
                if (typeof object.profiles[i] !== "object")
                    throw TypeError(".ListProfilesResponse.profiles: object expected");
                message.profiles[i] = $root.ProfileSummary.fromObject(object.profiles[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListProfilesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListProfilesResponse
     * @static
     * @param {ListProfilesResponse} message ListProfilesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListProfilesResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.profiles = [];
        if (message.profiles && message.profiles.length) {
            object.profiles = [];
            for (let j = 0; j < message.profiles.length; ++j)
                object.profiles[j] = $root.ProfileSummary.toObject(message.profiles[j], options);
        }
        return object;
    };

    /**
     * Converts this ListProfilesResponse to JSON.
     * @function toJSON
     * @memberof ListProfilesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListProfilesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListProfilesResponse;
})();

export const LoadSessionRequest = $root.LoadSessionRequest = (() => {

    /**
     * Properties of a LoadSessionRequest.
     * @exports ILoadSessionRequest
     * @interface ILoadSessionRequest
     * @property {string|null} [sessionId] LoadSessionRequest sessionId
     */

    /**
     * Constructs a new LoadSessionRequest.
     * @exports LoadSessionRequest
     * @classdesc Represents a LoadSessionRequest.
     * @implements ILoadSessionRequest
     * @constructor
     * @param {ILoadSessionRequest=} [properties] Properties to set
     */
    function LoadSessionRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadSessionRequest sessionId.
     * @member {string} sessionId
     * @memberof LoadSessionRequest
     * @instance
     */
    LoadSessionRequest.prototype.sessionId = "";

    /**
     * Creates a new LoadSessionRequest instance using the specified properties.
     * @function create
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest=} [properties] Properties to set
     * @returns {LoadSessionRequest} LoadSessionRequest instance
     */
    LoadSessionRequest.create = function create(properties) {
        return new LoadSessionRequest(properties);
    };

    /**
     * Encodes the specified LoadSessionRequest message. Does not implicitly {@link LoadSessionRequest.verify|verify} messages.
     * @function encode
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest} message LoadSessionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        return writer;
    };

    /**
     * Encodes the specified LoadSessionRequest message, length delimited. Does not implicitly {@link LoadSessionRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadSessionRequest
     * @static
     * @param {ILoadSessionRequest} message LoadSessionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadSessionRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LoadSessionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadSessionRequest} LoadSessionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadSessionRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadSessionRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadSessionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadSessionRequest} LoadSessionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadSessionRequest message.
     * @function verify
     * @memberof LoadSessionRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadSessionRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        return null;
    };

    /**
     * Creates a LoadSessionRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadSessionRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadSessionRequest} LoadSessionRequest
     */
    LoadSessionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadSessionRequest)
            return object;
        let message = new $root.LoadSessionRequest();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        return message;
    };

    /**
     * Creates a plain object from a LoadSessionRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadSessionRequest
     * @static
     * @param {LoadSessionRequest} message LoadSessionRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadSessionRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.sessionId = "";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        return object;
    };

    /**
     * Converts this LoadSessionRequest to JSON.
     * @function toJSON
     * @memberof LoadSessionRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadSessionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadSessionRequest;
})();

export const LoadSessionResponse = $root.LoadSessionResponse = (() => {

    /**
     * Properties of a LoadSessionResponse.
     * @exports ILoadSessionResponse
     * @interface ILoadSessionResponse
     * @property {string|null} [sessionId] LoadSessionResponse sessionId
     * @property {IProfile|null} [profile] LoadSessionResponse profile
     */

    /**
     * Constructs a new LoadSessionResponse.
     * @exports LoadSessionResponse
     * @classdesc Represents a LoadSessionResponse.
     * @implements ILoadSessionResponse
     * @constructor
     * @param {ILoadSessionResponse=} [properties] Properties to set
     */
    function LoadSessionResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoadSessionResponse sessionId.
     * @member {string} sessionId
     * @memberof LoadSessionResponse
     * @instance
     */
    LoadSessionResponse.prototype.sessionId = "";

    /**
     * LoadSessionResponse profile.
     * @member {IProfile|null|undefined} profile
     * @memberof LoadSessionResponse
     * @instance
     */
    LoadSessionResponse.prototype.profile = null;

    /**
     * Creates a new LoadSessionResponse instance using the specified properties.
     * @function create
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse=} [properties] Properties to set
     * @returns {LoadSessionResponse} LoadSessionResponse instance
     */
    LoadSessionResponse.create = function create(properties) {
        return new LoadSessionResponse(properties);
    };

    /**
     * Encodes the specified LoadSessionResponse message. Does not implicitly {@link LoadSessionResponse.verify|verify} messages.
     * @function encode
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse} message LoadSessionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
        if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
            $root.Profile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LoadSessionResponse message, length delimited. Does not implicitly {@link LoadSessionResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LoadSessionResponse
     * @static
     * @param {ILoadSessionResponse} message LoadSessionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoadSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoadSessionResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LoadSessionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LoadSessionResponse} LoadSessionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LoadSessionResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sessionId = reader.string();
                break;
            case 2:
                message.profile = $root.Profile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LoadSessionResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LoadSessionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LoadSessionResponse} LoadSessionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoadSessionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoadSessionResponse message.
     * @function verify
     * @memberof LoadSessionResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoadSessionResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            if (!$util.isString(message.sessionId))
                return "sessionId: string expected";
        if (message.profile != null && message.hasOwnProperty("profile")) {
            let error = $root.Profile.verify(message.profile);
            if (error)
                return "profile." + error;
        }
        return null;
    };

    /**
     * Creates a LoadSessionResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LoadSessionResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LoadSessionResponse} LoadSessionResponse
     */
    LoadSessionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LoadSessionResponse)
            return object;
        let message = new $root.LoadSessionResponse();
        if (object.sessionId != null)
            message.sessionId = String(object.sessionId);
        if (object.profile != null) {
            if (typeof object.profile !== "object")
                throw TypeError(".LoadSessionResponse.profile: object expected");
            message.profile = $root.Profile.fromObject(object.profile);
        }
        return message;
    };

    /**
     * Creates a plain object from a LoadSessionResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LoadSessionResponse
     * @static
     * @param {LoadSessionResponse} message LoadSessionResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoadSessionResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.sessionId = "";
            object.profile = null;
        }
        if (message.sessionId != null && message.hasOwnProperty("sessionId"))
            object.sessionId = message.sessionId;
        if (message.profile != null && message.hasOwnProperty("profile"))
            object.profile = $root.Profile.toObject(message.profile, options);
        return object;
    };

    /**
     * Converts this LoadSessionResponse to JSON.
     * @function toJSON
     * @memberof LoadSessionResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoadSessionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LoadSessionResponse;
})();

export const NetworkIcon = $root.NetworkIcon = (() => {

    /**
     * Properties of a NetworkIcon.
     * @exports INetworkIcon
     * @interface INetworkIcon
     * @property {Uint8Array|null} [data] NetworkIcon data
     * @property {string|null} [type] NetworkIcon type
     */

    /**
     * Constructs a new NetworkIcon.
     * @exports NetworkIcon
     * @classdesc Represents a NetworkIcon.
     * @implements INetworkIcon
     * @constructor
     * @param {INetworkIcon=} [properties] Properties to set
     */
    function NetworkIcon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkIcon data.
     * @member {Uint8Array} data
     * @memberof NetworkIcon
     * @instance
     */
    NetworkIcon.prototype.data = $util.newBuffer([]);

    /**
     * NetworkIcon type.
     * @member {string} type
     * @memberof NetworkIcon
     * @instance
     */
    NetworkIcon.prototype.type = "";

    /**
     * Creates a new NetworkIcon instance using the specified properties.
     * @function create
     * @memberof NetworkIcon
     * @static
     * @param {INetworkIcon=} [properties] Properties to set
     * @returns {NetworkIcon} NetworkIcon instance
     */
    NetworkIcon.create = function create(properties) {
        return new NetworkIcon(properties);
    };

    /**
     * Encodes the specified NetworkIcon message. Does not implicitly {@link NetworkIcon.verify|verify} messages.
     * @function encode
     * @memberof NetworkIcon
     * @static
     * @param {INetworkIcon} message NetworkIcon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkIcon.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
        return writer;
    };

    /**
     * Encodes the specified NetworkIcon message, length delimited. Does not implicitly {@link NetworkIcon.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkIcon
     * @static
     * @param {INetworkIcon} message NetworkIcon message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkIcon.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkIcon message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkIcon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkIcon} NetworkIcon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkIcon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkIcon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = reader.bytes();
                break;
            case 2:
                message.type = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkIcon message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkIcon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkIcon} NetworkIcon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkIcon.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkIcon message.
     * @function verify
     * @memberof NetworkIcon
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkIcon.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isString(message.type))
                return "type: string expected";
        return null;
    };

    /**
     * Creates a NetworkIcon message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkIcon
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkIcon} NetworkIcon
     */
    NetworkIcon.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkIcon)
            return object;
        let message = new $root.NetworkIcon();
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        if (object.type != null)
            message.type = String(object.type);
        return message;
    };

    /**
     * Creates a plain object from a NetworkIcon message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkIcon
     * @static
     * @param {NetworkIcon} message NetworkIcon
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkIcon.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
            object.type = "";
        }
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        return object;
    };

    /**
     * Converts this NetworkIcon to JSON.
     * @function toJSON
     * @memberof NetworkIcon
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkIcon.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NetworkIcon;
})();

export const CreateNetworkRequest = $root.CreateNetworkRequest = (() => {

    /**
     * Properties of a CreateNetworkRequest.
     * @exports ICreateNetworkRequest
     * @interface ICreateNetworkRequest
     * @property {string|null} [name] CreateNetworkRequest name
     * @property {INetworkIcon|null} [icon] CreateNetworkRequest icon
     */

    /**
     * Constructs a new CreateNetworkRequest.
     * @exports CreateNetworkRequest
     * @classdesc Represents a CreateNetworkRequest.
     * @implements ICreateNetworkRequest
     * @constructor
     * @param {ICreateNetworkRequest=} [properties] Properties to set
     */
    function CreateNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkRequest name.
     * @member {string} name
     * @memberof CreateNetworkRequest
     * @instance
     */
    CreateNetworkRequest.prototype.name = "";

    /**
     * CreateNetworkRequest icon.
     * @member {INetworkIcon|null|undefined} icon
     * @memberof CreateNetworkRequest
     * @instance
     */
    CreateNetworkRequest.prototype.icon = null;

    /**
     * Creates a new CreateNetworkRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest=} [properties] Properties to set
     * @returns {CreateNetworkRequest} CreateNetworkRequest instance
     */
    CreateNetworkRequest.create = function create(properties) {
        return new CreateNetworkRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkRequest message. Does not implicitly {@link CreateNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            $root.NetworkIcon.encode(message.icon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkRequest message, length delimited. Does not implicitly {@link CreateNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkRequest
     * @static
     * @param {ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.icon = $root.NetworkIcon.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkRequest message.
     * @function verify
     * @memberof CreateNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.icon != null && message.hasOwnProperty("icon")) {
            let error = $root.NetworkIcon.verify(message.icon);
            if (error)
                return "icon." + error;
        }
        return null;
    };

    /**
     * Creates a CreateNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkRequest} CreateNetworkRequest
     */
    CreateNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkRequest)
            return object;
        let message = new $root.CreateNetworkRequest();
        if (object.name != null)
            message.name = String(object.name);
        if (object.icon != null) {
            if (typeof object.icon !== "object")
                throw TypeError(".CreateNetworkRequest.icon: object expected");
            message.icon = $root.NetworkIcon.fromObject(object.icon);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkRequest
     * @static
     * @param {CreateNetworkRequest} message CreateNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.icon = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = $root.NetworkIcon.toObject(message.icon, options);
        return object;
    };

    /**
     * Converts this CreateNetworkRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkRequest;
})();

export const CreateNetworkResponse = $root.CreateNetworkResponse = (() => {

    /**
     * Properties of a CreateNetworkResponse.
     * @exports ICreateNetworkResponse
     * @interface ICreateNetworkResponse
     * @property {INetwork|null} [network] CreateNetworkResponse network
     */

    /**
     * Constructs a new CreateNetworkResponse.
     * @exports CreateNetworkResponse
     * @classdesc Represents a CreateNetworkResponse.
     * @implements ICreateNetworkResponse
     * @constructor
     * @param {ICreateNetworkResponse=} [properties] Properties to set
     */
    function CreateNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof CreateNetworkResponse
     * @instance
     */
    CreateNetworkResponse.prototype.network = null;

    /**
     * Creates a new CreateNetworkResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse=} [properties] Properties to set
     * @returns {CreateNetworkResponse} CreateNetworkResponse instance
     */
    CreateNetworkResponse.create = function create(properties) {
        return new CreateNetworkResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkResponse message. Does not implicitly {@link CreateNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse} message CreateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkResponse message, length delimited. Does not implicitly {@link CreateNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkResponse
     * @static
     * @param {ICreateNetworkResponse} message CreateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkResponse message.
     * @function verify
     * @memberof CreateNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a CreateNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkResponse} CreateNetworkResponse
     */
    CreateNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkResponse)
            return object;
        let message = new $root.CreateNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".CreateNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkResponse
     * @static
     * @param {CreateNetworkResponse} message CreateNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this CreateNetworkResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkResponse;
})();

export const UpdateNetworkRequest = $root.UpdateNetworkRequest = (() => {

    /**
     * Properties of an UpdateNetworkRequest.
     * @exports IUpdateNetworkRequest
     * @interface IUpdateNetworkRequest
     * @property {number|null} [id] UpdateNetworkRequest id
     * @property {string|null} [name] UpdateNetworkRequest name
     */

    /**
     * Constructs a new UpdateNetworkRequest.
     * @exports UpdateNetworkRequest
     * @classdesc Represents an UpdateNetworkRequest.
     * @implements IUpdateNetworkRequest
     * @constructor
     * @param {IUpdateNetworkRequest=} [properties] Properties to set
     */
    function UpdateNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateNetworkRequest id.
     * @member {number} id
     * @memberof UpdateNetworkRequest
     * @instance
     */
    UpdateNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateNetworkRequest name.
     * @member {string} name
     * @memberof UpdateNetworkRequest
     * @instance
     */
    UpdateNetworkRequest.prototype.name = "";

    /**
     * Creates a new UpdateNetworkRequest instance using the specified properties.
     * @function create
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest=} [properties] Properties to set
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest instance
     */
    UpdateNetworkRequest.create = function create(properties) {
        return new UpdateNetworkRequest(properties);
    };

    /**
     * Encodes the specified UpdateNetworkRequest message. Does not implicitly {@link UpdateNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest} message UpdateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified UpdateNetworkRequest message, length delimited. Does not implicitly {@link UpdateNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateNetworkRequest
     * @static
     * @param {IUpdateNetworkRequest} message UpdateNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateNetworkRequest message.
     * @function verify
     * @memberof UpdateNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates an UpdateNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateNetworkRequest} UpdateNetworkRequest
     */
    UpdateNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateNetworkRequest)
            return object;
        let message = new $root.UpdateNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from an UpdateNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateNetworkRequest
     * @static
     * @param {UpdateNetworkRequest} message UpdateNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this UpdateNetworkRequest to JSON.
     * @function toJSON
     * @memberof UpdateNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateNetworkRequest;
})();

export const UpdateNetworkResponse = $root.UpdateNetworkResponse = (() => {

    /**
     * Properties of an UpdateNetworkResponse.
     * @exports IUpdateNetworkResponse
     * @interface IUpdateNetworkResponse
     * @property {INetwork|null} [network] UpdateNetworkResponse network
     */

    /**
     * Constructs a new UpdateNetworkResponse.
     * @exports UpdateNetworkResponse
     * @classdesc Represents an UpdateNetworkResponse.
     * @implements IUpdateNetworkResponse
     * @constructor
     * @param {IUpdateNetworkResponse=} [properties] Properties to set
     */
    function UpdateNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof UpdateNetworkResponse
     * @instance
     */
    UpdateNetworkResponse.prototype.network = null;

    /**
     * Creates a new UpdateNetworkResponse instance using the specified properties.
     * @function create
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse=} [properties] Properties to set
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse instance
     */
    UpdateNetworkResponse.create = function create(properties) {
        return new UpdateNetworkResponse(properties);
    };

    /**
     * Encodes the specified UpdateNetworkResponse message. Does not implicitly {@link UpdateNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse} message UpdateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateNetworkResponse message, length delimited. Does not implicitly {@link UpdateNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateNetworkResponse
     * @static
     * @param {IUpdateNetworkResponse} message UpdateNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateNetworkResponse message.
     * @function verify
     * @memberof UpdateNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateNetworkResponse} UpdateNetworkResponse
     */
    UpdateNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateNetworkResponse)
            return object;
        let message = new $root.UpdateNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".UpdateNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateNetworkResponse
     * @static
     * @param {UpdateNetworkResponse} message UpdateNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this UpdateNetworkResponse to JSON.
     * @function toJSON
     * @memberof UpdateNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateNetworkResponse;
})();

export const DeleteNetworkRequest = $root.DeleteNetworkRequest = (() => {

    /**
     * Properties of a DeleteNetworkRequest.
     * @exports IDeleteNetworkRequest
     * @interface IDeleteNetworkRequest
     * @property {number|null} [id] DeleteNetworkRequest id
     */

    /**
     * Constructs a new DeleteNetworkRequest.
     * @exports DeleteNetworkRequest
     * @classdesc Represents a DeleteNetworkRequest.
     * @implements IDeleteNetworkRequest
     * @constructor
     * @param {IDeleteNetworkRequest=} [properties] Properties to set
     */
    function DeleteNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteNetworkRequest id.
     * @member {number} id
     * @memberof DeleteNetworkRequest
     * @instance
     */
    DeleteNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteNetworkRequest instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest=} [properties] Properties to set
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest instance
     */
    DeleteNetworkRequest.create = function create(properties) {
        return new DeleteNetworkRequest(properties);
    };

    /**
     * Encodes the specified DeleteNetworkRequest message. Does not implicitly {@link DeleteNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest} message DeleteNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkRequest message, length delimited. Does not implicitly {@link DeleteNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkRequest
     * @static
     * @param {IDeleteNetworkRequest} message DeleteNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkRequest message.
     * @function verify
     * @memberof DeleteNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkRequest} DeleteNetworkRequest
     */
    DeleteNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkRequest)
            return object;
        let message = new $root.DeleteNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkRequest
     * @static
     * @param {DeleteNetworkRequest} message DeleteNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteNetworkRequest to JSON.
     * @function toJSON
     * @memberof DeleteNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkRequest;
})();

export const DeleteNetworkResponse = $root.DeleteNetworkResponse = (() => {

    /**
     * Properties of a DeleteNetworkResponse.
     * @exports IDeleteNetworkResponse
     * @interface IDeleteNetworkResponse
     */

    /**
     * Constructs a new DeleteNetworkResponse.
     * @exports DeleteNetworkResponse
     * @classdesc Represents a DeleteNetworkResponse.
     * @implements IDeleteNetworkResponse
     * @constructor
     * @param {IDeleteNetworkResponse=} [properties] Properties to set
     */
    function DeleteNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteNetworkResponse instance using the specified properties.
     * @function create
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse=} [properties] Properties to set
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse instance
     */
    DeleteNetworkResponse.create = function create(properties) {
        return new DeleteNetworkResponse(properties);
    };

    /**
     * Encodes the specified DeleteNetworkResponse message. Does not implicitly {@link DeleteNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse} message DeleteNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteNetworkResponse message, length delimited. Does not implicitly {@link DeleteNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteNetworkResponse
     * @static
     * @param {IDeleteNetworkResponse} message DeleteNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteNetworkResponse message.
     * @function verify
     * @memberof DeleteNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteNetworkResponse} DeleteNetworkResponse
     */
    DeleteNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteNetworkResponse)
            return object;
        return new $root.DeleteNetworkResponse();
    };

    /**
     * Creates a plain object from a DeleteNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteNetworkResponse
     * @static
     * @param {DeleteNetworkResponse} message DeleteNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteNetworkResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteNetworkResponse to JSON.
     * @function toJSON
     * @memberof DeleteNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteNetworkResponse;
})();

export const GetNetworkRequest = $root.GetNetworkRequest = (() => {

    /**
     * Properties of a GetNetworkRequest.
     * @exports IGetNetworkRequest
     * @interface IGetNetworkRequest
     * @property {number|null} [id] GetNetworkRequest id
     */

    /**
     * Constructs a new GetNetworkRequest.
     * @exports GetNetworkRequest
     * @classdesc Represents a GetNetworkRequest.
     * @implements IGetNetworkRequest
     * @constructor
     * @param {IGetNetworkRequest=} [properties] Properties to set
     */
    function GetNetworkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworkRequest id.
     * @member {number} id
     * @memberof GetNetworkRequest
     * @instance
     */
    GetNetworkRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetNetworkRequest instance using the specified properties.
     * @function create
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest=} [properties] Properties to set
     * @returns {GetNetworkRequest} GetNetworkRequest instance
     */
    GetNetworkRequest.create = function create(properties) {
        return new GetNetworkRequest(properties);
    };

    /**
     * Encodes the specified GetNetworkRequest message. Does not implicitly {@link GetNetworkRequest.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest} message GetNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetNetworkRequest message, length delimited. Does not implicitly {@link GetNetworkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkRequest
     * @static
     * @param {IGetNetworkRequest} message GetNetworkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkRequest} GetNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkRequest} GetNetworkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkRequest message.
     * @function verify
     * @memberof GetNetworkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetNetworkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkRequest} GetNetworkRequest
     */
    GetNetworkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkRequest)
            return object;
        let message = new $root.GetNetworkRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetNetworkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkRequest
     * @static
     * @param {GetNetworkRequest} message GetNetworkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetNetworkRequest to JSON.
     * @function toJSON
     * @memberof GetNetworkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkRequest;
})();

export const GetNetworkResponse = $root.GetNetworkResponse = (() => {

    /**
     * Properties of a GetNetworkResponse.
     * @exports IGetNetworkResponse
     * @interface IGetNetworkResponse
     * @property {INetwork|null} [network] GetNetworkResponse network
     */

    /**
     * Constructs a new GetNetworkResponse.
     * @exports GetNetworkResponse
     * @classdesc Represents a GetNetworkResponse.
     * @implements IGetNetworkResponse
     * @constructor
     * @param {IGetNetworkResponse=} [properties] Properties to set
     */
    function GetNetworkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetNetworkResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof GetNetworkResponse
     * @instance
     */
    GetNetworkResponse.prototype.network = null;

    /**
     * Creates a new GetNetworkResponse instance using the specified properties.
     * @function create
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse=} [properties] Properties to set
     * @returns {GetNetworkResponse} GetNetworkResponse instance
     */
    GetNetworkResponse.create = function create(properties) {
        return new GetNetworkResponse(properties);
    };

    /**
     * Encodes the specified GetNetworkResponse message. Does not implicitly {@link GetNetworkResponse.verify|verify} messages.
     * @function encode
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse} message GetNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetNetworkResponse message, length delimited. Does not implicitly {@link GetNetworkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetNetworkResponse
     * @static
     * @param {IGetNetworkResponse} message GetNetworkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetNetworkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetNetworkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetNetworkResponse} GetNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetNetworkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetNetworkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetNetworkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetNetworkResponse} GetNetworkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetNetworkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetNetworkResponse message.
     * @function verify
     * @memberof GetNetworkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetNetworkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a GetNetworkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetNetworkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetNetworkResponse} GetNetworkResponse
     */
    GetNetworkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetNetworkResponse)
            return object;
        let message = new $root.GetNetworkResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".GetNetworkResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetNetworkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetNetworkResponse
     * @static
     * @param {GetNetworkResponse} message GetNetworkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetNetworkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this GetNetworkResponse to JSON.
     * @function toJSON
     * @memberof GetNetworkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetNetworkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetNetworkResponse;
})();

export const ListNetworksRequest = $root.ListNetworksRequest = (() => {

    /**
     * Properties of a ListNetworksRequest.
     * @exports IListNetworksRequest
     * @interface IListNetworksRequest
     */

    /**
     * Constructs a new ListNetworksRequest.
     * @exports ListNetworksRequest
     * @classdesc Represents a ListNetworksRequest.
     * @implements IListNetworksRequest
     * @constructor
     * @param {IListNetworksRequest=} [properties] Properties to set
     */
    function ListNetworksRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ListNetworksRequest instance using the specified properties.
     * @function create
     * @memberof ListNetworksRequest
     * @static
     * @param {IListNetworksRequest=} [properties] Properties to set
     * @returns {ListNetworksRequest} ListNetworksRequest instance
     */
    ListNetworksRequest.create = function create(properties) {
        return new ListNetworksRequest(properties);
    };

    /**
     * Encodes the specified ListNetworksRequest message. Does not implicitly {@link ListNetworksRequest.verify|verify} messages.
     * @function encode
     * @memberof ListNetworksRequest
     * @static
     * @param {IListNetworksRequest} message ListNetworksRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListNetworksRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ListNetworksRequest message, length delimited. Does not implicitly {@link ListNetworksRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListNetworksRequest
     * @static
     * @param {IListNetworksRequest} message ListNetworksRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListNetworksRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListNetworksRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ListNetworksRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListNetworksRequest} ListNetworksRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListNetworksRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListNetworksRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListNetworksRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListNetworksRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListNetworksRequest} ListNetworksRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListNetworksRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListNetworksRequest message.
     * @function verify
     * @memberof ListNetworksRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListNetworksRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ListNetworksRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListNetworksRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListNetworksRequest} ListNetworksRequest
     */
    ListNetworksRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ListNetworksRequest)
            return object;
        return new $root.ListNetworksRequest();
    };

    /**
     * Creates a plain object from a ListNetworksRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListNetworksRequest
     * @static
     * @param {ListNetworksRequest} message ListNetworksRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListNetworksRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ListNetworksRequest to JSON.
     * @function toJSON
     * @memberof ListNetworksRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListNetworksRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListNetworksRequest;
})();

export const ListNetworksResponse = $root.ListNetworksResponse = (() => {

    /**
     * Properties of a ListNetworksResponse.
     * @exports IListNetworksResponse
     * @interface IListNetworksResponse
     * @property {Array.<INetwork>|null} [networks] ListNetworksResponse networks
     */

    /**
     * Constructs a new ListNetworksResponse.
     * @exports ListNetworksResponse
     * @classdesc Represents a ListNetworksResponse.
     * @implements IListNetworksResponse
     * @constructor
     * @param {IListNetworksResponse=} [properties] Properties to set
     */
    function ListNetworksResponse(properties) {
        this.networks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListNetworksResponse networks.
     * @member {Array.<INetwork>} networks
     * @memberof ListNetworksResponse
     * @instance
     */
    ListNetworksResponse.prototype.networks = $util.emptyArray;

    /**
     * Creates a new ListNetworksResponse instance using the specified properties.
     * @function create
     * @memberof ListNetworksResponse
     * @static
     * @param {IListNetworksResponse=} [properties] Properties to set
     * @returns {ListNetworksResponse} ListNetworksResponse instance
     */
    ListNetworksResponse.create = function create(properties) {
        return new ListNetworksResponse(properties);
    };

    /**
     * Encodes the specified ListNetworksResponse message. Does not implicitly {@link ListNetworksResponse.verify|verify} messages.
     * @function encode
     * @memberof ListNetworksResponse
     * @static
     * @param {IListNetworksResponse} message ListNetworksResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListNetworksResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networks != null && message.networks.length)
            for (let i = 0; i < message.networks.length; ++i)
                $root.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListNetworksResponse message, length delimited. Does not implicitly {@link ListNetworksResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListNetworksResponse
     * @static
     * @param {IListNetworksResponse} message ListNetworksResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListNetworksResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListNetworksResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListNetworksResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListNetworksResponse} ListNetworksResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListNetworksResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListNetworksResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.networks && message.networks.length))
                    message.networks = [];
                message.networks.push($root.Network.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListNetworksResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListNetworksResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListNetworksResponse} ListNetworksResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListNetworksResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListNetworksResponse message.
     * @function verify
     * @memberof ListNetworksResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListNetworksResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networks != null && message.hasOwnProperty("networks")) {
            if (!Array.isArray(message.networks))
                return "networks: array expected";
            for (let i = 0; i < message.networks.length; ++i) {
                let error = $root.Network.verify(message.networks[i]);
                if (error)
                    return "networks." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListNetworksResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListNetworksResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListNetworksResponse} ListNetworksResponse
     */
    ListNetworksResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListNetworksResponse)
            return object;
        let message = new $root.ListNetworksResponse();
        if (object.networks) {
            if (!Array.isArray(object.networks))
                throw TypeError(".ListNetworksResponse.networks: array expected");
            message.networks = [];
            for (let i = 0; i < object.networks.length; ++i) {
                if (typeof object.networks[i] !== "object")
                    throw TypeError(".ListNetworksResponse.networks: object expected");
                message.networks[i] = $root.Network.fromObject(object.networks[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListNetworksResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListNetworksResponse
     * @static
     * @param {ListNetworksResponse} message ListNetworksResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListNetworksResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.networks = [];
        if (message.networks && message.networks.length) {
            object.networks = [];
            for (let j = 0; j < message.networks.length; ++j)
                object.networks[j] = $root.Network.toObject(message.networks[j], options);
        }
        return object;
    };

    /**
     * Converts this ListNetworksResponse to JSON.
     * @function toJSON
     * @memberof ListNetworksResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListNetworksResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListNetworksResponse;
})();

export const StorageKey = $root.StorageKey = (() => {

    /**
     * Properties of a StorageKey.
     * @exports IStorageKey
     * @interface IStorageKey
     * @property {KDFType|null} [kdfType] StorageKey kdfType
     * @property {StorageKey.IPBKDF2Options|null} [pbkdf2Options] StorageKey pbkdf2Options
     */

    /**
     * Constructs a new StorageKey.
     * @exports StorageKey
     * @classdesc Represents a StorageKey.
     * @implements IStorageKey
     * @constructor
     * @param {IStorageKey=} [properties] Properties to set
     */
    function StorageKey(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StorageKey kdfType.
     * @member {KDFType} kdfType
     * @memberof StorageKey
     * @instance
     */
    StorageKey.prototype.kdfType = 0;

    /**
     * StorageKey pbkdf2Options.
     * @member {StorageKey.IPBKDF2Options|null|undefined} pbkdf2Options
     * @memberof StorageKey
     * @instance
     */
    StorageKey.prototype.pbkdf2Options = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * StorageKey kdfOptions.
     * @member {"pbkdf2Options"|undefined} kdfOptions
     * @memberof StorageKey
     * @instance
     */
    Object.defineProperty(StorageKey.prototype, "kdfOptions", {
        get: $util.oneOfGetter($oneOfFields = ["pbkdf2Options"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new StorageKey instance using the specified properties.
     * @function create
     * @memberof StorageKey
     * @static
     * @param {IStorageKey=} [properties] Properties to set
     * @returns {StorageKey} StorageKey instance
     */
    StorageKey.create = function create(properties) {
        return new StorageKey(properties);
    };

    /**
     * Encodes the specified StorageKey message. Does not implicitly {@link StorageKey.verify|verify} messages.
     * @function encode
     * @memberof StorageKey
     * @static
     * @param {IStorageKey} message StorageKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StorageKey.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.kdfType != null && Object.hasOwnProperty.call(message, "kdfType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kdfType);
        if (message.pbkdf2Options != null && Object.hasOwnProperty.call(message, "pbkdf2Options"))
            $root.StorageKey.PBKDF2Options.encode(message.pbkdf2Options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified StorageKey message, length delimited. Does not implicitly {@link StorageKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StorageKey
     * @static
     * @param {IStorageKey} message StorageKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StorageKey.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StorageKey message from the specified reader or buffer.
     * @function decode
     * @memberof StorageKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StorageKey} StorageKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StorageKey.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StorageKey();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.kdfType = reader.int32();
                break;
            case 2:
                message.pbkdf2Options = $root.StorageKey.PBKDF2Options.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StorageKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StorageKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StorageKey} StorageKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StorageKey.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StorageKey message.
     * @function verify
     * @memberof StorageKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StorageKey.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.kdfType != null && message.hasOwnProperty("kdfType"))
            switch (message.kdfType) {
            default:
                return "kdfType: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.pbkdf2Options != null && message.hasOwnProperty("pbkdf2Options")) {
            properties.kdfOptions = 1;
            {
                let error = $root.StorageKey.PBKDF2Options.verify(message.pbkdf2Options);
                if (error)
                    return "pbkdf2Options." + error;
            }
        }
        return null;
    };

    /**
     * Creates a StorageKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StorageKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StorageKey} StorageKey
     */
    StorageKey.fromObject = function fromObject(object) {
        if (object instanceof $root.StorageKey)
            return object;
        let message = new $root.StorageKey();
        switch (object.kdfType) {
        case "KDF_TYPE_UNDEFINED":
        case 0:
            message.kdfType = 0;
            break;
        case "KDF_TYPE_PBKDF2_SHA256":
        case 1:
            message.kdfType = 1;
            break;
        }
        if (object.pbkdf2Options != null) {
            if (typeof object.pbkdf2Options !== "object")
                throw TypeError(".StorageKey.pbkdf2Options: object expected");
            message.pbkdf2Options = $root.StorageKey.PBKDF2Options.fromObject(object.pbkdf2Options);
        }
        return message;
    };

    /**
     * Creates a plain object from a StorageKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StorageKey
     * @static
     * @param {StorageKey} message StorageKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StorageKey.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.kdfType = options.enums === String ? "KDF_TYPE_UNDEFINED" : 0;
        if (message.kdfType != null && message.hasOwnProperty("kdfType"))
            object.kdfType = options.enums === String ? $root.KDFType[message.kdfType] : message.kdfType;
        if (message.pbkdf2Options != null && message.hasOwnProperty("pbkdf2Options")) {
            object.pbkdf2Options = $root.StorageKey.PBKDF2Options.toObject(message.pbkdf2Options, options);
            if (options.oneofs)
                object.kdfOptions = "pbkdf2Options";
        }
        return object;
    };

    /**
     * Converts this StorageKey to JSON.
     * @function toJSON
     * @memberof StorageKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StorageKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    StorageKey.PBKDF2Options = (function() {

        /**
         * Properties of a PBKDF2Options.
         * @memberof StorageKey
         * @interface IPBKDF2Options
         * @property {number|null} [iterations] PBKDF2Options iterations
         * @property {number|null} [keySize] PBKDF2Options keySize
         * @property {Uint8Array|null} [salt] PBKDF2Options salt
         */

        /**
         * Constructs a new PBKDF2Options.
         * @memberof StorageKey
         * @classdesc Represents a PBKDF2Options.
         * @implements IPBKDF2Options
         * @constructor
         * @param {StorageKey.IPBKDF2Options=} [properties] Properties to set
         */
        function PBKDF2Options(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PBKDF2Options iterations.
         * @member {number} iterations
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.iterations = 0;

        /**
         * PBKDF2Options keySize.
         * @member {number} keySize
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.keySize = 0;

        /**
         * PBKDF2Options salt.
         * @member {Uint8Array} salt
         * @memberof StorageKey.PBKDF2Options
         * @instance
         */
        PBKDF2Options.prototype.salt = $util.newBuffer([]);

        /**
         * Creates a new PBKDF2Options instance using the specified properties.
         * @function create
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options=} [properties] Properties to set
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options instance
         */
        PBKDF2Options.create = function create(properties) {
            return new PBKDF2Options(properties);
        };

        /**
         * Encodes the specified PBKDF2Options message. Does not implicitly {@link StorageKey.PBKDF2Options.verify|verify} messages.
         * @function encode
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options} message PBKDF2Options message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PBKDF2Options.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iterations != null && Object.hasOwnProperty.call(message, "iterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iterations);
            if (message.keySize != null && Object.hasOwnProperty.call(message, "keySize"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.keySize);
            if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
            return writer;
        };

        /**
         * Encodes the specified PBKDF2Options message, length delimited. Does not implicitly {@link StorageKey.PBKDF2Options.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.IPBKDF2Options} message PBKDF2Options message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PBKDF2Options.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PBKDF2Options message from the specified reader or buffer.
         * @function decode
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PBKDF2Options.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StorageKey.PBKDF2Options();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iterations = reader.uint32();
                    break;
                case 2:
                    message.keySize = reader.uint32();
                    break;
                case 3:
                    message.salt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PBKDF2Options message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PBKDF2Options.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PBKDF2Options message.
         * @function verify
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PBKDF2Options.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.keySize != null && message.hasOwnProperty("keySize"))
                if (!$util.isInteger(message.keySize))
                    return "keySize: integer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            return null;
        };

        /**
         * Creates a PBKDF2Options message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StorageKey.PBKDF2Options} PBKDF2Options
         */
        PBKDF2Options.fromObject = function fromObject(object) {
            if (object instanceof $root.StorageKey.PBKDF2Options)
                return object;
            let message = new $root.StorageKey.PBKDF2Options();
            if (object.iterations != null)
                message.iterations = object.iterations >>> 0;
            if (object.keySize != null)
                message.keySize = object.keySize >>> 0;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            return message;
        };

        /**
         * Creates a plain object from a PBKDF2Options message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StorageKey.PBKDF2Options
         * @static
         * @param {StorageKey.PBKDF2Options} message PBKDF2Options
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PBKDF2Options.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.iterations = 0;
                object.keySize = 0;
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
            }
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.keySize != null && message.hasOwnProperty("keySize"))
                object.keySize = message.keySize;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            return object;
        };

        /**
         * Converts this PBKDF2Options to JSON.
         * @function toJSON
         * @memberof StorageKey.PBKDF2Options
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PBKDF2Options.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PBKDF2Options;
    })();

    return StorageKey;
})();

export const Key = $root.Key = (() => {

    /**
     * Properties of a Key.
     * @exports IKey
     * @interface IKey
     * @property {KeyType|null} [type] Key type
     * @property {Uint8Array|null} ["private"] Key private
     * @property {Uint8Array|null} ["public"] Key public
     */

    /**
     * Constructs a new Key.
     * @exports Key
     * @classdesc Represents a Key.
     * @implements IKey
     * @constructor
     * @param {IKey=} [properties] Properties to set
     */
    function Key(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Key type.
     * @member {KeyType} type
     * @memberof Key
     * @instance
     */
    Key.prototype.type = 0;

    /**
     * Key private.
     * @member {Uint8Array} private
     * @memberof Key
     * @instance
     */
    Key.prototype["private"] = $util.newBuffer([]);

    /**
     * Key public.
     * @member {Uint8Array} public
     * @memberof Key
     * @instance
     */
    Key.prototype["public"] = $util.newBuffer([]);

    /**
     * Creates a new Key instance using the specified properties.
     * @function create
     * @memberof Key
     * @static
     * @param {IKey=} [properties] Properties to set
     * @returns {Key} Key instance
     */
    Key.create = function create(properties) {
        return new Key(properties);
    };

    /**
     * Encodes the specified Key message. Does not implicitly {@link Key.verify|verify} messages.
     * @function encode
     * @memberof Key
     * @static
     * @param {IKey} message Key message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Key.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
        if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message["public"]);
        return writer;
    };

    /**
     * Encodes the specified Key message, length delimited. Does not implicitly {@link Key.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Key
     * @static
     * @param {IKey} message Key message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Key.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Key message from the specified reader or buffer.
     * @function decode
     * @memberof Key
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Key} Key
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Key.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Key();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message["private"] = reader.bytes();
                break;
            case 3:
                message["public"] = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Key message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Key
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Key} Key
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Key.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Key message.
     * @function verify
     * @memberof Key
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Key.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message["private"] != null && message.hasOwnProperty("private"))
            if (!(message["private"] && typeof message["private"].length === "number" || $util.isString(message["private"])))
                return "private: buffer expected";
        if (message["public"] != null && message.hasOwnProperty("public"))
            if (!(message["public"] && typeof message["public"].length === "number" || $util.isString(message["public"])))
                return "public: buffer expected";
        return null;
    };

    /**
     * Creates a Key message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Key
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Key} Key
     */
    Key.fromObject = function fromObject(object) {
        if (object instanceof $root.Key)
            return object;
        let message = new $root.Key();
        switch (object.type) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.type = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.type = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.type = 2;
            break;
        }
        if (object["private"] != null)
            if (typeof object["private"] === "string")
                $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
            else if (object["private"].length)
                message["private"] = object["private"];
        if (object["public"] != null)
            if (typeof object["public"] === "string")
                $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
            else if (object["public"].length)
                message["public"] = object["public"];
        return message;
    };

    /**
     * Creates a plain object from a Key message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Key
     * @static
     * @param {Key} message Key
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Key.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            if (options.bytes === String)
                object["private"] = "";
            else {
                object["private"] = [];
                if (options.bytes !== Array)
                    object["private"] = $util.newBuffer(object["private"]);
            }
            if (options.bytes === String)
                object["public"] = "";
            else {
                object["public"] = [];
                if (options.bytes !== Array)
                    object["public"] = $util.newBuffer(object["public"]);
            }
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.KeyType[message.type] : message.type;
        if (message["private"] != null && message.hasOwnProperty("private"))
            object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
        if (message["public"] != null && message.hasOwnProperty("public"))
            object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
        return object;
    };

    /**
     * Converts this Key to JSON.
     * @function toJSON
     * @memberof Key
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Key.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Key;
})();

export const CertificateRequest = $root.CertificateRequest = (() => {

    /**
     * Properties of a CertificateRequest.
     * @exports ICertificateRequest
     * @interface ICertificateRequest
     * @property {Uint8Array|null} [key] CertificateRequest key
     * @property {KeyType|null} [keyType] CertificateRequest keyType
     * @property {number|null} [keyUsage] CertificateRequest keyUsage
     * @property {string|null} [subject] CertificateRequest subject
     * @property {Uint8Array|null} [signature] CertificateRequest signature
     */

    /**
     * Constructs a new CertificateRequest.
     * @exports CertificateRequest
     * @classdesc Represents a CertificateRequest.
     * @implements ICertificateRequest
     * @constructor
     * @param {ICertificateRequest=} [properties] Properties to set
     */
    function CertificateRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CertificateRequest key.
     * @member {Uint8Array} key
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.key = $util.newBuffer([]);

    /**
     * CertificateRequest keyType.
     * @member {KeyType} keyType
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.keyType = 0;

    /**
     * CertificateRequest keyUsage.
     * @member {number} keyUsage
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.keyUsage = 0;

    /**
     * CertificateRequest subject.
     * @member {string} subject
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.subject = "";

    /**
     * CertificateRequest signature.
     * @member {Uint8Array} signature
     * @memberof CertificateRequest
     * @instance
     */
    CertificateRequest.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new CertificateRequest instance using the specified properties.
     * @function create
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest=} [properties] Properties to set
     * @returns {CertificateRequest} CertificateRequest instance
     */
    CertificateRequest.create = function create(properties) {
        return new CertificateRequest(properties);
    };

    /**
     * Encodes the specified CertificateRequest message. Does not implicitly {@link CertificateRequest.verify|verify} messages.
     * @function encode
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest} message CertificateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyType);
        if (message.keyUsage != null && Object.hasOwnProperty.call(message, "keyUsage"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.keyUsage);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
        if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.subject);
        return writer;
    };

    /**
     * Encodes the specified CertificateRequest message, length delimited. Does not implicitly {@link CertificateRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CertificateRequest
     * @static
     * @param {ICertificateRequest} message CertificateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CertificateRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CertificateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CertificateRequest} CertificateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CertificateRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.keyType = reader.int32();
                break;
            case 3:
                message.keyUsage = reader.uint32();
                break;
            case 5:
                message.subject = reader.string();
                break;
            case 4:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CertificateRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CertificateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CertificateRequest} CertificateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CertificateRequest message.
     * @function verify
     * @memberof CertificateRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CertificateRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            switch (message.keyType) {
            default:
                return "keyType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            if (!$util.isInteger(message.keyUsage))
                return "keyUsage: integer expected";
        if (message.subject != null && message.hasOwnProperty("subject"))
            if (!$util.isString(message.subject))
                return "subject: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a CertificateRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CertificateRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CertificateRequest} CertificateRequest
     */
    CertificateRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CertificateRequest)
            return object;
        let message = new $root.CertificateRequest();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        switch (object.keyType) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.keyType = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.keyType = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.keyType = 2;
            break;
        }
        if (object.keyUsage != null)
            message.keyUsage = object.keyUsage >>> 0;
        if (object.subject != null)
            message.subject = String(object.subject);
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a CertificateRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CertificateRequest
     * @static
     * @param {CertificateRequest} message CertificateRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CertificateRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.keyType = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            object.keyUsage = 0;
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
            object.subject = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            object.keyType = options.enums === String ? $root.KeyType[message.keyType] : message.keyType;
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            object.keyUsage = message.keyUsage;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        if (message.subject != null && message.hasOwnProperty("subject"))
            object.subject = message.subject;
        return object;
    };

    /**
     * Converts this CertificateRequest to JSON.
     * @function toJSON
     * @memberof CertificateRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CertificateRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CertificateRequest;
})();

export const Certificate = $root.Certificate = (() => {

    /**
     * Properties of a Certificate.
     * @exports ICertificate
     * @interface ICertificate
     * @property {Uint8Array|null} [key] Certificate key
     * @property {KeyType|null} [keyType] Certificate keyType
     * @property {number|null} [keyUsage] Certificate keyUsage
     * @property {string|null} [subject] Certificate subject
     * @property {number|null} [notBefore] Certificate notBefore
     * @property {number|null} [notAfter] Certificate notAfter
     * @property {Uint8Array|null} [serialNumber] Certificate serialNumber
     * @property {Uint8Array|null} [signature] Certificate signature
     * @property {ICertificate|null} [parent] Certificate parent
     */

    /**
     * Constructs a new Certificate.
     * @exports Certificate
     * @classdesc Represents a Certificate.
     * @implements ICertificate
     * @constructor
     * @param {ICertificate=} [properties] Properties to set
     */
    function Certificate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Certificate key.
     * @member {Uint8Array} key
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.key = $util.newBuffer([]);

    /**
     * Certificate keyType.
     * @member {KeyType} keyType
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.keyType = 0;

    /**
     * Certificate keyUsage.
     * @member {number} keyUsage
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.keyUsage = 0;

    /**
     * Certificate subject.
     * @member {string} subject
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.subject = "";

    /**
     * Certificate notBefore.
     * @member {number} notBefore
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.notBefore = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Certificate notAfter.
     * @member {number} notAfter
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.notAfter = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Certificate serialNumber.
     * @member {Uint8Array} serialNumber
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.serialNumber = $util.newBuffer([]);

    /**
     * Certificate signature.
     * @member {Uint8Array} signature
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.signature = $util.newBuffer([]);

    /**
     * Certificate parent.
     * @member {ICertificate|null|undefined} parent
     * @memberof Certificate
     * @instance
     */
    Certificate.prototype.parent = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * Certificate parentOneof.
     * @member {"parent"|undefined} parentOneof
     * @memberof Certificate
     * @instance
     */
    Object.defineProperty(Certificate.prototype, "parentOneof", {
        get: $util.oneOfGetter($oneOfFields = ["parent"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new Certificate instance using the specified properties.
     * @function create
     * @memberof Certificate
     * @static
     * @param {ICertificate=} [properties] Properties to set
     * @returns {Certificate} Certificate instance
     */
    Certificate.create = function create(properties) {
        return new Certificate(properties);
    };

    /**
     * Encodes the specified Certificate message. Does not implicitly {@link Certificate.verify|verify} messages.
     * @function encode
     * @memberof Certificate
     * @static
     * @param {ICertificate} message Certificate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Certificate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
        if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyType);
        if (message.keyUsage != null && Object.hasOwnProperty.call(message, "keyUsage"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.keyUsage);
        if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.subject);
        if (message.notBefore != null && Object.hasOwnProperty.call(message, "notBefore"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.notBefore);
        if (message.notAfter != null && Object.hasOwnProperty.call(message, "notAfter"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.notAfter);
        if (message.serialNumber != null && Object.hasOwnProperty.call(message, "serialNumber"))
            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.serialNumber);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.signature);
        if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
            $root.Certificate.encode(message.parent, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Certificate message, length delimited. Does not implicitly {@link Certificate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Certificate
     * @static
     * @param {ICertificate} message Certificate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Certificate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Certificate message from the specified reader or buffer.
     * @function decode
     * @memberof Certificate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Certificate} Certificate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Certificate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Certificate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.bytes();
                break;
            case 2:
                message.keyType = reader.int32();
                break;
            case 3:
                message.keyUsage = reader.uint32();
                break;
            case 4:
                message.subject = reader.string();
                break;
            case 5:
                message.notBefore = reader.uint64();
                break;
            case 6:
                message.notAfter = reader.uint64();
                break;
            case 7:
                message.serialNumber = reader.bytes();
                break;
            case 8:
                message.signature = reader.bytes();
                break;
            case 9:
                message.parent = $root.Certificate.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Certificate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Certificate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Certificate} Certificate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Certificate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Certificate message.
     * @function verify
     * @memberof Certificate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Certificate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.key != null && message.hasOwnProperty("key"))
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            switch (message.keyType) {
            default:
                return "keyType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            if (!$util.isInteger(message.keyUsage))
                return "keyUsage: integer expected";
        if (message.subject != null && message.hasOwnProperty("subject"))
            if (!$util.isString(message.subject))
                return "subject: string expected";
        if (message.notBefore != null && message.hasOwnProperty("notBefore"))
            if (!$util.isInteger(message.notBefore) && !(message.notBefore && $util.isInteger(message.notBefore.low) && $util.isInteger(message.notBefore.high)))
                return "notBefore: integer|Long expected";
        if (message.notAfter != null && message.hasOwnProperty("notAfter"))
            if (!$util.isInteger(message.notAfter) && !(message.notAfter && $util.isInteger(message.notAfter.low) && $util.isInteger(message.notAfter.high)))
                return "notAfter: integer|Long expected";
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            if (!(message.serialNumber && typeof message.serialNumber.length === "number" || $util.isString(message.serialNumber)))
                return "serialNumber: buffer expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        if (message.parent != null && message.hasOwnProperty("parent")) {
            properties.parentOneof = 1;
            {
                let error = $root.Certificate.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Certificate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Certificate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Certificate} Certificate
     */
    Certificate.fromObject = function fromObject(object) {
        if (object instanceof $root.Certificate)
            return object;
        let message = new $root.Certificate();
        if (object.key != null)
            if (typeof object.key === "string")
                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
                message.key = object.key;
        switch (object.keyType) {
        case "KEY_TYPE_UNDEFINED":
        case 0:
            message.keyType = 0;
            break;
        case "KEY_TYPE_ED25519":
        case 1:
            message.keyType = 1;
            break;
        case "KEY_TYPE_X25519":
        case 2:
            message.keyType = 2;
            break;
        }
        if (object.keyUsage != null)
            message.keyUsage = object.keyUsage >>> 0;
        if (object.subject != null)
            message.subject = String(object.subject);
        if (object.notBefore != null)
            if ($util.Long)
                (message.notBefore = $util.Long.fromValue(object.notBefore)).unsigned = true;
            else if (typeof object.notBefore === "string")
                message.notBefore = parseInt(object.notBefore, 10);
            else if (typeof object.notBefore === "number")
                message.notBefore = object.notBefore;
            else if (typeof object.notBefore === "object")
                message.notBefore = new $util.LongBits(object.notBefore.low >>> 0, object.notBefore.high >>> 0).toNumber(true);
        if (object.notAfter != null)
            if ($util.Long)
                (message.notAfter = $util.Long.fromValue(object.notAfter)).unsigned = true;
            else if (typeof object.notAfter === "string")
                message.notAfter = parseInt(object.notAfter, 10);
            else if (typeof object.notAfter === "number")
                message.notAfter = object.notAfter;
            else if (typeof object.notAfter === "object")
                message.notAfter = new $util.LongBits(object.notAfter.low >>> 0, object.notAfter.high >>> 0).toNumber(true);
        if (object.serialNumber != null)
            if (typeof object.serialNumber === "string")
                $util.base64.decode(object.serialNumber, message.serialNumber = $util.newBuffer($util.base64.length(object.serialNumber)), 0);
            else if (object.serialNumber.length)
                message.serialNumber = object.serialNumber;
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        if (object.parent != null) {
            if (typeof object.parent !== "object")
                throw TypeError(".Certificate.parent: object expected");
            message.parent = $root.Certificate.fromObject(object.parent);
        }
        return message;
    };

    /**
     * Creates a plain object from a Certificate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Certificate
     * @static
     * @param {Certificate} message Certificate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Certificate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.key = "";
            else {
                object.key = [];
                if (options.bytes !== Array)
                    object.key = $util.newBuffer(object.key);
            }
            object.keyType = options.enums === String ? "KEY_TYPE_UNDEFINED" : 0;
            object.keyUsage = 0;
            object.subject = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.notBefore = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.notBefore = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.notAfter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.notAfter = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.serialNumber = "";
            else {
                object.serialNumber = [];
                if (options.bytes !== Array)
                    object.serialNumber = $util.newBuffer(object.serialNumber);
            }
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
        if (message.keyType != null && message.hasOwnProperty("keyType"))
            object.keyType = options.enums === String ? $root.KeyType[message.keyType] : message.keyType;
        if (message.keyUsage != null && message.hasOwnProperty("keyUsage"))
            object.keyUsage = message.keyUsage;
        if (message.subject != null && message.hasOwnProperty("subject"))
            object.subject = message.subject;
        if (message.notBefore != null && message.hasOwnProperty("notBefore"))
            if (typeof message.notBefore === "number")
                object.notBefore = options.longs === String ? String(message.notBefore) : message.notBefore;
            else
                object.notBefore = options.longs === String ? $util.Long.prototype.toString.call(message.notBefore) : options.longs === Number ? new $util.LongBits(message.notBefore.low >>> 0, message.notBefore.high >>> 0).toNumber(true) : message.notBefore;
        if (message.notAfter != null && message.hasOwnProperty("notAfter"))
            if (typeof message.notAfter === "number")
                object.notAfter = options.longs === String ? String(message.notAfter) : message.notAfter;
            else
                object.notAfter = options.longs === String ? $util.Long.prototype.toString.call(message.notAfter) : options.longs === Number ? new $util.LongBits(message.notAfter.low >>> 0, message.notAfter.high >>> 0).toNumber(true) : message.notAfter;
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            object.serialNumber = options.bytes === String ? $util.base64.encode(message.serialNumber, 0, message.serialNumber.length) : options.bytes === Array ? Array.prototype.slice.call(message.serialNumber) : message.serialNumber;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        if (message.parent != null && message.hasOwnProperty("parent")) {
            object.parent = $root.Certificate.toObject(message.parent, options);
            if (options.oneofs)
                object.parentOneof = "parent";
        }
        return object;
    };

    /**
     * Converts this Certificate to JSON.
     * @function toJSON
     * @memberof Certificate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Certificate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Certificate;
})();

export const Profile = $root.Profile = (() => {

    /**
     * Properties of a Profile.
     * @exports IProfile
     * @interface IProfile
     * @property {number|null} [id] Profile id
     * @property {string|null} [name] Profile name
     * @property {Uint8Array|null} [secret] Profile secret
     * @property {IKey|null} [key] Profile key
     * @property {Array.<INetwork>|null} [networks] Profile networks
     */

    /**
     * Constructs a new Profile.
     * @exports Profile
     * @classdesc Represents a Profile.
     * @implements IProfile
     * @constructor
     * @param {IProfile=} [properties] Properties to set
     */
    function Profile(properties) {
        this.networks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Profile id.
     * @member {number} id
     * @memberof Profile
     * @instance
     */
    Profile.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Profile name.
     * @member {string} name
     * @memberof Profile
     * @instance
     */
    Profile.prototype.name = "";

    /**
     * Profile secret.
     * @member {Uint8Array} secret
     * @memberof Profile
     * @instance
     */
    Profile.prototype.secret = $util.newBuffer([]);

    /**
     * Profile key.
     * @member {IKey|null|undefined} key
     * @memberof Profile
     * @instance
     */
    Profile.prototype.key = null;

    /**
     * Profile networks.
     * @member {Array.<INetwork>} networks
     * @memberof Profile
     * @instance
     */
    Profile.prototype.networks = $util.emptyArray;

    /**
     * Creates a new Profile instance using the specified properties.
     * @function create
     * @memberof Profile
     * @static
     * @param {IProfile=} [properties] Properties to set
     * @returns {Profile} Profile instance
     */
    Profile.create = function create(properties) {
        return new Profile(properties);
    };

    /**
     * Encodes the specified Profile message. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encode
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.secret);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.networks != null && message.networks.length)
            for (let i = 0; i < message.networks.length; ++i)
                $root.Network.encode(message.networks[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Profile message, length delimited. Does not implicitly {@link Profile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Profile
     * @static
     * @param {IProfile} message Profile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Profile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Profile message from the specified reader or buffer.
     * @function decode
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Profile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.secret = reader.bytes();
                break;
            case 4:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 5:
                if (!(message.networks && message.networks.length))
                    message.networks = [];
                message.networks.push($root.Network.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Profile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Profile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Profile} Profile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Profile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Profile message.
     * @function verify
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Profile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.secret != null && message.hasOwnProperty("secret"))
            if (!(message.secret && typeof message.secret.length === "number" || $util.isString(message.secret)))
                return "secret: buffer expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.networks != null && message.hasOwnProperty("networks")) {
            if (!Array.isArray(message.networks))
                return "networks: array expected";
            for (let i = 0; i < message.networks.length; ++i) {
                let error = $root.Network.verify(message.networks[i]);
                if (error)
                    return "networks." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Profile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Profile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Profile} Profile
     */
    Profile.fromObject = function fromObject(object) {
        if (object instanceof $root.Profile)
            return object;
        let message = new $root.Profile();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.secret != null)
            if (typeof object.secret === "string")
                $util.base64.decode(object.secret, message.secret = $util.newBuffer($util.base64.length(object.secret)), 0);
            else if (object.secret.length)
                message.secret = object.secret;
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".Profile.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.networks) {
            if (!Array.isArray(object.networks))
                throw TypeError(".Profile.networks: array expected");
            message.networks = [];
            for (let i = 0; i < object.networks.length; ++i) {
                if (typeof object.networks[i] !== "object")
                    throw TypeError(".Profile.networks: object expected");
                message.networks[i] = $root.Network.fromObject(object.networks[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a Profile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Profile
     * @static
     * @param {Profile} message Profile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Profile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.networks = [];
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            if (options.bytes === String)
                object.secret = "";
            else {
                object.secret = [];
                if (options.bytes !== Array)
                    object.secret = $util.newBuffer(object.secret);
            }
            object.key = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.secret != null && message.hasOwnProperty("secret"))
            object.secret = options.bytes === String ? $util.base64.encode(message.secret, 0, message.secret.length) : options.bytes === Array ? Array.prototype.slice.call(message.secret) : message.secret;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.networks && message.networks.length) {
            object.networks = [];
            for (let j = 0; j < message.networks.length; ++j)
                object.networks[j] = $root.Network.toObject(message.networks[j], options);
        }
        return object;
    };

    /**
     * Converts this Profile to JSON.
     * @function toJSON
     * @memberof Profile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Profile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Profile;
})();

export const ProfileSummary = $root.ProfileSummary = (() => {

    /**
     * Properties of a ProfileSummary.
     * @exports IProfileSummary
     * @interface IProfileSummary
     * @property {number|null} [id] ProfileSummary id
     * @property {string|null} [name] ProfileSummary name
     */

    /**
     * Constructs a new ProfileSummary.
     * @exports ProfileSummary
     * @classdesc Represents a ProfileSummary.
     * @implements IProfileSummary
     * @constructor
     * @param {IProfileSummary=} [properties] Properties to set
     */
    function ProfileSummary(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ProfileSummary id.
     * @member {number} id
     * @memberof ProfileSummary
     * @instance
     */
    ProfileSummary.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ProfileSummary name.
     * @member {string} name
     * @memberof ProfileSummary
     * @instance
     */
    ProfileSummary.prototype.name = "";

    /**
     * Creates a new ProfileSummary instance using the specified properties.
     * @function create
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary=} [properties] Properties to set
     * @returns {ProfileSummary} ProfileSummary instance
     */
    ProfileSummary.create = function create(properties) {
        return new ProfileSummary(properties);
    };

    /**
     * Encodes the specified ProfileSummary message. Does not implicitly {@link ProfileSummary.verify|verify} messages.
     * @function encode
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary} message ProfileSummary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileSummary.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified ProfileSummary message, length delimited. Does not implicitly {@link ProfileSummary.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ProfileSummary
     * @static
     * @param {IProfileSummary} message ProfileSummary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ProfileSummary.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ProfileSummary message from the specified reader or buffer.
     * @function decode
     * @memberof ProfileSummary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ProfileSummary} ProfileSummary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileSummary.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProfileSummary();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ProfileSummary message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ProfileSummary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ProfileSummary} ProfileSummary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ProfileSummary.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ProfileSummary message.
     * @function verify
     * @memberof ProfileSummary
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ProfileSummary.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates a ProfileSummary message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ProfileSummary
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ProfileSummary} ProfileSummary
     */
    ProfileSummary.fromObject = function fromObject(object) {
        if (object instanceof $root.ProfileSummary)
            return object;
        let message = new $root.ProfileSummary();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from a ProfileSummary message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ProfileSummary
     * @static
     * @param {ProfileSummary} message ProfileSummary
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ProfileSummary.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this ProfileSummary to JSON.
     * @function toJSON
     * @memberof ProfileSummary
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ProfileSummary.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ProfileSummary;
})();

export const Network = $root.Network = (() => {

    /**
     * Properties of a Network.
     * @exports INetwork
     * @interface INetwork
     * @property {number|null} [id] Network id
     * @property {string|null} [name] Network name
     * @property {IKey|null} [key] Network key
     * @property {ICertificate|null} [certificate] Network certificate
     * @property {INetworkIcon|null} [icon] Network icon
     */

    /**
     * Constructs a new Network.
     * @exports Network
     * @classdesc Represents a Network.
     * @implements INetwork
     * @constructor
     * @param {INetwork=} [properties] Properties to set
     */
    function Network(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Network id.
     * @member {number} id
     * @memberof Network
     * @instance
     */
    Network.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Network name.
     * @member {string} name
     * @memberof Network
     * @instance
     */
    Network.prototype.name = "";

    /**
     * Network key.
     * @member {IKey|null|undefined} key
     * @memberof Network
     * @instance
     */
    Network.prototype.key = null;

    /**
     * Network certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof Network
     * @instance
     */
    Network.prototype.certificate = null;

    /**
     * Network icon.
     * @member {INetworkIcon|null|undefined} icon
     * @memberof Network
     * @instance
     */
    Network.prototype.icon = null;

    /**
     * Creates a new Network instance using the specified properties.
     * @function create
     * @memberof Network
     * @static
     * @param {INetwork=} [properties] Properties to set
     * @returns {Network} Network instance
     */
    Network.create = function create(properties) {
        return new Network(properties);
    };

    /**
     * Encodes the specified Network message. Does not implicitly {@link Network.verify|verify} messages.
     * @function encode
     * @memberof Network
     * @static
     * @param {INetwork} message Network message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Network.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            $root.NetworkIcon.encode(message.icon, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Network message, length delimited. Does not implicitly {@link Network.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Network
     * @static
     * @param {INetwork} message Network message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Network.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Network message from the specified reader or buffer.
     * @function decode
     * @memberof Network
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Network} Network
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Network.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Network();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 4:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 5:
                message.icon = $root.NetworkIcon.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Network message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Network
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Network} Network
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Network.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Network message.
     * @function verify
     * @memberof Network
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Network.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.icon != null && message.hasOwnProperty("icon")) {
            let error = $root.NetworkIcon.verify(message.icon);
            if (error)
                return "icon." + error;
        }
        return null;
    };

    /**
     * Creates a Network message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Network
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Network} Network
     */
    Network.fromObject = function fromObject(object) {
        if (object instanceof $root.Network)
            return object;
        let message = new $root.Network();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".Network.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".Network.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.icon != null) {
            if (typeof object.icon !== "object")
                throw TypeError(".Network.icon: object expected");
            message.icon = $root.NetworkIcon.fromObject(object.icon);
        }
        return message;
    };

    /**
     * Creates a plain object from a Network message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Network
     * @static
     * @param {Network} message Network
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Network.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.name = "";
            object.key = null;
            object.certificate = null;
            object.icon = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = $root.NetworkIcon.toObject(message.icon, options);
        return object;
    };

    /**
     * Converts this Network to JSON.
     * @function toJSON
     * @memberof Network
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Network.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Network;
})();

export const NetworkMembership = $root.NetworkMembership = (() => {

    /**
     * Properties of a NetworkMembership.
     * @exports INetworkMembership
     * @interface INetworkMembership
     * @property {number|null} [id] NetworkMembership id
     * @property {number|null} [createdAt] NetworkMembership createdAt
     * @property {string|null} [name] NetworkMembership name
     * @property {ICertificate|null} [caCertificate] NetworkMembership caCertificate
     * @property {ICertificate|null} [certificate] NetworkMembership certificate
     * @property {number|null} [lastSeenAt] NetworkMembership lastSeenAt
     */

    /**
     * Constructs a new NetworkMembership.
     * @exports NetworkMembership
     * @classdesc Represents a NetworkMembership.
     * @implements INetworkMembership
     * @constructor
     * @param {INetworkMembership=} [properties] Properties to set
     */
    function NetworkMembership(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkMembership id.
     * @member {number} id
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NetworkMembership createdAt.
     * @member {number} createdAt
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * NetworkMembership name.
     * @member {string} name
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.name = "";

    /**
     * NetworkMembership caCertificate.
     * @member {ICertificate|null|undefined} caCertificate
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.caCertificate = null;

    /**
     * NetworkMembership certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.certificate = null;

    /**
     * NetworkMembership lastSeenAt.
     * @member {number} lastSeenAt
     * @memberof NetworkMembership
     * @instance
     */
    NetworkMembership.prototype.lastSeenAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new NetworkMembership instance using the specified properties.
     * @function create
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership=} [properties] Properties to set
     * @returns {NetworkMembership} NetworkMembership instance
     */
    NetworkMembership.create = function create(properties) {
        return new NetworkMembership(properties);
    };

    /**
     * Encodes the specified NetworkMembership message. Does not implicitly {@link NetworkMembership.verify|verify} messages.
     * @function encode
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership} message NetworkMembership message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkMembership.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.createdAt);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.caCertificate != null && Object.hasOwnProperty.call(message, "caCertificate"))
            $root.Certificate.encode(message.caCertificate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.lastSeenAt != null && Object.hasOwnProperty.call(message, "lastSeenAt"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.lastSeenAt);
        return writer;
    };

    /**
     * Encodes the specified NetworkMembership message, length delimited. Does not implicitly {@link NetworkMembership.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkMembership
     * @static
     * @param {INetworkMembership} message NetworkMembership message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkMembership.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkMembership message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkMembership
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkMembership} NetworkMembership
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkMembership.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkMembership();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.createdAt = reader.uint64();
                break;
            case 3:
                message.name = reader.string();
                break;
            case 4:
                message.caCertificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 5:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 6:
                message.lastSeenAt = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkMembership message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkMembership
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkMembership} NetworkMembership
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkMembership.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkMembership message.
     * @function verify
     * @memberof NetworkMembership
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkMembership.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.createdAt != null && message.hasOwnProperty("createdAt"))
            if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                return "createdAt: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.caCertificate != null && message.hasOwnProperty("caCertificate")) {
            let error = $root.Certificate.verify(message.caCertificate);
            if (error)
                return "caCertificate." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.lastSeenAt != null && message.hasOwnProperty("lastSeenAt"))
            if (!$util.isInteger(message.lastSeenAt) && !(message.lastSeenAt && $util.isInteger(message.lastSeenAt.low) && $util.isInteger(message.lastSeenAt.high)))
                return "lastSeenAt: integer|Long expected";
        return null;
    };

    /**
     * Creates a NetworkMembership message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkMembership
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkMembership} NetworkMembership
     */
    NetworkMembership.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkMembership)
            return object;
        let message = new $root.NetworkMembership();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.createdAt != null)
            if ($util.Long)
                (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = true;
            else if (typeof object.createdAt === "string")
                message.createdAt = parseInt(object.createdAt, 10);
            else if (typeof object.createdAt === "number")
                message.createdAt = object.createdAt;
            else if (typeof object.createdAt === "object")
                message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.caCertificate != null) {
            if (typeof object.caCertificate !== "object")
                throw TypeError(".NetworkMembership.caCertificate: object expected");
            message.caCertificate = $root.Certificate.fromObject(object.caCertificate);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".NetworkMembership.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.lastSeenAt != null)
            if ($util.Long)
                (message.lastSeenAt = $util.Long.fromValue(object.lastSeenAt)).unsigned = true;
            else if (typeof object.lastSeenAt === "string")
                message.lastSeenAt = parseInt(object.lastSeenAt, 10);
            else if (typeof object.lastSeenAt === "number")
                message.lastSeenAt = object.lastSeenAt;
            else if (typeof object.lastSeenAt === "object")
                message.lastSeenAt = new $util.LongBits(object.lastSeenAt.low >>> 0, object.lastSeenAt.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a NetworkMembership message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkMembership
     * @static
     * @param {NetworkMembership} message NetworkMembership
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkMembership.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.createdAt = options.longs === String ? "0" : 0;
            object.name = "";
            object.caCertificate = null;
            object.certificate = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastSeenAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastSeenAt = options.longs === String ? "0" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.createdAt != null && message.hasOwnProperty("createdAt"))
            if (typeof message.createdAt === "number")
                object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
            else
                object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber(true) : message.createdAt;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.caCertificate != null && message.hasOwnProperty("caCertificate"))
            object.caCertificate = $root.Certificate.toObject(message.caCertificate, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.lastSeenAt != null && message.hasOwnProperty("lastSeenAt"))
            if (typeof message.lastSeenAt === "number")
                object.lastSeenAt = options.longs === String ? String(message.lastSeenAt) : message.lastSeenAt;
            else
                object.lastSeenAt = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeenAt) : options.longs === Number ? new $util.LongBits(message.lastSeenAt.low >>> 0, message.lastSeenAt.high >>> 0).toNumber(true) : message.lastSeenAt;
        return object;
    };

    /**
     * Converts this NetworkMembership to JSON.
     * @function toJSON
     * @memberof NetworkMembership
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkMembership.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NetworkMembership;
})();

export const CreateNetworkInvitationRequest = $root.CreateNetworkInvitationRequest = (() => {

    /**
     * Properties of a CreateNetworkInvitationRequest.
     * @exports ICreateNetworkInvitationRequest
     * @interface ICreateNetworkInvitationRequest
     * @property {IKey|null} [signingKey] CreateNetworkInvitationRequest signingKey
     * @property {ICertificate|null} [signingCert] CreateNetworkInvitationRequest signingCert
     * @property {string|null} [networkName] CreateNetworkInvitationRequest networkName
     */

    /**
     * Constructs a new CreateNetworkInvitationRequest.
     * @exports CreateNetworkInvitationRequest
     * @classdesc Represents a CreateNetworkInvitationRequest.
     * @implements ICreateNetworkInvitationRequest
     * @constructor
     * @param {ICreateNetworkInvitationRequest=} [properties] Properties to set
     */
    function CreateNetworkInvitationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkInvitationRequest signingKey.
     * @member {IKey|null|undefined} signingKey
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.signingKey = null;

    /**
     * CreateNetworkInvitationRequest signingCert.
     * @member {ICertificate|null|undefined} signingCert
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.signingCert = null;

    /**
     * CreateNetworkInvitationRequest networkName.
     * @member {string} networkName
     * @memberof CreateNetworkInvitationRequest
     * @instance
     */
    CreateNetworkInvitationRequest.prototype.networkName = "";

    /**
     * Creates a new CreateNetworkInvitationRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest=} [properties] Properties to set
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest instance
     */
    CreateNetworkInvitationRequest.create = function create(properties) {
        return new CreateNetworkInvitationRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkInvitationRequest message. Does not implicitly {@link CreateNetworkInvitationRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest} message CreateNetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.signingKey != null && Object.hasOwnProperty.call(message, "signingKey"))
            $root.Key.encode(message.signingKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.signingCert != null && Object.hasOwnProperty.call(message, "signingCert"))
            $root.Certificate.encode(message.signingCert, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.networkName != null && Object.hasOwnProperty.call(message, "networkName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.networkName);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkInvitationRequest message, length delimited. Does not implicitly {@link CreateNetworkInvitationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {ICreateNetworkInvitationRequest} message CreateNetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkInvitationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkInvitationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.signingKey = $root.Key.decode(reader, reader.uint32());
                break;
            case 2:
                message.signingCert = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 3:
                message.networkName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkInvitationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkInvitationRequest message.
     * @function verify
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkInvitationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.signingKey != null && message.hasOwnProperty("signingKey")) {
            let error = $root.Key.verify(message.signingKey);
            if (error)
                return "signingKey." + error;
        }
        if (message.signingCert != null && message.hasOwnProperty("signingCert")) {
            let error = $root.Certificate.verify(message.signingCert);
            if (error)
                return "signingCert." + error;
        }
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            if (!$util.isString(message.networkName))
                return "networkName: string expected";
        return null;
    };

    /**
     * Creates a CreateNetworkInvitationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkInvitationRequest} CreateNetworkInvitationRequest
     */
    CreateNetworkInvitationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkInvitationRequest)
            return object;
        let message = new $root.CreateNetworkInvitationRequest();
        if (object.signingKey != null) {
            if (typeof object.signingKey !== "object")
                throw TypeError(".CreateNetworkInvitationRequest.signingKey: object expected");
            message.signingKey = $root.Key.fromObject(object.signingKey);
        }
        if (object.signingCert != null) {
            if (typeof object.signingCert !== "object")
                throw TypeError(".CreateNetworkInvitationRequest.signingCert: object expected");
            message.signingCert = $root.Certificate.fromObject(object.signingCert);
        }
        if (object.networkName != null)
            message.networkName = String(object.networkName);
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkInvitationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkInvitationRequest
     * @static
     * @param {CreateNetworkInvitationRequest} message CreateNetworkInvitationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkInvitationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.signingKey = null;
            object.signingCert = null;
            object.networkName = "";
        }
        if (message.signingKey != null && message.hasOwnProperty("signingKey"))
            object.signingKey = $root.Key.toObject(message.signingKey, options);
        if (message.signingCert != null && message.hasOwnProperty("signingCert"))
            object.signingCert = $root.Certificate.toObject(message.signingCert, options);
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            object.networkName = message.networkName;
        return object;
    };

    /**
     * Converts this CreateNetworkInvitationRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkInvitationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkInvitationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkInvitationRequest;
})();

export const CreateNetworkInvitationResponse = $root.CreateNetworkInvitationResponse = (() => {

    /**
     * Properties of a CreateNetworkInvitationResponse.
     * @exports ICreateNetworkInvitationResponse
     * @interface ICreateNetworkInvitationResponse
     * @property {IInvitation|null} [invitation] CreateNetworkInvitationResponse invitation
     * @property {string|null} [invitationB64] CreateNetworkInvitationResponse invitationB64
     * @property {Uint8Array|null} [invitationBytes] CreateNetworkInvitationResponse invitationBytes
     */

    /**
     * Constructs a new CreateNetworkInvitationResponse.
     * @exports CreateNetworkInvitationResponse
     * @classdesc Represents a CreateNetworkInvitationResponse.
     * @implements ICreateNetworkInvitationResponse
     * @constructor
     * @param {ICreateNetworkInvitationResponse=} [properties] Properties to set
     */
    function CreateNetworkInvitationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkInvitationResponse invitation.
     * @member {IInvitation|null|undefined} invitation
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitation = null;

    /**
     * CreateNetworkInvitationResponse invitationB64.
     * @member {string} invitationB64
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitationB64 = "";

    /**
     * CreateNetworkInvitationResponse invitationBytes.
     * @member {Uint8Array} invitationBytes
     * @memberof CreateNetworkInvitationResponse
     * @instance
     */
    CreateNetworkInvitationResponse.prototype.invitationBytes = $util.newBuffer([]);

    /**
     * Creates a new CreateNetworkInvitationResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse=} [properties] Properties to set
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse instance
     */
    CreateNetworkInvitationResponse.create = function create(properties) {
        return new CreateNetworkInvitationResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkInvitationResponse message. Does not implicitly {@link CreateNetworkInvitationResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse} message CreateNetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.invitation != null && Object.hasOwnProperty.call(message, "invitation"))
            $root.Invitation.encode(message.invitation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.invitationB64 != null && Object.hasOwnProperty.call(message, "invitationB64"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.invitationB64);
        if (message.invitationBytes != null && Object.hasOwnProperty.call(message, "invitationBytes"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.invitationBytes);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkInvitationResponse message, length delimited. Does not implicitly {@link CreateNetworkInvitationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {ICreateNetworkInvitationResponse} message CreateNetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkInvitationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkInvitationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkInvitationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.invitation = $root.Invitation.decode(reader, reader.uint32());
                break;
            case 2:
                message.invitationB64 = reader.string();
                break;
            case 3:
                message.invitationBytes = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkInvitationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkInvitationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkInvitationResponse message.
     * @function verify
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkInvitationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.invitation != null && message.hasOwnProperty("invitation")) {
            let error = $root.Invitation.verify(message.invitation);
            if (error)
                return "invitation." + error;
        }
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64"))
            if (!$util.isString(message.invitationB64))
                return "invitationB64: string expected";
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes"))
            if (!(message.invitationBytes && typeof message.invitationBytes.length === "number" || $util.isString(message.invitationBytes)))
                return "invitationBytes: buffer expected";
        return null;
    };

    /**
     * Creates a CreateNetworkInvitationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkInvitationResponse} CreateNetworkInvitationResponse
     */
    CreateNetworkInvitationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkInvitationResponse)
            return object;
        let message = new $root.CreateNetworkInvitationResponse();
        if (object.invitation != null) {
            if (typeof object.invitation !== "object")
                throw TypeError(".CreateNetworkInvitationResponse.invitation: object expected");
            message.invitation = $root.Invitation.fromObject(object.invitation);
        }
        if (object.invitationB64 != null)
            message.invitationB64 = String(object.invitationB64);
        if (object.invitationBytes != null)
            if (typeof object.invitationBytes === "string")
                $util.base64.decode(object.invitationBytes, message.invitationBytes = $util.newBuffer($util.base64.length(object.invitationBytes)), 0);
            else if (object.invitationBytes.length)
                message.invitationBytes = object.invitationBytes;
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkInvitationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkInvitationResponse
     * @static
     * @param {CreateNetworkInvitationResponse} message CreateNetworkInvitationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkInvitationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.invitation = null;
            object.invitationB64 = "";
            if (options.bytes === String)
                object.invitationBytes = "";
            else {
                object.invitationBytes = [];
                if (options.bytes !== Array)
                    object.invitationBytes = $util.newBuffer(object.invitationBytes);
            }
        }
        if (message.invitation != null && message.hasOwnProperty("invitation"))
            object.invitation = $root.Invitation.toObject(message.invitation, options);
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64"))
            object.invitationB64 = message.invitationB64;
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes"))
            object.invitationBytes = options.bytes === String ? $util.base64.encode(message.invitationBytes, 0, message.invitationBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.invitationBytes) : message.invitationBytes;
        return object;
    };

    /**
     * Converts this CreateNetworkInvitationResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkInvitationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkInvitationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkInvitationResponse;
})();

export const Invitation = $root.Invitation = (() => {

    /**
     * Properties of an Invitation.
     * @exports IInvitation
     * @interface IInvitation
     * @property {number|null} [version] Invitation version
     * @property {Uint8Array|null} [data] Invitation data
     */

    /**
     * Constructs a new Invitation.
     * @exports Invitation
     * @classdesc Represents an Invitation.
     * @implements IInvitation
     * @constructor
     * @param {IInvitation=} [properties] Properties to set
     */
    function Invitation(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Invitation version.
     * @member {number} version
     * @memberof Invitation
     * @instance
     */
    Invitation.prototype.version = 0;

    /**
     * Invitation data.
     * @member {Uint8Array} data
     * @memberof Invitation
     * @instance
     */
    Invitation.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new Invitation instance using the specified properties.
     * @function create
     * @memberof Invitation
     * @static
     * @param {IInvitation=} [properties] Properties to set
     * @returns {Invitation} Invitation instance
     */
    Invitation.create = function create(properties) {
        return new Invitation(properties);
    };

    /**
     * Encodes the specified Invitation message. Does not implicitly {@link Invitation.verify|verify} messages.
     * @function encode
     * @memberof Invitation
     * @static
     * @param {IInvitation} message Invitation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Invitation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified Invitation message, length delimited. Does not implicitly {@link Invitation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Invitation
     * @static
     * @param {IInvitation} message Invitation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Invitation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Invitation message from the specified reader or buffer.
     * @function decode
     * @memberof Invitation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Invitation} Invitation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Invitation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Invitation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.version = reader.uint32();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Invitation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Invitation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Invitation} Invitation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Invitation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Invitation message.
     * @function verify
     * @memberof Invitation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Invitation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates an Invitation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Invitation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Invitation} Invitation
     */
    Invitation.fromObject = function fromObject(object) {
        if (object instanceof $root.Invitation)
            return object;
        let message = new $root.Invitation();
        if (object.version != null)
            message.version = object.version >>> 0;
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from an Invitation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Invitation
     * @static
     * @param {Invitation} message Invitation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Invitation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.version = 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this Invitation to JSON.
     * @function toJSON
     * @memberof Invitation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Invitation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Invitation;
})();

export const InvitationV0 = $root.InvitationV0 = (() => {

    /**
     * Properties of an InvitationV0.
     * @exports IInvitationV0
     * @interface IInvitationV0
     * @property {IKey|null} [key] InvitationV0 key
     * @property {ICertificate|null} [certificate] InvitationV0 certificate
     * @property {string|null} [networkName] InvitationV0 networkName
     */

    /**
     * Constructs a new InvitationV0.
     * @exports InvitationV0
     * @classdesc Represents an InvitationV0.
     * @implements IInvitationV0
     * @constructor
     * @param {IInvitationV0=} [properties] Properties to set
     */
    function InvitationV0(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InvitationV0 key.
     * @member {IKey|null|undefined} key
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.key = null;

    /**
     * InvitationV0 certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.certificate = null;

    /**
     * InvitationV0 networkName.
     * @member {string} networkName
     * @memberof InvitationV0
     * @instance
     */
    InvitationV0.prototype.networkName = "";

    /**
     * Creates a new InvitationV0 instance using the specified properties.
     * @function create
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0=} [properties] Properties to set
     * @returns {InvitationV0} InvitationV0 instance
     */
    InvitationV0.create = function create(properties) {
        return new InvitationV0(properties);
    };

    /**
     * Encodes the specified InvitationV0 message. Does not implicitly {@link InvitationV0.verify|verify} messages.
     * @function encode
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0} message InvitationV0 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InvitationV0.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.Key.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.networkName != null && Object.hasOwnProperty.call(message, "networkName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkName);
        return writer;
    };

    /**
     * Encodes the specified InvitationV0 message, length delimited. Does not implicitly {@link InvitationV0.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InvitationV0
     * @static
     * @param {IInvitationV0} message InvitationV0 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InvitationV0.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InvitationV0 message from the specified reader or buffer.
     * @function decode
     * @memberof InvitationV0
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InvitationV0} InvitationV0
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InvitationV0.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.InvitationV0();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = $root.Key.decode(reader, reader.uint32());
                break;
            case 2:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 4:
                message.networkName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InvitationV0 message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InvitationV0
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InvitationV0} InvitationV0
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InvitationV0.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InvitationV0 message.
     * @function verify
     * @memberof InvitationV0
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InvitationV0.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.Key.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            if (!$util.isString(message.networkName))
                return "networkName: string expected";
        return null;
    };

    /**
     * Creates an InvitationV0 message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InvitationV0
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InvitationV0} InvitationV0
     */
    InvitationV0.fromObject = function fromObject(object) {
        if (object instanceof $root.InvitationV0)
            return object;
        let message = new $root.InvitationV0();
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".InvitationV0.key: object expected");
            message.key = $root.Key.fromObject(object.key);
        }
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".InvitationV0.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.networkName != null)
            message.networkName = String(object.networkName);
        return message;
    };

    /**
     * Creates a plain object from an InvitationV0 message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InvitationV0
     * @static
     * @param {InvitationV0} message InvitationV0
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InvitationV0.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.key = null;
            object.certificate = null;
            object.networkName = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.Key.toObject(message.key, options);
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.networkName != null && message.hasOwnProperty("networkName"))
            object.networkName = message.networkName;
        return object;
    };

    /**
     * Converts this InvitationV0 to JSON.
     * @function toJSON
     * @memberof InvitationV0
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InvitationV0.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InvitationV0;
})();

export const CreateNetworkFromInvitationRequest = $root.CreateNetworkFromInvitationRequest = (() => {

    /**
     * Properties of a CreateNetworkFromInvitationRequest.
     * @exports ICreateNetworkFromInvitationRequest
     * @interface ICreateNetworkFromInvitationRequest
     * @property {string|null} [invitationB64] CreateNetworkFromInvitationRequest invitationB64
     * @property {Uint8Array|null} [invitationBytes] CreateNetworkFromInvitationRequest invitationBytes
     */

    /**
     * Constructs a new CreateNetworkFromInvitationRequest.
     * @exports CreateNetworkFromInvitationRequest
     * @classdesc Represents a CreateNetworkFromInvitationRequest.
     * @implements ICreateNetworkFromInvitationRequest
     * @constructor
     * @param {ICreateNetworkFromInvitationRequest=} [properties] Properties to set
     */
    function CreateNetworkFromInvitationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkFromInvitationRequest invitationB64.
     * @member {string} invitationB64
     * @memberof CreateNetworkFromInvitationRequest
     * @instance
     */
    CreateNetworkFromInvitationRequest.prototype.invitationB64 = "";

    /**
     * CreateNetworkFromInvitationRequest invitationBytes.
     * @member {Uint8Array} invitationBytes
     * @memberof CreateNetworkFromInvitationRequest
     * @instance
     */
    CreateNetworkFromInvitationRequest.prototype.invitationBytes = $util.newBuffer([]);

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CreateNetworkFromInvitationRequest invitation.
     * @member {"invitationB64"|"invitationBytes"|undefined} invitation
     * @memberof CreateNetworkFromInvitationRequest
     * @instance
     */
    Object.defineProperty(CreateNetworkFromInvitationRequest.prototype, "invitation", {
        get: $util.oneOfGetter($oneOfFields = ["invitationB64", "invitationBytes"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CreateNetworkFromInvitationRequest instance using the specified properties.
     * @function create
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {ICreateNetworkFromInvitationRequest=} [properties] Properties to set
     * @returns {CreateNetworkFromInvitationRequest} CreateNetworkFromInvitationRequest instance
     */
    CreateNetworkFromInvitationRequest.create = function create(properties) {
        return new CreateNetworkFromInvitationRequest(properties);
    };

    /**
     * Encodes the specified CreateNetworkFromInvitationRequest message. Does not implicitly {@link CreateNetworkFromInvitationRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {ICreateNetworkFromInvitationRequest} message CreateNetworkFromInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkFromInvitationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.invitationB64 != null && Object.hasOwnProperty.call(message, "invitationB64"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.invitationB64);
        if (message.invitationBytes != null && Object.hasOwnProperty.call(message, "invitationBytes"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.invitationBytes);
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkFromInvitationRequest message, length delimited. Does not implicitly {@link CreateNetworkFromInvitationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {ICreateNetworkFromInvitationRequest} message CreateNetworkFromInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkFromInvitationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkFromInvitationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkFromInvitationRequest} CreateNetworkFromInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkFromInvitationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkFromInvitationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.invitationB64 = reader.string();
                break;
            case 2:
                message.invitationBytes = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkFromInvitationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkFromInvitationRequest} CreateNetworkFromInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkFromInvitationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkFromInvitationRequest message.
     * @function verify
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkFromInvitationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64")) {
            properties.invitation = 1;
            if (!$util.isString(message.invitationB64))
                return "invitationB64: string expected";
        }
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes")) {
            if (properties.invitation === 1)
                return "invitation: multiple values";
            properties.invitation = 1;
            if (!(message.invitationBytes && typeof message.invitationBytes.length === "number" || $util.isString(message.invitationBytes)))
                return "invitationBytes: buffer expected";
        }
        return null;
    };

    /**
     * Creates a CreateNetworkFromInvitationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkFromInvitationRequest} CreateNetworkFromInvitationRequest
     */
    CreateNetworkFromInvitationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkFromInvitationRequest)
            return object;
        let message = new $root.CreateNetworkFromInvitationRequest();
        if (object.invitationB64 != null)
            message.invitationB64 = String(object.invitationB64);
        if (object.invitationBytes != null)
            if (typeof object.invitationBytes === "string")
                $util.base64.decode(object.invitationBytes, message.invitationBytes = $util.newBuffer($util.base64.length(object.invitationBytes)), 0);
            else if (object.invitationBytes.length)
                message.invitationBytes = object.invitationBytes;
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkFromInvitationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkFromInvitationRequest
     * @static
     * @param {CreateNetworkFromInvitationRequest} message CreateNetworkFromInvitationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkFromInvitationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.invitationB64 != null && message.hasOwnProperty("invitationB64")) {
            object.invitationB64 = message.invitationB64;
            if (options.oneofs)
                object.invitation = "invitationB64";
        }
        if (message.invitationBytes != null && message.hasOwnProperty("invitationBytes")) {
            object.invitationBytes = options.bytes === String ? $util.base64.encode(message.invitationBytes, 0, message.invitationBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.invitationBytes) : message.invitationBytes;
            if (options.oneofs)
                object.invitation = "invitationBytes";
        }
        return object;
    };

    /**
     * Converts this CreateNetworkFromInvitationRequest to JSON.
     * @function toJSON
     * @memberof CreateNetworkFromInvitationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkFromInvitationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkFromInvitationRequest;
})();

export const CreateNetworkFromInvitationResponse = $root.CreateNetworkFromInvitationResponse = (() => {

    /**
     * Properties of a CreateNetworkFromInvitationResponse.
     * @exports ICreateNetworkFromInvitationResponse
     * @interface ICreateNetworkFromInvitationResponse
     * @property {INetwork|null} [network] CreateNetworkFromInvitationResponse network
     */

    /**
     * Constructs a new CreateNetworkFromInvitationResponse.
     * @exports CreateNetworkFromInvitationResponse
     * @classdesc Represents a CreateNetworkFromInvitationResponse.
     * @implements ICreateNetworkFromInvitationResponse
     * @constructor
     * @param {ICreateNetworkFromInvitationResponse=} [properties] Properties to set
     */
    function CreateNetworkFromInvitationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateNetworkFromInvitationResponse network.
     * @member {INetwork|null|undefined} network
     * @memberof CreateNetworkFromInvitationResponse
     * @instance
     */
    CreateNetworkFromInvitationResponse.prototype.network = null;

    /**
     * Creates a new CreateNetworkFromInvitationResponse instance using the specified properties.
     * @function create
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {ICreateNetworkFromInvitationResponse=} [properties] Properties to set
     * @returns {CreateNetworkFromInvitationResponse} CreateNetworkFromInvitationResponse instance
     */
    CreateNetworkFromInvitationResponse.create = function create(properties) {
        return new CreateNetworkFromInvitationResponse(properties);
    };

    /**
     * Encodes the specified CreateNetworkFromInvitationResponse message. Does not implicitly {@link CreateNetworkFromInvitationResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {ICreateNetworkFromInvitationResponse} message CreateNetworkFromInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkFromInvitationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateNetworkFromInvitationResponse message, length delimited. Does not implicitly {@link CreateNetworkFromInvitationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {ICreateNetworkFromInvitationResponse} message CreateNetworkFromInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateNetworkFromInvitationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateNetworkFromInvitationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateNetworkFromInvitationResponse} CreateNetworkFromInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkFromInvitationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateNetworkFromInvitationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateNetworkFromInvitationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateNetworkFromInvitationResponse} CreateNetworkFromInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateNetworkFromInvitationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateNetworkFromInvitationResponse message.
     * @function verify
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateNetworkFromInvitationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a CreateNetworkFromInvitationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateNetworkFromInvitationResponse} CreateNetworkFromInvitationResponse
     */
    CreateNetworkFromInvitationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateNetworkFromInvitationResponse)
            return object;
        let message = new $root.CreateNetworkFromInvitationResponse();
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".CreateNetworkFromInvitationResponse.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateNetworkFromInvitationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateNetworkFromInvitationResponse
     * @static
     * @param {CreateNetworkFromInvitationResponse} message CreateNetworkFromInvitationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateNetworkFromInvitationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.network = null;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this CreateNetworkFromInvitationResponse to JSON.
     * @function toJSON
     * @memberof CreateNetworkFromInvitationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateNetworkFromInvitationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateNetworkFromInvitationResponse;
})();

export const Mutex = $root.Mutex = (() => {

    /**
     * Properties of a Mutex.
     * @exports IMutex
     * @interface IMutex
     * @property {number|null} [eol] Mutex eol
     * @property {Uint8Array|null} [token] Mutex token
     */

    /**
     * Constructs a new Mutex.
     * @exports Mutex
     * @classdesc Represents a Mutex.
     * @implements IMutex
     * @constructor
     * @param {IMutex=} [properties] Properties to set
     */
    function Mutex(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Mutex eol.
     * @member {number} eol
     * @memberof Mutex
     * @instance
     */
    Mutex.prototype.eol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Mutex token.
     * @member {Uint8Array} token
     * @memberof Mutex
     * @instance
     */
    Mutex.prototype.token = $util.newBuffer([]);

    /**
     * Creates a new Mutex instance using the specified properties.
     * @function create
     * @memberof Mutex
     * @static
     * @param {IMutex=} [properties] Properties to set
     * @returns {Mutex} Mutex instance
     */
    Mutex.create = function create(properties) {
        return new Mutex(properties);
    };

    /**
     * Encodes the specified Mutex message. Does not implicitly {@link Mutex.verify|verify} messages.
     * @function encode
     * @memberof Mutex
     * @static
     * @param {IMutex} message Mutex message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Mutex.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.eol != null && Object.hasOwnProperty.call(message, "eol"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.eol);
        if (message.token != null && Object.hasOwnProperty.call(message, "token"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
        return writer;
    };

    /**
     * Encodes the specified Mutex message, length delimited. Does not implicitly {@link Mutex.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Mutex
     * @static
     * @param {IMutex} message Mutex message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Mutex.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Mutex message from the specified reader or buffer.
     * @function decode
     * @memberof Mutex
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Mutex} Mutex
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Mutex.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Mutex();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.eol = reader.int64();
                break;
            case 2:
                message.token = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Mutex message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Mutex
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Mutex} Mutex
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Mutex.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Mutex message.
     * @function verify
     * @memberof Mutex
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Mutex.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.eol != null && message.hasOwnProperty("eol"))
            if (!$util.isInteger(message.eol) && !(message.eol && $util.isInteger(message.eol.low) && $util.isInteger(message.eol.high)))
                return "eol: integer|Long expected";
        if (message.token != null && message.hasOwnProperty("token"))
            if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                return "token: buffer expected";
        return null;
    };

    /**
     * Creates a Mutex message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Mutex
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Mutex} Mutex
     */
    Mutex.fromObject = function fromObject(object) {
        if (object instanceof $root.Mutex)
            return object;
        let message = new $root.Mutex();
        if (object.eol != null)
            if ($util.Long)
                (message.eol = $util.Long.fromValue(object.eol)).unsigned = false;
            else if (typeof object.eol === "string")
                message.eol = parseInt(object.eol, 10);
            else if (typeof object.eol === "number")
                message.eol = object.eol;
            else if (typeof object.eol === "object")
                message.eol = new $util.LongBits(object.eol.low >>> 0, object.eol.high >>> 0).toNumber();
        if (object.token != null)
            if (typeof object.token === "string")
                $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
            else if (object.token.length)
                message.token = object.token;
        return message;
    };

    /**
     * Creates a plain object from a Mutex message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Mutex
     * @static
     * @param {Mutex} message Mutex
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Mutex.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.eol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.eol = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.token = "";
            else {
                object.token = [];
                if (options.bytes !== Array)
                    object.token = $util.newBuffer(object.token);
            }
        }
        if (message.eol != null && message.hasOwnProperty("eol"))
            if (typeof message.eol === "number")
                object.eol = options.longs === String ? String(message.eol) : message.eol;
            else
                object.eol = options.longs === String ? $util.Long.prototype.toString.call(message.eol) : options.longs === Number ? new $util.LongBits(message.eol.low >>> 0, message.eol.high >>> 0).toNumber() : message.eol;
        if (message.token != null && message.hasOwnProperty("token"))
            object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
        return object;
    };

    /**
     * Converts this Mutex to JSON.
     * @function toJSON
     * @memberof Mutex
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Mutex.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Mutex;
})();

export const PubSubEvent = $root.PubSubEvent = (() => {

    /**
     * Properties of a PubSubEvent.
     * @exports IPubSubEvent
     * @interface IPubSubEvent
     * @property {PubSubEvent.IMessage|null} [message] PubSubEvent message
     * @property {PubSubEvent.IClose|null} [close] PubSubEvent close
     * @property {PubSubEvent.IPadding|null} [padding] PubSubEvent padding
     */

    /**
     * Constructs a new PubSubEvent.
     * @exports PubSubEvent
     * @classdesc Represents a PubSubEvent.
     * @implements IPubSubEvent
     * @constructor
     * @param {IPubSubEvent=} [properties] Properties to set
     */
    function PubSubEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PubSubEvent message.
     * @member {PubSubEvent.IMessage|null|undefined} message
     * @memberof PubSubEvent
     * @instance
     */
    PubSubEvent.prototype.message = null;

    /**
     * PubSubEvent close.
     * @member {PubSubEvent.IClose|null|undefined} close
     * @memberof PubSubEvent
     * @instance
     */
    PubSubEvent.prototype.close = null;

    /**
     * PubSubEvent padding.
     * @member {PubSubEvent.IPadding|null|undefined} padding
     * @memberof PubSubEvent
     * @instance
     */
    PubSubEvent.prototype.padding = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PubSubEvent body.
     * @member {"message"|"close"|"padding"|undefined} body
     * @memberof PubSubEvent
     * @instance
     */
    Object.defineProperty(PubSubEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["message", "close", "padding"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PubSubEvent instance using the specified properties.
     * @function create
     * @memberof PubSubEvent
     * @static
     * @param {IPubSubEvent=} [properties] Properties to set
     * @returns {PubSubEvent} PubSubEvent instance
     */
    PubSubEvent.create = function create(properties) {
        return new PubSubEvent(properties);
    };

    /**
     * Encodes the specified PubSubEvent message. Does not implicitly {@link PubSubEvent.verify|verify} messages.
     * @function encode
     * @memberof PubSubEvent
     * @static
     * @param {IPubSubEvent} message PubSubEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PubSubEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            $root.PubSubEvent.Message.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.PubSubEvent.Close.encode(message.close, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.padding != null && Object.hasOwnProperty.call(message, "padding"))
            $root.PubSubEvent.Padding.encode(message.padding, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PubSubEvent message, length delimited. Does not implicitly {@link PubSubEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PubSubEvent
     * @static
     * @param {IPubSubEvent} message PubSubEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PubSubEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PubSubEvent message from the specified reader or buffer.
     * @function decode
     * @memberof PubSubEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PubSubEvent} PubSubEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PubSubEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PubSubEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = $root.PubSubEvent.Message.decode(reader, reader.uint32());
                break;
            case 2:
                message.close = $root.PubSubEvent.Close.decode(reader, reader.uint32());
                break;
            case 3:
                message.padding = $root.PubSubEvent.Padding.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PubSubEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PubSubEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PubSubEvent} PubSubEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PubSubEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PubSubEvent message.
     * @function verify
     * @memberof PubSubEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PubSubEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.message != null && message.hasOwnProperty("message")) {
            properties.body = 1;
            {
                let error = $root.PubSubEvent.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PubSubEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        if (message.padding != null && message.hasOwnProperty("padding")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PubSubEvent.Padding.verify(message.padding);
                if (error)
                    return "padding." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PubSubEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PubSubEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PubSubEvent} PubSubEvent
     */
    PubSubEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.PubSubEvent)
            return object;
        let message = new $root.PubSubEvent();
        if (object.message != null) {
            if (typeof object.message !== "object")
                throw TypeError(".PubSubEvent.message: object expected");
            message.message = $root.PubSubEvent.Message.fromObject(object.message);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".PubSubEvent.close: object expected");
            message.close = $root.PubSubEvent.Close.fromObject(object.close);
        }
        if (object.padding != null) {
            if (typeof object.padding !== "object")
                throw TypeError(".PubSubEvent.padding: object expected");
            message.padding = $root.PubSubEvent.Padding.fromObject(object.padding);
        }
        return message;
    };

    /**
     * Creates a plain object from a PubSubEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PubSubEvent
     * @static
     * @param {PubSubEvent} message PubSubEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PubSubEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.message != null && message.hasOwnProperty("message")) {
            object.message = $root.PubSubEvent.Message.toObject(message.message, options);
            if (options.oneofs)
                object.body = "message";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.PubSubEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        if (message.padding != null && message.hasOwnProperty("padding")) {
            object.padding = $root.PubSubEvent.Padding.toObject(message.padding, options);
            if (options.oneofs)
                object.body = "padding";
        }
        return object;
    };

    /**
     * Converts this PubSubEvent to JSON.
     * @function toJSON
     * @memberof PubSubEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PubSubEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PubSubEvent.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof PubSubEvent
         * @interface IMessage
         * @property {number|null} [time] Message time
         * @property {string|null} [key] Message key
         * @property {Uint8Array|null} [body] Message body
         */

        /**
         * Constructs a new Message.
         * @memberof PubSubEvent
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {PubSubEvent.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message time.
         * @member {number} time
         * @memberof PubSubEvent.Message
         * @instance
         */
        Message.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Message key.
         * @member {string} key
         * @memberof PubSubEvent.Message
         * @instance
         */
        Message.prototype.key = "";

        /**
         * Message body.
         * @member {Uint8Array} body
         * @memberof PubSubEvent.Message
         * @instance
         */
        Message.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof PubSubEvent.Message
         * @static
         * @param {PubSubEvent.IMessage=} [properties] Properties to set
         * @returns {PubSubEvent.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link PubSubEvent.Message.verify|verify} messages.
         * @function encode
         * @memberof PubSubEvent.Message
         * @static
         * @param {PubSubEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link PubSubEvent.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PubSubEvent.Message
         * @static
         * @param {PubSubEvent.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof PubSubEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PubSubEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PubSubEvent.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                case 3:
                    message.key = reader.string();
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PubSubEvent.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PubSubEvent.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof PubSubEvent.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PubSubEvent.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PubSubEvent.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.PubSubEvent.Message)
                return object;
            let message = new $root.PubSubEvent.Message();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.key != null)
                message.key = String(object.key);
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PubSubEvent.Message
         * @static
         * @param {PubSubEvent.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.key = "";
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof PubSubEvent.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    PubSubEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof PubSubEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof PubSubEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {PubSubEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof PubSubEvent.Close
         * @static
         * @param {PubSubEvent.IClose=} [properties] Properties to set
         * @returns {PubSubEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link PubSubEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof PubSubEvent.Close
         * @static
         * @param {PubSubEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link PubSubEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PubSubEvent.Close
         * @static
         * @param {PubSubEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof PubSubEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PubSubEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PubSubEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PubSubEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PubSubEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof PubSubEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PubSubEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PubSubEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.PubSubEvent.Close)
                return object;
            return new $root.PubSubEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PubSubEvent.Close
         * @static
         * @param {PubSubEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof PubSubEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    PubSubEvent.Padding = (function() {

        /**
         * Properties of a Padding.
         * @memberof PubSubEvent
         * @interface IPadding
         * @property {Uint8Array|null} [body] Padding body
         */

        /**
         * Constructs a new Padding.
         * @memberof PubSubEvent
         * @classdesc Represents a Padding.
         * @implements IPadding
         * @constructor
         * @param {PubSubEvent.IPadding=} [properties] Properties to set
         */
        function Padding(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Padding body.
         * @member {Uint8Array} body
         * @memberof PubSubEvent.Padding
         * @instance
         */
        Padding.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new Padding instance using the specified properties.
         * @function create
         * @memberof PubSubEvent.Padding
         * @static
         * @param {PubSubEvent.IPadding=} [properties] Properties to set
         * @returns {PubSubEvent.Padding} Padding instance
         */
        Padding.create = function create(properties) {
            return new Padding(properties);
        };

        /**
         * Encodes the specified Padding message. Does not implicitly {@link PubSubEvent.Padding.verify|verify} messages.
         * @function encode
         * @memberof PubSubEvent.Padding
         * @static
         * @param {PubSubEvent.IPadding} message Padding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Padding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified Padding message, length delimited. Does not implicitly {@link PubSubEvent.Padding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PubSubEvent.Padding
         * @static
         * @param {PubSubEvent.IPadding} message Padding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Padding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Padding message from the specified reader or buffer.
         * @function decode
         * @memberof PubSubEvent.Padding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PubSubEvent.Padding} Padding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Padding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PubSubEvent.Padding();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Padding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PubSubEvent.Padding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PubSubEvent.Padding} Padding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Padding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Padding message.
         * @function verify
         * @memberof PubSubEvent.Padding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Padding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a Padding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PubSubEvent.Padding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PubSubEvent.Padding} Padding
         */
        Padding.fromObject = function fromObject(object) {
            if (object instanceof $root.PubSubEvent.Padding)
                return object;
            let message = new $root.PubSubEvent.Padding();
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a Padding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PubSubEvent.Padding
         * @static
         * @param {PubSubEvent.Padding} message Padding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Padding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this Padding to JSON.
         * @function toJSON
         * @memberof PubSubEvent.Padding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Padding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Padding;
    })();

    return PubSubEvent;
})();

export const Call = $root.Call = (() => {

    /**
     * Properties of a Call.
     * @exports ICall
     * @interface ICall
     * @property {number|null} [id] Call id
     * @property {number|null} [parentId] Call parentId
     * @property {string|null} [method] Call method
     * @property {google.protobuf.IAny|null} [argument] Call argument
     */

    /**
     * Constructs a new Call.
     * @exports Call
     * @classdesc Represents a Call.
     * @implements ICall
     * @constructor
     * @param {ICall=} [properties] Properties to set
     */
    function Call(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Call id.
     * @member {number} id
     * @memberof Call
     * @instance
     */
    Call.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Call parentId.
     * @member {number} parentId
     * @memberof Call
     * @instance
     */
    Call.prototype.parentId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Call method.
     * @member {string} method
     * @memberof Call
     * @instance
     */
    Call.prototype.method = "";

    /**
     * Call argument.
     * @member {google.protobuf.IAny|null|undefined} argument
     * @memberof Call
     * @instance
     */
    Call.prototype.argument = null;

    /**
     * Creates a new Call instance using the specified properties.
     * @function create
     * @memberof Call
     * @static
     * @param {ICall=} [properties] Properties to set
     * @returns {Call} Call instance
     */
    Call.create = function create(properties) {
        return new Call(properties);
    };

    /**
     * Encodes the specified Call message. Does not implicitly {@link Call.verify|verify} messages.
     * @function encode
     * @memberof Call
     * @static
     * @param {ICall} message Call message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Call.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.parentId);
        if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.method);
        if (message.argument != null && Object.hasOwnProperty.call(message, "argument"))
            $root.google.protobuf.Any.encode(message.argument, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Call message, length delimited. Does not implicitly {@link Call.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Call
     * @static
     * @param {ICall} message Call message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Call.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Call message from the specified reader or buffer.
     * @function decode
     * @memberof Call
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Call} Call
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Call.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Call();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.parentId = reader.uint64();
                break;
            case 3:
                message.method = reader.string();
                break;
            case 4:
                message.argument = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Call message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Call
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Call} Call
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Call.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Call message.
     * @function verify
     * @memberof Call
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Call.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.parentId != null && message.hasOwnProperty("parentId"))
            if (!$util.isInteger(message.parentId) && !(message.parentId && $util.isInteger(message.parentId.low) && $util.isInteger(message.parentId.high)))
                return "parentId: integer|Long expected";
        if (message.method != null && message.hasOwnProperty("method"))
            if (!$util.isString(message.method))
                return "method: string expected";
        if (message.argument != null && message.hasOwnProperty("argument")) {
            let error = $root.google.protobuf.Any.verify(message.argument);
            if (error)
                return "argument." + error;
        }
        return null;
    };

    /**
     * Creates a Call message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Call
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Call} Call
     */
    Call.fromObject = function fromObject(object) {
        if (object instanceof $root.Call)
            return object;
        let message = new $root.Call();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.parentId != null)
            if ($util.Long)
                (message.parentId = $util.Long.fromValue(object.parentId)).unsigned = true;
            else if (typeof object.parentId === "string")
                message.parentId = parseInt(object.parentId, 10);
            else if (typeof object.parentId === "number")
                message.parentId = object.parentId;
            else if (typeof object.parentId === "object")
                message.parentId = new $util.LongBits(object.parentId.low >>> 0, object.parentId.high >>> 0).toNumber(true);
        if (object.method != null)
            message.method = String(object.method);
        if (object.argument != null) {
            if (typeof object.argument !== "object")
                throw TypeError(".Call.argument: object expected");
            message.argument = $root.google.protobuf.Any.fromObject(object.argument);
        }
        return message;
    };

    /**
     * Creates a plain object from a Call message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Call
     * @static
     * @param {Call} message Call
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Call.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.parentId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.parentId = options.longs === String ? "0" : 0;
            object.method = "";
            object.argument = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.parentId != null && message.hasOwnProperty("parentId"))
            if (typeof message.parentId === "number")
                object.parentId = options.longs === String ? String(message.parentId) : message.parentId;
            else
                object.parentId = options.longs === String ? $util.Long.prototype.toString.call(message.parentId) : options.longs === Number ? new $util.LongBits(message.parentId.low >>> 0, message.parentId.high >>> 0).toNumber(true) : message.parentId;
        if (message.method != null && message.hasOwnProperty("method"))
            object.method = message.method;
        if (message.argument != null && message.hasOwnProperty("argument"))
            object.argument = $root.google.protobuf.Any.toObject(message.argument, options);
        return object;
    };

    /**
     * Converts this Call to JSON.
     * @function toJSON
     * @memberof Call
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Call.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Call;
})();

export const Error = $root.Error = (() => {

    /**
     * Properties of an Error.
     * @exports IError
     * @interface IError
     * @property {string|null} [message] Error message
     */

    /**
     * Constructs a new Error.
     * @exports Error
     * @classdesc Represents an Error.
     * @implements IError
     * @constructor
     * @param {IError=} [properties] Properties to set
     */
    function Error(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Error message.
     * @member {string} message
     * @memberof Error
     * @instance
     */
    Error.prototype.message = "";

    /**
     * Creates a new Error instance using the specified properties.
     * @function create
     * @memberof Error
     * @static
     * @param {IError=} [properties] Properties to set
     * @returns {Error} Error instance
     */
    Error.create = function create(properties) {
        return new Error(properties);
    };

    /**
     * Encodes the specified Error message. Does not implicitly {@link Error.verify|verify} messages.
     * @function encode
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified Error message, length delimited. Does not implicitly {@link Error.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Error
     * @static
     * @param {IError} message Error message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Error.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Error message from the specified reader or buffer.
     * @function decode
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Error();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Error message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Error
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Error} Error
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Error.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Error message.
     * @function verify
     * @memberof Error
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Error.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message))
                return "message: string expected";
        return null;
    };

    /**
     * Creates an Error message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Error
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Error} Error
     */
    Error.fromObject = function fromObject(object) {
        if (object instanceof $root.Error)
            return object;
        let message = new $root.Error();
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from an Error message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Error
     * @static
     * @param {Error} message Error
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Error.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.message = "";
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this Error to JSON.
     * @function toJSON
     * @memberof Error
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Error.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Error;
})();

export const Cancel = $root.Cancel = (() => {

    /**
     * Properties of a Cancel.
     * @exports ICancel
     * @interface ICancel
     */

    /**
     * Constructs a new Cancel.
     * @exports Cancel
     * @classdesc Represents a Cancel.
     * @implements ICancel
     * @constructor
     * @param {ICancel=} [properties] Properties to set
     */
    function Cancel(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Cancel instance using the specified properties.
     * @function create
     * @memberof Cancel
     * @static
     * @param {ICancel=} [properties] Properties to set
     * @returns {Cancel} Cancel instance
     */
    Cancel.create = function create(properties) {
        return new Cancel(properties);
    };

    /**
     * Encodes the specified Cancel message. Does not implicitly {@link Cancel.verify|verify} messages.
     * @function encode
     * @memberof Cancel
     * @static
     * @param {ICancel} message Cancel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Cancel.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Cancel message, length delimited. Does not implicitly {@link Cancel.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Cancel
     * @static
     * @param {ICancel} message Cancel message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Cancel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Cancel message from the specified reader or buffer.
     * @function decode
     * @memberof Cancel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Cancel} Cancel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Cancel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Cancel();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Cancel message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Cancel
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Cancel} Cancel
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Cancel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Cancel message.
     * @function verify
     * @memberof Cancel
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Cancel.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a Cancel message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Cancel
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Cancel} Cancel
     */
    Cancel.fromObject = function fromObject(object) {
        if (object instanceof $root.Cancel)
            return object;
        return new $root.Cancel();
    };

    /**
     * Creates a plain object from a Cancel message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Cancel
     * @static
     * @param {Cancel} message Cancel
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Cancel.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Cancel to JSON.
     * @function toJSON
     * @memberof Cancel
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Cancel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Cancel;
})();

export const Undefined = $root.Undefined = (() => {

    /**
     * Properties of an Undefined.
     * @exports IUndefined
     * @interface IUndefined
     */

    /**
     * Constructs a new Undefined.
     * @exports Undefined
     * @classdesc Represents an Undefined.
     * @implements IUndefined
     * @constructor
     * @param {IUndefined=} [properties] Properties to set
     */
    function Undefined(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Undefined instance using the specified properties.
     * @function create
     * @memberof Undefined
     * @static
     * @param {IUndefined=} [properties] Properties to set
     * @returns {Undefined} Undefined instance
     */
    Undefined.create = function create(properties) {
        return new Undefined(properties);
    };

    /**
     * Encodes the specified Undefined message. Does not implicitly {@link Undefined.verify|verify} messages.
     * @function encode
     * @memberof Undefined
     * @static
     * @param {IUndefined} message Undefined message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Undefined.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Undefined message, length delimited. Does not implicitly {@link Undefined.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Undefined
     * @static
     * @param {IUndefined} message Undefined message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Undefined.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Undefined message from the specified reader or buffer.
     * @function decode
     * @memberof Undefined
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Undefined} Undefined
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Undefined.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Undefined();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Undefined message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Undefined
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Undefined} Undefined
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Undefined.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Undefined message.
     * @function verify
     * @memberof Undefined
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Undefined.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an Undefined message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Undefined
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Undefined} Undefined
     */
    Undefined.fromObject = function fromObject(object) {
        if (object instanceof $root.Undefined)
            return object;
        return new $root.Undefined();
    };

    /**
     * Creates a plain object from an Undefined message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Undefined
     * @static
     * @param {Undefined} message Undefined
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Undefined.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Undefined to JSON.
     * @function toJSON
     * @memberof Undefined
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Undefined.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Undefined;
})();

export const Close = $root.Close = (() => {

    /**
     * Properties of a Close.
     * @exports IClose
     * @interface IClose
     */

    /**
     * Constructs a new Close.
     * @exports Close
     * @classdesc Represents a Close.
     * @implements IClose
     * @constructor
     * @param {IClose=} [properties] Properties to set
     */
    function Close(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new Close instance using the specified properties.
     * @function create
     * @memberof Close
     * @static
     * @param {IClose=} [properties] Properties to set
     * @returns {Close} Close instance
     */
    Close.create = function create(properties) {
        return new Close(properties);
    };

    /**
     * Encodes the specified Close message. Does not implicitly {@link Close.verify|verify} messages.
     * @function encode
     * @memberof Close
     * @static
     * @param {IClose} message Close message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Close.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified Close message, length delimited. Does not implicitly {@link Close.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Close
     * @static
     * @param {IClose} message Close message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Close.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Close message from the specified reader or buffer.
     * @function decode
     * @memberof Close
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Close} Close
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Close.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Close();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Close message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Close
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Close} Close
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Close.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Close message.
     * @function verify
     * @memberof Close
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Close.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a Close message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Close
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Close} Close
     */
    Close.fromObject = function fromObject(object) {
        if (object instanceof $root.Close)
            return object;
        return new $root.Close();
    };

    /**
     * Creates a plain object from a Close message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Close
     * @static
     * @param {Close} message Close
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Close.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this Close to JSON.
     * @function toJSON
     * @memberof Close
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Close.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Close;
})();

export const JoinSwarmRequest = $root.JoinSwarmRequest = (() => {

    /**
     * Properties of a JoinSwarmRequest.
     * @exports IJoinSwarmRequest
     * @interface IJoinSwarmRequest
     * @property {string|null} [swarmUri] JoinSwarmRequest swarmUri
     */

    /**
     * Constructs a new JoinSwarmRequest.
     * @exports JoinSwarmRequest
     * @classdesc Represents a JoinSwarmRequest.
     * @implements IJoinSwarmRequest
     * @constructor
     * @param {IJoinSwarmRequest=} [properties] Properties to set
     */
    function JoinSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * JoinSwarmRequest swarmUri.
     * @member {string} swarmUri
     * @memberof JoinSwarmRequest
     * @instance
     */
    JoinSwarmRequest.prototype.swarmUri = "";

    /**
     * Creates a new JoinSwarmRequest instance using the specified properties.
     * @function create
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest=} [properties] Properties to set
     * @returns {JoinSwarmRequest} JoinSwarmRequest instance
     */
    JoinSwarmRequest.create = function create(properties) {
        return new JoinSwarmRequest(properties);
    };

    /**
     * Encodes the specified JoinSwarmRequest message. Does not implicitly {@link JoinSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest} message JoinSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified JoinSwarmRequest message, length delimited. Does not implicitly {@link JoinSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof JoinSwarmRequest
     * @static
     * @param {IJoinSwarmRequest} message JoinSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a JoinSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof JoinSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.JoinSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a JoinSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof JoinSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a JoinSwarmRequest message.
     * @function verify
     * @memberof JoinSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    JoinSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a JoinSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof JoinSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {JoinSwarmRequest} JoinSwarmRequest
     */
    JoinSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.JoinSwarmRequest)
            return object;
        let message = new $root.JoinSwarmRequest();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a JoinSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof JoinSwarmRequest
     * @static
     * @param {JoinSwarmRequest} message JoinSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    JoinSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this JoinSwarmRequest to JSON.
     * @function toJSON
     * @memberof JoinSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    JoinSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return JoinSwarmRequest;
})();

export const JoinSwarmResponse = $root.JoinSwarmResponse = (() => {

    /**
     * Properties of a JoinSwarmResponse.
     * @exports IJoinSwarmResponse
     * @interface IJoinSwarmResponse
     */

    /**
     * Constructs a new JoinSwarmResponse.
     * @exports JoinSwarmResponse
     * @classdesc Represents a JoinSwarmResponse.
     * @implements IJoinSwarmResponse
     * @constructor
     * @param {IJoinSwarmResponse=} [properties] Properties to set
     */
    function JoinSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new JoinSwarmResponse instance using the specified properties.
     * @function create
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse=} [properties] Properties to set
     * @returns {JoinSwarmResponse} JoinSwarmResponse instance
     */
    JoinSwarmResponse.create = function create(properties) {
        return new JoinSwarmResponse(properties);
    };

    /**
     * Encodes the specified JoinSwarmResponse message. Does not implicitly {@link JoinSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse} message JoinSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified JoinSwarmResponse message, length delimited. Does not implicitly {@link JoinSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof JoinSwarmResponse
     * @static
     * @param {IJoinSwarmResponse} message JoinSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    JoinSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a JoinSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof JoinSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.JoinSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a JoinSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof JoinSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    JoinSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a JoinSwarmResponse message.
     * @function verify
     * @memberof JoinSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    JoinSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a JoinSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof JoinSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {JoinSwarmResponse} JoinSwarmResponse
     */
    JoinSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.JoinSwarmResponse)
            return object;
        return new $root.JoinSwarmResponse();
    };

    /**
     * Creates a plain object from a JoinSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof JoinSwarmResponse
     * @static
     * @param {JoinSwarmResponse} message JoinSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    JoinSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this JoinSwarmResponse to JSON.
     * @function toJSON
     * @memberof JoinSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    JoinSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return JoinSwarmResponse;
})();

export const LeaveSwarmRequest = $root.LeaveSwarmRequest = (() => {

    /**
     * Properties of a LeaveSwarmRequest.
     * @exports ILeaveSwarmRequest
     * @interface ILeaveSwarmRequest
     * @property {string|null} [swarmUri] LeaveSwarmRequest swarmUri
     */

    /**
     * Constructs a new LeaveSwarmRequest.
     * @exports LeaveSwarmRequest
     * @classdesc Represents a LeaveSwarmRequest.
     * @implements ILeaveSwarmRequest
     * @constructor
     * @param {ILeaveSwarmRequest=} [properties] Properties to set
     */
    function LeaveSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LeaveSwarmRequest swarmUri.
     * @member {string} swarmUri
     * @memberof LeaveSwarmRequest
     * @instance
     */
    LeaveSwarmRequest.prototype.swarmUri = "";

    /**
     * Creates a new LeaveSwarmRequest instance using the specified properties.
     * @function create
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest=} [properties] Properties to set
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest instance
     */
    LeaveSwarmRequest.create = function create(properties) {
        return new LeaveSwarmRequest(properties);
    };

    /**
     * Encodes the specified LeaveSwarmRequest message. Does not implicitly {@link LeaveSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest} message LeaveSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified LeaveSwarmRequest message, length delimited. Does not implicitly {@link LeaveSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LeaveSwarmRequest
     * @static
     * @param {ILeaveSwarmRequest} message LeaveSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LeaveSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LeaveSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LeaveSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LeaveSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LeaveSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LeaveSwarmRequest message.
     * @function verify
     * @memberof LeaveSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LeaveSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a LeaveSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LeaveSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LeaveSwarmRequest} LeaveSwarmRequest
     */
    LeaveSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LeaveSwarmRequest)
            return object;
        let message = new $root.LeaveSwarmRequest();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a LeaveSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LeaveSwarmRequest
     * @static
     * @param {LeaveSwarmRequest} message LeaveSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LeaveSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this LeaveSwarmRequest to JSON.
     * @function toJSON
     * @memberof LeaveSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LeaveSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LeaveSwarmRequest;
})();

export const LeaveSwarmResponse = $root.LeaveSwarmResponse = (() => {

    /**
     * Properties of a LeaveSwarmResponse.
     * @exports ILeaveSwarmResponse
     * @interface ILeaveSwarmResponse
     */

    /**
     * Constructs a new LeaveSwarmResponse.
     * @exports LeaveSwarmResponse
     * @classdesc Represents a LeaveSwarmResponse.
     * @implements ILeaveSwarmResponse
     * @constructor
     * @param {ILeaveSwarmResponse=} [properties] Properties to set
     */
    function LeaveSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new LeaveSwarmResponse instance using the specified properties.
     * @function create
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse=} [properties] Properties to set
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse instance
     */
    LeaveSwarmResponse.create = function create(properties) {
        return new LeaveSwarmResponse(properties);
    };

    /**
     * Encodes the specified LeaveSwarmResponse message. Does not implicitly {@link LeaveSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse} message LeaveSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified LeaveSwarmResponse message, length delimited. Does not implicitly {@link LeaveSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LeaveSwarmResponse
     * @static
     * @param {ILeaveSwarmResponse} message LeaveSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LeaveSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LeaveSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof LeaveSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LeaveSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LeaveSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LeaveSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LeaveSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LeaveSwarmResponse message.
     * @function verify
     * @memberof LeaveSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LeaveSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a LeaveSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LeaveSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LeaveSwarmResponse} LeaveSwarmResponse
     */
    LeaveSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.LeaveSwarmResponse)
            return object;
        return new $root.LeaveSwarmResponse();
    };

    /**
     * Creates a plain object from a LeaveSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LeaveSwarmResponse
     * @static
     * @param {LeaveSwarmResponse} message LeaveSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LeaveSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this LeaveSwarmResponse to JSON.
     * @function toJSON
     * @memberof LeaveSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LeaveSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LeaveSwarmResponse;
})();

export const GetIngressStreamsRequest = $root.GetIngressStreamsRequest = (() => {

    /**
     * Properties of a GetIngressStreamsRequest.
     * @exports IGetIngressStreamsRequest
     * @interface IGetIngressStreamsRequest
     */

    /**
     * Constructs a new GetIngressStreamsRequest.
     * @exports GetIngressStreamsRequest
     * @classdesc Represents a GetIngressStreamsRequest.
     * @implements IGetIngressStreamsRequest
     * @constructor
     * @param {IGetIngressStreamsRequest=} [properties] Properties to set
     */
    function GetIngressStreamsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetIngressStreamsRequest instance using the specified properties.
     * @function create
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest=} [properties] Properties to set
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest instance
     */
    GetIngressStreamsRequest.create = function create(properties) {
        return new GetIngressStreamsRequest(properties);
    };

    /**
     * Encodes the specified GetIngressStreamsRequest message. Does not implicitly {@link GetIngressStreamsRequest.verify|verify} messages.
     * @function encode
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest} message GetIngressStreamsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetIngressStreamsRequest message, length delimited. Does not implicitly {@link GetIngressStreamsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {IGetIngressStreamsRequest} message GetIngressStreamsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetIngressStreamsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetIngressStreamsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetIngressStreamsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetIngressStreamsRequest message.
     * @function verify
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetIngressStreamsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetIngressStreamsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetIngressStreamsRequest} GetIngressStreamsRequest
     */
    GetIngressStreamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetIngressStreamsRequest)
            return object;
        return new $root.GetIngressStreamsRequest();
    };

    /**
     * Creates a plain object from a GetIngressStreamsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetIngressStreamsRequest
     * @static
     * @param {GetIngressStreamsRequest} message GetIngressStreamsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetIngressStreamsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetIngressStreamsRequest to JSON.
     * @function toJSON
     * @memberof GetIngressStreamsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetIngressStreamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetIngressStreamsRequest;
})();

export const GetIngressStreamsResponse = $root.GetIngressStreamsResponse = (() => {

    /**
     * Properties of a GetIngressStreamsResponse.
     * @exports IGetIngressStreamsResponse
     * @interface IGetIngressStreamsResponse
     * @property {string|null} [swarmUri] GetIngressStreamsResponse swarmUri
     */

    /**
     * Constructs a new GetIngressStreamsResponse.
     * @exports GetIngressStreamsResponse
     * @classdesc Represents a GetIngressStreamsResponse.
     * @implements IGetIngressStreamsResponse
     * @constructor
     * @param {IGetIngressStreamsResponse=} [properties] Properties to set
     */
    function GetIngressStreamsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetIngressStreamsResponse swarmUri.
     * @member {string} swarmUri
     * @memberof GetIngressStreamsResponse
     * @instance
     */
    GetIngressStreamsResponse.prototype.swarmUri = "";

    /**
     * Creates a new GetIngressStreamsResponse instance using the specified properties.
     * @function create
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse=} [properties] Properties to set
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse instance
     */
    GetIngressStreamsResponse.create = function create(properties) {
        return new GetIngressStreamsResponse(properties);
    };

    /**
     * Encodes the specified GetIngressStreamsResponse message. Does not implicitly {@link GetIngressStreamsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse} message GetIngressStreamsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmUri != null && Object.hasOwnProperty.call(message, "swarmUri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.swarmUri);
        return writer;
    };

    /**
     * Encodes the specified GetIngressStreamsResponse message, length delimited. Does not implicitly {@link GetIngressStreamsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {IGetIngressStreamsResponse} message GetIngressStreamsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetIngressStreamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetIngressStreamsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetIngressStreamsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmUri = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetIngressStreamsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetIngressStreamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetIngressStreamsResponse message.
     * @function verify
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetIngressStreamsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            if (!$util.isString(message.swarmUri))
                return "swarmUri: string expected";
        return null;
    };

    /**
     * Creates a GetIngressStreamsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetIngressStreamsResponse} GetIngressStreamsResponse
     */
    GetIngressStreamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetIngressStreamsResponse)
            return object;
        let message = new $root.GetIngressStreamsResponse();
        if (object.swarmUri != null)
            message.swarmUri = String(object.swarmUri);
        return message;
    };

    /**
     * Creates a plain object from a GetIngressStreamsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetIngressStreamsResponse
     * @static
     * @param {GetIngressStreamsResponse} message GetIngressStreamsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetIngressStreamsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.swarmUri = "";
        if (message.swarmUri != null && message.hasOwnProperty("swarmUri"))
            object.swarmUri = message.swarmUri;
        return object;
    };

    /**
     * Converts this GetIngressStreamsResponse to JSON.
     * @function toJSON
     * @memberof GetIngressStreamsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetIngressStreamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetIngressStreamsResponse;
})();

export const StartRTMPIngressRequest = $root.StartRTMPIngressRequest = (() => {

    /**
     * Properties of a StartRTMPIngressRequest.
     * @exports IStartRTMPIngressRequest
     * @interface IStartRTMPIngressRequest
     */

    /**
     * Constructs a new StartRTMPIngressRequest.
     * @exports StartRTMPIngressRequest
     * @classdesc Represents a StartRTMPIngressRequest.
     * @implements IStartRTMPIngressRequest
     * @constructor
     * @param {IStartRTMPIngressRequest=} [properties] Properties to set
     */
    function StartRTMPIngressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartRTMPIngressRequest instance using the specified properties.
     * @function create
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {IStartRTMPIngressRequest=} [properties] Properties to set
     * @returns {StartRTMPIngressRequest} StartRTMPIngressRequest instance
     */
    StartRTMPIngressRequest.create = function create(properties) {
        return new StartRTMPIngressRequest(properties);
    };

    /**
     * Encodes the specified StartRTMPIngressRequest message. Does not implicitly {@link StartRTMPIngressRequest.verify|verify} messages.
     * @function encode
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {IStartRTMPIngressRequest} message StartRTMPIngressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartRTMPIngressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartRTMPIngressRequest message, length delimited. Does not implicitly {@link StartRTMPIngressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {IStartRTMPIngressRequest} message StartRTMPIngressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartRTMPIngressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartRTMPIngressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartRTMPIngressRequest} StartRTMPIngressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartRTMPIngressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartRTMPIngressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartRTMPIngressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartRTMPIngressRequest} StartRTMPIngressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartRTMPIngressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartRTMPIngressRequest message.
     * @function verify
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartRTMPIngressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartRTMPIngressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartRTMPIngressRequest} StartRTMPIngressRequest
     */
    StartRTMPIngressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartRTMPIngressRequest)
            return object;
        return new $root.StartRTMPIngressRequest();
    };

    /**
     * Creates a plain object from a StartRTMPIngressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartRTMPIngressRequest
     * @static
     * @param {StartRTMPIngressRequest} message StartRTMPIngressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartRTMPIngressRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartRTMPIngressRequest to JSON.
     * @function toJSON
     * @memberof StartRTMPIngressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartRTMPIngressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartRTMPIngressRequest;
})();

export const StartRTMPIngressResponse = $root.StartRTMPIngressResponse = (() => {

    /**
     * Properties of a StartRTMPIngressResponse.
     * @exports IStartRTMPIngressResponse
     * @interface IStartRTMPIngressResponse
     */

    /**
     * Constructs a new StartRTMPIngressResponse.
     * @exports StartRTMPIngressResponse
     * @classdesc Represents a StartRTMPIngressResponse.
     * @implements IStartRTMPIngressResponse
     * @constructor
     * @param {IStartRTMPIngressResponse=} [properties] Properties to set
     */
    function StartRTMPIngressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartRTMPIngressResponse instance using the specified properties.
     * @function create
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {IStartRTMPIngressResponse=} [properties] Properties to set
     * @returns {StartRTMPIngressResponse} StartRTMPIngressResponse instance
     */
    StartRTMPIngressResponse.create = function create(properties) {
        return new StartRTMPIngressResponse(properties);
    };

    /**
     * Encodes the specified StartRTMPIngressResponse message. Does not implicitly {@link StartRTMPIngressResponse.verify|verify} messages.
     * @function encode
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {IStartRTMPIngressResponse} message StartRTMPIngressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartRTMPIngressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartRTMPIngressResponse message, length delimited. Does not implicitly {@link StartRTMPIngressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {IStartRTMPIngressResponse} message StartRTMPIngressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartRTMPIngressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartRTMPIngressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartRTMPIngressResponse} StartRTMPIngressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartRTMPIngressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartRTMPIngressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartRTMPIngressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartRTMPIngressResponse} StartRTMPIngressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartRTMPIngressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartRTMPIngressResponse message.
     * @function verify
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartRTMPIngressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartRTMPIngressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartRTMPIngressResponse} StartRTMPIngressResponse
     */
    StartRTMPIngressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartRTMPIngressResponse)
            return object;
        return new $root.StartRTMPIngressResponse();
    };

    /**
     * Creates a plain object from a StartRTMPIngressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartRTMPIngressResponse
     * @static
     * @param {StartRTMPIngressResponse} message StartRTMPIngressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartRTMPIngressResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartRTMPIngressResponse to JSON.
     * @function toJSON
     * @memberof StartRTMPIngressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartRTMPIngressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartRTMPIngressResponse;
})();

export const StartHLSEgressRequest = $root.StartHLSEgressRequest = (() => {

    /**
     * Properties of a StartHLSEgressRequest.
     * @exports IStartHLSEgressRequest
     * @interface IStartHLSEgressRequest
     * @property {number|null} [videoId] StartHLSEgressRequest videoId
     * @property {string|null} [address] StartHLSEgressRequest address
     */

    /**
     * Constructs a new StartHLSEgressRequest.
     * @exports StartHLSEgressRequest
     * @classdesc Represents a StartHLSEgressRequest.
     * @implements IStartHLSEgressRequest
     * @constructor
     * @param {IStartHLSEgressRequest=} [properties] Properties to set
     */
    function StartHLSEgressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StartHLSEgressRequest videoId.
     * @member {number} videoId
     * @memberof StartHLSEgressRequest
     * @instance
     */
    StartHLSEgressRequest.prototype.videoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * StartHLSEgressRequest address.
     * @member {string} address
     * @memberof StartHLSEgressRequest
     * @instance
     */
    StartHLSEgressRequest.prototype.address = "";

    /**
     * Creates a new StartHLSEgressRequest instance using the specified properties.
     * @function create
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest=} [properties] Properties to set
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest instance
     */
    StartHLSEgressRequest.create = function create(properties) {
        return new StartHLSEgressRequest(properties);
    };

    /**
     * Encodes the specified StartHLSEgressRequest message. Does not implicitly {@link StartHLSEgressRequest.verify|verify} messages.
     * @function encode
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest} message StartHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.videoId);
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
        return writer;
    };

    /**
     * Encodes the specified StartHLSEgressRequest message, length delimited. Does not implicitly {@link StartHLSEgressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSEgressRequest
     * @static
     * @param {IStartHLSEgressRequest} message StartHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSEgressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSEgressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.videoId = reader.uint64();
                break;
            case 2:
                message.address = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSEgressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSEgressRequest message.
     * @function verify
     * @memberof StartHLSEgressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSEgressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.videoId != null && message.hasOwnProperty("videoId"))
            if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
                return "videoId: integer|Long expected";
        if (message.address != null && message.hasOwnProperty("address"))
            if (!$util.isString(message.address))
                return "address: string expected";
        return null;
    };

    /**
     * Creates a StartHLSEgressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSEgressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSEgressRequest} StartHLSEgressRequest
     */
    StartHLSEgressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSEgressRequest)
            return object;
        let message = new $root.StartHLSEgressRequest();
        if (object.videoId != null)
            if ($util.Long)
                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
            else if (typeof object.videoId === "string")
                message.videoId = parseInt(object.videoId, 10);
            else if (typeof object.videoId === "number")
                message.videoId = object.videoId;
            else if (typeof object.videoId === "object")
                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
        if (object.address != null)
            message.address = String(object.address);
        return message;
    };

    /**
     * Creates a plain object from a StartHLSEgressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSEgressRequest
     * @static
     * @param {StartHLSEgressRequest} message StartHLSEgressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSEgressRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.videoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.videoId = options.longs === String ? "0" : 0;
            object.address = "";
        }
        if (message.videoId != null && message.hasOwnProperty("videoId"))
            if (typeof message.videoId === "number")
                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
            else
                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
        if (message.address != null && message.hasOwnProperty("address"))
            object.address = message.address;
        return object;
    };

    /**
     * Converts this StartHLSEgressRequest to JSON.
     * @function toJSON
     * @memberof StartHLSEgressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSEgressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSEgressRequest;
})();

export const StartHLSEgressResponse = $root.StartHLSEgressResponse = (() => {

    /**
     * Properties of a StartHLSEgressResponse.
     * @exports IStartHLSEgressResponse
     * @interface IStartHLSEgressResponse
     * @property {number|null} [id] StartHLSEgressResponse id
     * @property {string|null} [url] StartHLSEgressResponse url
     */

    /**
     * Constructs a new StartHLSEgressResponse.
     * @exports StartHLSEgressResponse
     * @classdesc Represents a StartHLSEgressResponse.
     * @implements IStartHLSEgressResponse
     * @constructor
     * @param {IStartHLSEgressResponse=} [properties] Properties to set
     */
    function StartHLSEgressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StartHLSEgressResponse id.
     * @member {number} id
     * @memberof StartHLSEgressResponse
     * @instance
     */
    StartHLSEgressResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * StartHLSEgressResponse url.
     * @member {string} url
     * @memberof StartHLSEgressResponse
     * @instance
     */
    StartHLSEgressResponse.prototype.url = "";

    /**
     * Creates a new StartHLSEgressResponse instance using the specified properties.
     * @function create
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse=} [properties] Properties to set
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse instance
     */
    StartHLSEgressResponse.create = function create(properties) {
        return new StartHLSEgressResponse(properties);
    };

    /**
     * Encodes the specified StartHLSEgressResponse message. Does not implicitly {@link StartHLSEgressResponse.verify|verify} messages.
     * @function encode
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse} message StartHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
        return writer;
    };

    /**
     * Encodes the specified StartHLSEgressResponse message, length delimited. Does not implicitly {@link StartHLSEgressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartHLSEgressResponse
     * @static
     * @param {IStartHLSEgressResponse} message StartHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartHLSEgressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartHLSEgressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartHLSEgressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.url = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartHLSEgressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartHLSEgressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartHLSEgressResponse message.
     * @function verify
     * @memberof StartHLSEgressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartHLSEgressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        return null;
    };

    /**
     * Creates a StartHLSEgressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartHLSEgressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartHLSEgressResponse} StartHLSEgressResponse
     */
    StartHLSEgressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartHLSEgressResponse)
            return object;
        let message = new $root.StartHLSEgressResponse();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.url != null)
            message.url = String(object.url);
        return message;
    };

    /**
     * Creates a plain object from a StartHLSEgressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartHLSEgressResponse
     * @static
     * @param {StartHLSEgressResponse} message StartHLSEgressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartHLSEgressResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.url = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        return object;
    };

    /**
     * Converts this StartHLSEgressResponse to JSON.
     * @function toJSON
     * @memberof StartHLSEgressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartHLSEgressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartHLSEgressResponse;
})();

export const StopHLSEgressRequest = $root.StopHLSEgressRequest = (() => {

    /**
     * Properties of a StopHLSEgressRequest.
     * @exports IStopHLSEgressRequest
     * @interface IStopHLSEgressRequest
     * @property {number|null} [id] StopHLSEgressRequest id
     */

    /**
     * Constructs a new StopHLSEgressRequest.
     * @exports StopHLSEgressRequest
     * @classdesc Represents a StopHLSEgressRequest.
     * @implements IStopHLSEgressRequest
     * @constructor
     * @param {IStopHLSEgressRequest=} [properties] Properties to set
     */
    function StopHLSEgressRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StopHLSEgressRequest id.
     * @member {number} id
     * @memberof StopHLSEgressRequest
     * @instance
     */
    StopHLSEgressRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new StopHLSEgressRequest instance using the specified properties.
     * @function create
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest=} [properties] Properties to set
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest instance
     */
    StopHLSEgressRequest.create = function create(properties) {
        return new StopHLSEgressRequest(properties);
    };

    /**
     * Encodes the specified StopHLSEgressRequest message. Does not implicitly {@link StopHLSEgressRequest.verify|verify} messages.
     * @function encode
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest} message StopHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified StopHLSEgressRequest message, length delimited. Does not implicitly {@link StopHLSEgressRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopHLSEgressRequest
     * @static
     * @param {IStopHLSEgressRequest} message StopHLSEgressRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopHLSEgressRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopHLSEgressRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopHLSEgressRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopHLSEgressRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopHLSEgressRequest message.
     * @function verify
     * @memberof StopHLSEgressRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopHLSEgressRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a StopHLSEgressRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopHLSEgressRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopHLSEgressRequest} StopHLSEgressRequest
     */
    StopHLSEgressRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopHLSEgressRequest)
            return object;
        let message = new $root.StopHLSEgressRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a StopHLSEgressRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopHLSEgressRequest
     * @static
     * @param {StopHLSEgressRequest} message StopHLSEgressRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopHLSEgressRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this StopHLSEgressRequest to JSON.
     * @function toJSON
     * @memberof StopHLSEgressRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopHLSEgressRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopHLSEgressRequest;
})();

export const StopHLSEgressResponse = $root.StopHLSEgressResponse = (() => {

    /**
     * Properties of a StopHLSEgressResponse.
     * @exports IStopHLSEgressResponse
     * @interface IStopHLSEgressResponse
     */

    /**
     * Constructs a new StopHLSEgressResponse.
     * @exports StopHLSEgressResponse
     * @classdesc Represents a StopHLSEgressResponse.
     * @implements IStopHLSEgressResponse
     * @constructor
     * @param {IStopHLSEgressResponse=} [properties] Properties to set
     */
    function StopHLSEgressResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopHLSEgressResponse instance using the specified properties.
     * @function create
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse=} [properties] Properties to set
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse instance
     */
    StopHLSEgressResponse.create = function create(properties) {
        return new StopHLSEgressResponse(properties);
    };

    /**
     * Encodes the specified StopHLSEgressResponse message. Does not implicitly {@link StopHLSEgressResponse.verify|verify} messages.
     * @function encode
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse} message StopHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopHLSEgressResponse message, length delimited. Does not implicitly {@link StopHLSEgressResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopHLSEgressResponse
     * @static
     * @param {IStopHLSEgressResponse} message StopHLSEgressResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopHLSEgressResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopHLSEgressResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopHLSEgressResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopHLSEgressResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopHLSEgressResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopHLSEgressResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopHLSEgressResponse message.
     * @function verify
     * @memberof StopHLSEgressResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopHLSEgressResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopHLSEgressResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopHLSEgressResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopHLSEgressResponse} StopHLSEgressResponse
     */
    StopHLSEgressResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopHLSEgressResponse)
            return object;
        return new $root.StopHLSEgressResponse();
    };

    /**
     * Creates a plain object from a StopHLSEgressResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopHLSEgressResponse
     * @static
     * @param {StopHLSEgressResponse} message StopHLSEgressResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopHLSEgressResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopHLSEgressResponse to JSON.
     * @function toJSON
     * @memberof StopHLSEgressResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopHLSEgressResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopHLSEgressResponse;
})();

export const StartSwarmRequest = $root.StartSwarmRequest = (() => {

    /**
     * Properties of a StartSwarmRequest.
     * @exports IStartSwarmRequest
     * @interface IStartSwarmRequest
     */

    /**
     * Constructs a new StartSwarmRequest.
     * @exports StartSwarmRequest
     * @classdesc Represents a StartSwarmRequest.
     * @implements IStartSwarmRequest
     * @constructor
     * @param {IStartSwarmRequest=} [properties] Properties to set
     */
    function StartSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartSwarmRequest instance using the specified properties.
     * @function create
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest=} [properties] Properties to set
     * @returns {StartSwarmRequest} StartSwarmRequest instance
     */
    StartSwarmRequest.create = function create(properties) {
        return new StartSwarmRequest(properties);
    };

    /**
     * Encodes the specified StartSwarmRequest message. Does not implicitly {@link StartSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest} message StartSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartSwarmRequest message, length delimited. Does not implicitly {@link StartSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartSwarmRequest
     * @static
     * @param {IStartSwarmRequest} message StartSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartSwarmRequest} StartSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartSwarmRequest} StartSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartSwarmRequest message.
     * @function verify
     * @memberof StartSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartSwarmRequest} StartSwarmRequest
     */
    StartSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartSwarmRequest)
            return object;
        return new $root.StartSwarmRequest();
    };

    /**
     * Creates a plain object from a StartSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartSwarmRequest
     * @static
     * @param {StartSwarmRequest} message StartSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartSwarmRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartSwarmRequest to JSON.
     * @function toJSON
     * @memberof StartSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartSwarmRequest;
})();

export const StartSwarmResponse = $root.StartSwarmResponse = (() => {

    /**
     * Properties of a StartSwarmResponse.
     * @exports IStartSwarmResponse
     * @interface IStartSwarmResponse
     * @property {number|null} [id] StartSwarmResponse id
     */

    /**
     * Constructs a new StartSwarmResponse.
     * @exports StartSwarmResponse
     * @classdesc Represents a StartSwarmResponse.
     * @implements IStartSwarmResponse
     * @constructor
     * @param {IStartSwarmResponse=} [properties] Properties to set
     */
    function StartSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StartSwarmResponse id.
     * @member {number} id
     * @memberof StartSwarmResponse
     * @instance
     */
    StartSwarmResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new StartSwarmResponse instance using the specified properties.
     * @function create
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse=} [properties] Properties to set
     * @returns {StartSwarmResponse} StartSwarmResponse instance
     */
    StartSwarmResponse.create = function create(properties) {
        return new StartSwarmResponse(properties);
    };

    /**
     * Encodes the specified StartSwarmResponse message. Does not implicitly {@link StartSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse} message StartSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified StartSwarmResponse message, length delimited. Does not implicitly {@link StartSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartSwarmResponse
     * @static
     * @param {IStartSwarmResponse} message StartSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartSwarmResponse} StartSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartSwarmResponse} StartSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartSwarmResponse message.
     * @function verify
     * @memberof StartSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a StartSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartSwarmResponse} StartSwarmResponse
     */
    StartSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartSwarmResponse)
            return object;
        let message = new $root.StartSwarmResponse();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a StartSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartSwarmResponse
     * @static
     * @param {StartSwarmResponse} message StartSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartSwarmResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this StartSwarmResponse to JSON.
     * @function toJSON
     * @memberof StartSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartSwarmResponse;
})();

export const WriteToSwarmRequest = $root.WriteToSwarmRequest = (() => {

    /**
     * Properties of a WriteToSwarmRequest.
     * @exports IWriteToSwarmRequest
     * @interface IWriteToSwarmRequest
     * @property {number|null} [id] WriteToSwarmRequest id
     * @property {Uint8Array|null} [data] WriteToSwarmRequest data
     */

    /**
     * Constructs a new WriteToSwarmRequest.
     * @exports WriteToSwarmRequest
     * @classdesc Represents a WriteToSwarmRequest.
     * @implements IWriteToSwarmRequest
     * @constructor
     * @param {IWriteToSwarmRequest=} [properties] Properties to set
     */
    function WriteToSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WriteToSwarmRequest id.
     * @member {number} id
     * @memberof WriteToSwarmRequest
     * @instance
     */
    WriteToSwarmRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * WriteToSwarmRequest data.
     * @member {Uint8Array} data
     * @memberof WriteToSwarmRequest
     * @instance
     */
    WriteToSwarmRequest.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new WriteToSwarmRequest instance using the specified properties.
     * @function create
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest=} [properties] Properties to set
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest instance
     */
    WriteToSwarmRequest.create = function create(properties) {
        return new WriteToSwarmRequest(properties);
    };

    /**
     * Encodes the specified WriteToSwarmRequest message. Does not implicitly {@link WriteToSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest} message WriteToSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified WriteToSwarmRequest message, length delimited. Does not implicitly {@link WriteToSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToSwarmRequest
     * @static
     * @param {IWriteToSwarmRequest} message WriteToSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToSwarmRequest message.
     * @function verify
     * @memberof WriteToSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a WriteToSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToSwarmRequest} WriteToSwarmRequest
     */
    WriteToSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToSwarmRequest)
            return object;
        let message = new $root.WriteToSwarmRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a WriteToSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToSwarmRequest
     * @static
     * @param {WriteToSwarmRequest} message WriteToSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this WriteToSwarmRequest to JSON.
     * @function toJSON
     * @memberof WriteToSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToSwarmRequest;
})();

export const WriteToSwarmResponse = $root.WriteToSwarmResponse = (() => {

    /**
     * Properties of a WriteToSwarmResponse.
     * @exports IWriteToSwarmResponse
     * @interface IWriteToSwarmResponse
     * @property {string|null} [error] WriteToSwarmResponse error
     */

    /**
     * Constructs a new WriteToSwarmResponse.
     * @exports WriteToSwarmResponse
     * @classdesc Represents a WriteToSwarmResponse.
     * @implements IWriteToSwarmResponse
     * @constructor
     * @param {IWriteToSwarmResponse=} [properties] Properties to set
     */
    function WriteToSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WriteToSwarmResponse error.
     * @member {string} error
     * @memberof WriteToSwarmResponse
     * @instance
     */
    WriteToSwarmResponse.prototype.error = "";

    /**
     * Creates a new WriteToSwarmResponse instance using the specified properties.
     * @function create
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse=} [properties] Properties to set
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse instance
     */
    WriteToSwarmResponse.create = function create(properties) {
        return new WriteToSwarmResponse(properties);
    };

    /**
     * Encodes the specified WriteToSwarmResponse message. Does not implicitly {@link WriteToSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse} message WriteToSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
        return writer;
    };

    /**
     * Encodes the specified WriteToSwarmResponse message, length delimited. Does not implicitly {@link WriteToSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToSwarmResponse
     * @static
     * @param {IWriteToSwarmResponse} message WriteToSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.error = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToSwarmResponse message.
     * @function verify
     * @memberof WriteToSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.error != null && message.hasOwnProperty("error"))
            if (!$util.isString(message.error))
                return "error: string expected";
        return null;
    };

    /**
     * Creates a WriteToSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToSwarmResponse} WriteToSwarmResponse
     */
    WriteToSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToSwarmResponse)
            return object;
        let message = new $root.WriteToSwarmResponse();
        if (object.error != null)
            message.error = String(object.error);
        return message;
    };

    /**
     * Creates a plain object from a WriteToSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToSwarmResponse
     * @static
     * @param {WriteToSwarmResponse} message WriteToSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToSwarmResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.error = "";
        if (message.error != null && message.hasOwnProperty("error"))
            object.error = message.error;
        return object;
    };

    /**
     * Converts this WriteToSwarmResponse to JSON.
     * @function toJSON
     * @memberof WriteToSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToSwarmResponse;
})();

export const StopSwarmRequest = $root.StopSwarmRequest = (() => {

    /**
     * Properties of a StopSwarmRequest.
     * @exports IStopSwarmRequest
     * @interface IStopSwarmRequest
     * @property {number|null} [id] StopSwarmRequest id
     */

    /**
     * Constructs a new StopSwarmRequest.
     * @exports StopSwarmRequest
     * @classdesc Represents a StopSwarmRequest.
     * @implements IStopSwarmRequest
     * @constructor
     * @param {IStopSwarmRequest=} [properties] Properties to set
     */
    function StopSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StopSwarmRequest id.
     * @member {number} id
     * @memberof StopSwarmRequest
     * @instance
     */
    StopSwarmRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new StopSwarmRequest instance using the specified properties.
     * @function create
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest=} [properties] Properties to set
     * @returns {StopSwarmRequest} StopSwarmRequest instance
     */
    StopSwarmRequest.create = function create(properties) {
        return new StopSwarmRequest(properties);
    };

    /**
     * Encodes the specified StopSwarmRequest message. Does not implicitly {@link StopSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest} message StopSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified StopSwarmRequest message, length delimited. Does not implicitly {@link StopSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopSwarmRequest
     * @static
     * @param {IStopSwarmRequest} message StopSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopSwarmRequest} StopSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopSwarmRequest} StopSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopSwarmRequest message.
     * @function verify
     * @memberof StopSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a StopSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopSwarmRequest} StopSwarmRequest
     */
    StopSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopSwarmRequest)
            return object;
        let message = new $root.StopSwarmRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a StopSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopSwarmRequest
     * @static
     * @param {StopSwarmRequest} message StopSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this StopSwarmRequest to JSON.
     * @function toJSON
     * @memberof StopSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopSwarmRequest;
})();

export const StopSwarmResponse = $root.StopSwarmResponse = (() => {

    /**
     * Properties of a StopSwarmResponse.
     * @exports IStopSwarmResponse
     * @interface IStopSwarmResponse
     */

    /**
     * Constructs a new StopSwarmResponse.
     * @exports StopSwarmResponse
     * @classdesc Represents a StopSwarmResponse.
     * @implements IStopSwarmResponse
     * @constructor
     * @param {IStopSwarmResponse=} [properties] Properties to set
     */
    function StopSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopSwarmResponse instance using the specified properties.
     * @function create
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse=} [properties] Properties to set
     * @returns {StopSwarmResponse} StopSwarmResponse instance
     */
    StopSwarmResponse.create = function create(properties) {
        return new StopSwarmResponse(properties);
    };

    /**
     * Encodes the specified StopSwarmResponse message. Does not implicitly {@link StopSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse} message StopSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopSwarmResponse message, length delimited. Does not implicitly {@link StopSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopSwarmResponse
     * @static
     * @param {IStopSwarmResponse} message StopSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopSwarmResponse} StopSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopSwarmResponse} StopSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopSwarmResponse message.
     * @function verify
     * @memberof StopSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopSwarmResponse} StopSwarmResponse
     */
    StopSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopSwarmResponse)
            return object;
        return new $root.StopSwarmResponse();
    };

    /**
     * Creates a plain object from a StopSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopSwarmResponse
     * @static
     * @param {StopSwarmResponse} message StopSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopSwarmResponse to JSON.
     * @function toJSON
     * @memberof StopSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopSwarmResponse;
})();

export const PublishSwarmRequest = $root.PublishSwarmRequest = (() => {

    /**
     * Properties of a PublishSwarmRequest.
     * @exports IPublishSwarmRequest
     * @interface IPublishSwarmRequest
     * @property {number|null} [id] PublishSwarmRequest id
     * @property {Uint8Array|null} [networkKey] PublishSwarmRequest networkKey
     */

    /**
     * Constructs a new PublishSwarmRequest.
     * @exports PublishSwarmRequest
     * @classdesc Represents a PublishSwarmRequest.
     * @implements IPublishSwarmRequest
     * @constructor
     * @param {IPublishSwarmRequest=} [properties] Properties to set
     */
    function PublishSwarmRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PublishSwarmRequest id.
     * @member {number} id
     * @memberof PublishSwarmRequest
     * @instance
     */
    PublishSwarmRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * PublishSwarmRequest networkKey.
     * @member {Uint8Array} networkKey
     * @memberof PublishSwarmRequest
     * @instance
     */
    PublishSwarmRequest.prototype.networkKey = $util.newBuffer([]);

    /**
     * Creates a new PublishSwarmRequest instance using the specified properties.
     * @function create
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest=} [properties] Properties to set
     * @returns {PublishSwarmRequest} PublishSwarmRequest instance
     */
    PublishSwarmRequest.create = function create(properties) {
        return new PublishSwarmRequest(properties);
    };

    /**
     * Encodes the specified PublishSwarmRequest message. Does not implicitly {@link PublishSwarmRequest.verify|verify} messages.
     * @function encode
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest} message PublishSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
        return writer;
    };

    /**
     * Encodes the specified PublishSwarmRequest message, length delimited. Does not implicitly {@link PublishSwarmRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishSwarmRequest
     * @static
     * @param {IPublishSwarmRequest} message PublishSwarmRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishSwarmRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PublishSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishSwarmRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.networkKey = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishSwarmRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishSwarmRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishSwarmRequest message.
     * @function verify
     * @memberof PublishSwarmRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishSwarmRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                return "networkKey: buffer expected";
        return null;
    };

    /**
     * Creates a PublishSwarmRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishSwarmRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishSwarmRequest} PublishSwarmRequest
     */
    PublishSwarmRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishSwarmRequest)
            return object;
        let message = new $root.PublishSwarmRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.networkKey != null)
            if (typeof object.networkKey === "string")
                $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
            else if (object.networkKey.length)
                message.networkKey = object.networkKey;
        return message;
    };

    /**
     * Creates a plain object from a PublishSwarmRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishSwarmRequest
     * @static
     * @param {PublishSwarmRequest} message PublishSwarmRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishSwarmRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.networkKey = "";
            else {
                object.networkKey = [];
                if (options.bytes !== Array)
                    object.networkKey = $util.newBuffer(object.networkKey);
            }
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.networkKey != null && message.hasOwnProperty("networkKey"))
            object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
        return object;
    };

    /**
     * Converts this PublishSwarmRequest to JSON.
     * @function toJSON
     * @memberof PublishSwarmRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishSwarmRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishSwarmRequest;
})();

export const PublishSwarmResponse = $root.PublishSwarmResponse = (() => {

    /**
     * Properties of a PublishSwarmResponse.
     * @exports IPublishSwarmResponse
     * @interface IPublishSwarmResponse
     */

    /**
     * Constructs a new PublishSwarmResponse.
     * @exports PublishSwarmResponse
     * @classdesc Represents a PublishSwarmResponse.
     * @implements IPublishSwarmResponse
     * @constructor
     * @param {IPublishSwarmResponse=} [properties] Properties to set
     */
    function PublishSwarmResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new PublishSwarmResponse instance using the specified properties.
     * @function create
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse=} [properties] Properties to set
     * @returns {PublishSwarmResponse} PublishSwarmResponse instance
     */
    PublishSwarmResponse.create = function create(properties) {
        return new PublishSwarmResponse(properties);
    };

    /**
     * Encodes the specified PublishSwarmResponse message. Does not implicitly {@link PublishSwarmResponse.verify|verify} messages.
     * @function encode
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse} message PublishSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified PublishSwarmResponse message, length delimited. Does not implicitly {@link PublishSwarmResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishSwarmResponse
     * @static
     * @param {IPublishSwarmResponse} message PublishSwarmResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishSwarmResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishSwarmResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PublishSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishSwarmResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishSwarmResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishSwarmResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishSwarmResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishSwarmResponse message.
     * @function verify
     * @memberof PublishSwarmResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishSwarmResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a PublishSwarmResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishSwarmResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishSwarmResponse} PublishSwarmResponse
     */
    PublishSwarmResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishSwarmResponse)
            return object;
        return new $root.PublishSwarmResponse();
    };

    /**
     * Creates a plain object from a PublishSwarmResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishSwarmResponse
     * @static
     * @param {PublishSwarmResponse} message PublishSwarmResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishSwarmResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this PublishSwarmResponse to JSON.
     * @function toJSON
     * @memberof PublishSwarmResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishSwarmResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishSwarmResponse;
})();

export const OpenVideoServerRequest = $root.OpenVideoServerRequest = (() => {

    /**
     * Properties of an OpenVideoServerRequest.
     * @exports IOpenVideoServerRequest
     * @interface IOpenVideoServerRequest
     */

    /**
     * Constructs a new OpenVideoServerRequest.
     * @exports OpenVideoServerRequest
     * @classdesc Represents an OpenVideoServerRequest.
     * @implements IOpenVideoServerRequest
     * @constructor
     * @param {IOpenVideoServerRequest=} [properties] Properties to set
     */
    function OpenVideoServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new OpenVideoServerRequest instance using the specified properties.
     * @function create
     * @memberof OpenVideoServerRequest
     * @static
     * @param {IOpenVideoServerRequest=} [properties] Properties to set
     * @returns {OpenVideoServerRequest} OpenVideoServerRequest instance
     */
    OpenVideoServerRequest.create = function create(properties) {
        return new OpenVideoServerRequest(properties);
    };

    /**
     * Encodes the specified OpenVideoServerRequest message. Does not implicitly {@link OpenVideoServerRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenVideoServerRequest
     * @static
     * @param {IOpenVideoServerRequest} message OpenVideoServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenVideoServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified OpenVideoServerRequest message, length delimited. Does not implicitly {@link OpenVideoServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenVideoServerRequest
     * @static
     * @param {IOpenVideoServerRequest} message OpenVideoServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenVideoServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenVideoServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenVideoServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenVideoServerRequest} OpenVideoServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenVideoServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenVideoServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenVideoServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenVideoServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenVideoServerRequest} OpenVideoServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenVideoServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenVideoServerRequest message.
     * @function verify
     * @memberof OpenVideoServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenVideoServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an OpenVideoServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenVideoServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenVideoServerRequest} OpenVideoServerRequest
     */
    OpenVideoServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenVideoServerRequest)
            return object;
        return new $root.OpenVideoServerRequest();
    };

    /**
     * Creates a plain object from an OpenVideoServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenVideoServerRequest
     * @static
     * @param {OpenVideoServerRequest} message OpenVideoServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenVideoServerRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this OpenVideoServerRequest to JSON.
     * @function toJSON
     * @memberof OpenVideoServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenVideoServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OpenVideoServerRequest;
})();

export const VideoServerOpenResponse = $root.VideoServerOpenResponse = (() => {

    /**
     * Properties of a VideoServerOpenResponse.
     * @exports IVideoServerOpenResponse
     * @interface IVideoServerOpenResponse
     * @property {number|null} [id] VideoServerOpenResponse id
     */

    /**
     * Constructs a new VideoServerOpenResponse.
     * @exports VideoServerOpenResponse
     * @classdesc Represents a VideoServerOpenResponse.
     * @implements IVideoServerOpenResponse
     * @constructor
     * @param {IVideoServerOpenResponse=} [properties] Properties to set
     */
    function VideoServerOpenResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoServerOpenResponse id.
     * @member {number} id
     * @memberof VideoServerOpenResponse
     * @instance
     */
    VideoServerOpenResponse.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new VideoServerOpenResponse instance using the specified properties.
     * @function create
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse=} [properties] Properties to set
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse instance
     */
    VideoServerOpenResponse.create = function create(properties) {
        return new VideoServerOpenResponse(properties);
    };

    /**
     * Encodes the specified VideoServerOpenResponse message. Does not implicitly {@link VideoServerOpenResponse.verify|verify} messages.
     * @function encode
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse} message VideoServerOpenResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified VideoServerOpenResponse message, length delimited. Does not implicitly {@link VideoServerOpenResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoServerOpenResponse
     * @static
     * @param {IVideoServerOpenResponse} message VideoServerOpenResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoServerOpenResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoServerOpenResponse message from the specified reader or buffer.
     * @function decode
     * @memberof VideoServerOpenResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoServerOpenResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoServerOpenResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoServerOpenResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoServerOpenResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoServerOpenResponse message.
     * @function verify
     * @memberof VideoServerOpenResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoServerOpenResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a VideoServerOpenResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoServerOpenResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoServerOpenResponse} VideoServerOpenResponse
     */
    VideoServerOpenResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoServerOpenResponse)
            return object;
        let message = new $root.VideoServerOpenResponse();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a VideoServerOpenResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoServerOpenResponse
     * @static
     * @param {VideoServerOpenResponse} message VideoServerOpenResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoServerOpenResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this VideoServerOpenResponse to JSON.
     * @function toJSON
     * @memberof VideoServerOpenResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoServerOpenResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoServerOpenResponse;
})();

export const WriteToVideoServerRequest = $root.WriteToVideoServerRequest = (() => {

    /**
     * Properties of a WriteToVideoServerRequest.
     * @exports IWriteToVideoServerRequest
     * @interface IWriteToVideoServerRequest
     * @property {number|null} [id] WriteToVideoServerRequest id
     * @property {Uint8Array|null} [data] WriteToVideoServerRequest data
     * @property {boolean|null} [flush] WriteToVideoServerRequest flush
     */

    /**
     * Constructs a new WriteToVideoServerRequest.
     * @exports WriteToVideoServerRequest
     * @classdesc Represents a WriteToVideoServerRequest.
     * @implements IWriteToVideoServerRequest
     * @constructor
     * @param {IWriteToVideoServerRequest=} [properties] Properties to set
     */
    function WriteToVideoServerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WriteToVideoServerRequest id.
     * @member {number} id
     * @memberof WriteToVideoServerRequest
     * @instance
     */
    WriteToVideoServerRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * WriteToVideoServerRequest data.
     * @member {Uint8Array} data
     * @memberof WriteToVideoServerRequest
     * @instance
     */
    WriteToVideoServerRequest.prototype.data = $util.newBuffer([]);

    /**
     * WriteToVideoServerRequest flush.
     * @member {boolean} flush
     * @memberof WriteToVideoServerRequest
     * @instance
     */
    WriteToVideoServerRequest.prototype.flush = false;

    /**
     * Creates a new WriteToVideoServerRequest instance using the specified properties.
     * @function create
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {IWriteToVideoServerRequest=} [properties] Properties to set
     * @returns {WriteToVideoServerRequest} WriteToVideoServerRequest instance
     */
    WriteToVideoServerRequest.create = function create(properties) {
        return new WriteToVideoServerRequest(properties);
    };

    /**
     * Encodes the specified WriteToVideoServerRequest message. Does not implicitly {@link WriteToVideoServerRequest.verify|verify} messages.
     * @function encode
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {IWriteToVideoServerRequest} message WriteToVideoServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToVideoServerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.flush);
        return writer;
    };

    /**
     * Encodes the specified WriteToVideoServerRequest message, length delimited. Does not implicitly {@link WriteToVideoServerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {IWriteToVideoServerRequest} message WriteToVideoServerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToVideoServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToVideoServerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToVideoServerRequest} WriteToVideoServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToVideoServerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToVideoServerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            case 3:
                message.flush = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToVideoServerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToVideoServerRequest} WriteToVideoServerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToVideoServerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToVideoServerRequest message.
     * @function verify
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToVideoServerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        if (message.flush != null && message.hasOwnProperty("flush"))
            if (typeof message.flush !== "boolean")
                return "flush: boolean expected";
        return null;
    };

    /**
     * Creates a WriteToVideoServerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToVideoServerRequest} WriteToVideoServerRequest
     */
    WriteToVideoServerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToVideoServerRequest)
            return object;
        let message = new $root.WriteToVideoServerRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        if (object.flush != null)
            message.flush = Boolean(object.flush);
        return message;
    };

    /**
     * Creates a plain object from a WriteToVideoServerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToVideoServerRequest
     * @static
     * @param {WriteToVideoServerRequest} message WriteToVideoServerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToVideoServerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
            object.flush = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        if (message.flush != null && message.hasOwnProperty("flush"))
            object.flush = message.flush;
        return object;
    };

    /**
     * Converts this WriteToVideoServerRequest to JSON.
     * @function toJSON
     * @memberof WriteToVideoServerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToVideoServerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToVideoServerRequest;
})();

export const WriteToVideoServerResponse = $root.WriteToVideoServerResponse = (() => {

    /**
     * Properties of a WriteToVideoServerResponse.
     * @exports IWriteToVideoServerResponse
     * @interface IWriteToVideoServerResponse
     */

    /**
     * Constructs a new WriteToVideoServerResponse.
     * @exports WriteToVideoServerResponse
     * @classdesc Represents a WriteToVideoServerResponse.
     * @implements IWriteToVideoServerResponse
     * @constructor
     * @param {IWriteToVideoServerResponse=} [properties] Properties to set
     */
    function WriteToVideoServerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new WriteToVideoServerResponse instance using the specified properties.
     * @function create
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {IWriteToVideoServerResponse=} [properties] Properties to set
     * @returns {WriteToVideoServerResponse} WriteToVideoServerResponse instance
     */
    WriteToVideoServerResponse.create = function create(properties) {
        return new WriteToVideoServerResponse(properties);
    };

    /**
     * Encodes the specified WriteToVideoServerResponse message. Does not implicitly {@link WriteToVideoServerResponse.verify|verify} messages.
     * @function encode
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {IWriteToVideoServerResponse} message WriteToVideoServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToVideoServerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified WriteToVideoServerResponse message, length delimited. Does not implicitly {@link WriteToVideoServerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {IWriteToVideoServerResponse} message WriteToVideoServerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WriteToVideoServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WriteToVideoServerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WriteToVideoServerResponse} WriteToVideoServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToVideoServerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WriteToVideoServerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WriteToVideoServerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WriteToVideoServerResponse} WriteToVideoServerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WriteToVideoServerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WriteToVideoServerResponse message.
     * @function verify
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WriteToVideoServerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a WriteToVideoServerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WriteToVideoServerResponse} WriteToVideoServerResponse
     */
    WriteToVideoServerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.WriteToVideoServerResponse)
            return object;
        return new $root.WriteToVideoServerResponse();
    };

    /**
     * Creates a plain object from a WriteToVideoServerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WriteToVideoServerResponse
     * @static
     * @param {WriteToVideoServerResponse} message WriteToVideoServerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WriteToVideoServerResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this WriteToVideoServerResponse to JSON.
     * @function toJSON
     * @memberof WriteToVideoServerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WriteToVideoServerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WriteToVideoServerResponse;
})();

export const OpenVideoClientRequest = $root.OpenVideoClientRequest = (() => {

    /**
     * Properties of an OpenVideoClientRequest.
     * @exports IOpenVideoClientRequest
     * @interface IOpenVideoClientRequest
     * @property {Uint8Array|null} [swarmKey] OpenVideoClientRequest swarmKey
     * @property {boolean|null} [emitData] OpenVideoClientRequest emitData
     */

    /**
     * Constructs a new OpenVideoClientRequest.
     * @exports OpenVideoClientRequest
     * @classdesc Represents an OpenVideoClientRequest.
     * @implements IOpenVideoClientRequest
     * @constructor
     * @param {IOpenVideoClientRequest=} [properties] Properties to set
     */
    function OpenVideoClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenVideoClientRequest swarmKey.
     * @member {Uint8Array} swarmKey
     * @memberof OpenVideoClientRequest
     * @instance
     */
    OpenVideoClientRequest.prototype.swarmKey = $util.newBuffer([]);

    /**
     * OpenVideoClientRequest emitData.
     * @member {boolean} emitData
     * @memberof OpenVideoClientRequest
     * @instance
     */
    OpenVideoClientRequest.prototype.emitData = false;

    /**
     * Creates a new OpenVideoClientRequest instance using the specified properties.
     * @function create
     * @memberof OpenVideoClientRequest
     * @static
     * @param {IOpenVideoClientRequest=} [properties] Properties to set
     * @returns {OpenVideoClientRequest} OpenVideoClientRequest instance
     */
    OpenVideoClientRequest.create = function create(properties) {
        return new OpenVideoClientRequest(properties);
    };

    /**
     * Encodes the specified OpenVideoClientRequest message. Does not implicitly {@link OpenVideoClientRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenVideoClientRequest
     * @static
     * @param {IOpenVideoClientRequest} message OpenVideoClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenVideoClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.swarmKey != null && Object.hasOwnProperty.call(message, "swarmKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swarmKey);
        if (message.emitData != null && Object.hasOwnProperty.call(message, "emitData"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.emitData);
        return writer;
    };

    /**
     * Encodes the specified OpenVideoClientRequest message, length delimited. Does not implicitly {@link OpenVideoClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenVideoClientRequest
     * @static
     * @param {IOpenVideoClientRequest} message OpenVideoClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenVideoClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenVideoClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenVideoClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenVideoClientRequest} OpenVideoClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenVideoClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenVideoClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.swarmKey = reader.bytes();
                break;
            case 2:
                message.emitData = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenVideoClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenVideoClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenVideoClientRequest} OpenVideoClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenVideoClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenVideoClientRequest message.
     * @function verify
     * @memberof OpenVideoClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenVideoClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.swarmKey != null && message.hasOwnProperty("swarmKey"))
            if (!(message.swarmKey && typeof message.swarmKey.length === "number" || $util.isString(message.swarmKey)))
                return "swarmKey: buffer expected";
        if (message.emitData != null && message.hasOwnProperty("emitData"))
            if (typeof message.emitData !== "boolean")
                return "emitData: boolean expected";
        return null;
    };

    /**
     * Creates an OpenVideoClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenVideoClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenVideoClientRequest} OpenVideoClientRequest
     */
    OpenVideoClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenVideoClientRequest)
            return object;
        let message = new $root.OpenVideoClientRequest();
        if (object.swarmKey != null)
            if (typeof object.swarmKey === "string")
                $util.base64.decode(object.swarmKey, message.swarmKey = $util.newBuffer($util.base64.length(object.swarmKey)), 0);
            else if (object.swarmKey.length)
                message.swarmKey = object.swarmKey;
        if (object.emitData != null)
            message.emitData = Boolean(object.emitData);
        return message;
    };

    /**
     * Creates a plain object from an OpenVideoClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenVideoClientRequest
     * @static
     * @param {OpenVideoClientRequest} message OpenVideoClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenVideoClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.swarmKey = "";
            else {
                object.swarmKey = [];
                if (options.bytes !== Array)
                    object.swarmKey = $util.newBuffer(object.swarmKey);
            }
            object.emitData = false;
        }
        if (message.swarmKey != null && message.hasOwnProperty("swarmKey"))
            object.swarmKey = options.bytes === String ? $util.base64.encode(message.swarmKey, 0, message.swarmKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.swarmKey) : message.swarmKey;
        if (message.emitData != null && message.hasOwnProperty("emitData"))
            object.emitData = message.emitData;
        return object;
    };

    /**
     * Converts this OpenVideoClientRequest to JSON.
     * @function toJSON
     * @memberof OpenVideoClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenVideoClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OpenVideoClientRequest;
})();

export const VideoClientEvent = $root.VideoClientEvent = (() => {

    /**
     * Properties of a VideoClientEvent.
     * @exports IVideoClientEvent
     * @interface IVideoClientEvent
     * @property {VideoClientEvent.IData|null} [data] VideoClientEvent data
     * @property {VideoClientEvent.IOpen|null} [open] VideoClientEvent open
     * @property {VideoClientEvent.IClose|null} [close] VideoClientEvent close
     */

    /**
     * Constructs a new VideoClientEvent.
     * @exports VideoClientEvent
     * @classdesc Represents a VideoClientEvent.
     * @implements IVideoClientEvent
     * @constructor
     * @param {IVideoClientEvent=} [properties] Properties to set
     */
    function VideoClientEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoClientEvent data.
     * @member {VideoClientEvent.IData|null|undefined} data
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.data = null;

    /**
     * VideoClientEvent open.
     * @member {VideoClientEvent.IOpen|null|undefined} open
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.open = null;

    /**
     * VideoClientEvent close.
     * @member {VideoClientEvent.IClose|null|undefined} close
     * @memberof VideoClientEvent
     * @instance
     */
    VideoClientEvent.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * VideoClientEvent body.
     * @member {"data"|"open"|"close"|undefined} body
     * @memberof VideoClientEvent
     * @instance
     */
    Object.defineProperty(VideoClientEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["data", "open", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new VideoClientEvent instance using the specified properties.
     * @function create
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent=} [properties] Properties to set
     * @returns {VideoClientEvent} VideoClientEvent instance
     */
    VideoClientEvent.create = function create(properties) {
        return new VideoClientEvent(properties);
    };

    /**
     * Encodes the specified VideoClientEvent message. Does not implicitly {@link VideoClientEvent.verify|verify} messages.
     * @function encode
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent} message VideoClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.VideoClientEvent.Data.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.VideoClientEvent.Open.encode(message.open, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.VideoClientEvent.Close.encode(message.close, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VideoClientEvent message, length delimited. Does not implicitly {@link VideoClientEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoClientEvent
     * @static
     * @param {IVideoClientEvent} message VideoClientEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoClientEvent message from the specified reader or buffer.
     * @function decode
     * @memberof VideoClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoClientEvent} VideoClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = $root.VideoClientEvent.Data.decode(reader, reader.uint32());
                break;
            case 2:
                message.open = $root.VideoClientEvent.Open.decode(reader, reader.uint32());
                break;
            case 3:
                message.close = $root.VideoClientEvent.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoClientEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoClientEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoClientEvent} VideoClientEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoClientEvent message.
     * @function verify
     * @memberof VideoClientEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoClientEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.data != null && message.hasOwnProperty("data")) {
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientEvent.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VideoClientEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoClientEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoClientEvent} VideoClientEvent
     */
    VideoClientEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoClientEvent)
            return object;
        let message = new $root.VideoClientEvent();
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".VideoClientEvent.data: object expected");
            message.data = $root.VideoClientEvent.Data.fromObject(object.data);
        }
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".VideoClientEvent.open: object expected");
            message.open = $root.VideoClientEvent.Open.fromObject(object.open);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".VideoClientEvent.close: object expected");
            message.close = $root.VideoClientEvent.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a VideoClientEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoClientEvent
     * @static
     * @param {VideoClientEvent} message VideoClientEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoClientEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.VideoClientEvent.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.VideoClientEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.VideoClientEvent.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this VideoClientEvent to JSON.
     * @function toJSON
     * @memberof VideoClientEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoClientEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    VideoClientEvent.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof VideoClientEvent
         * @interface IData
         * @property {Uint8Array|null} [data] Data data
         * @property {boolean|null} [flush] Data flush
         */

        /**
         * Constructs a new Data.
         * @memberof VideoClientEvent
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {VideoClientEvent.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data data.
         * @member {Uint8Array} data
         * @memberof VideoClientEvent.Data
         * @instance
         */
        Data.prototype.data = $util.newBuffer([]);

        /**
         * Data flush.
         * @member {boolean} flush
         * @memberof VideoClientEvent.Data
         * @instance
         */
        Data.prototype.flush = false;

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData=} [properties] Properties to set
         * @returns {VideoClientEvent.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link VideoClientEvent.Data.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.flush);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link VideoClientEvent.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.flush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof VideoClientEvent.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.flush != null && message.hasOwnProperty("flush"))
                if (typeof message.flush !== "boolean")
                    return "flush: boolean expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Data)
                return object;
            let message = new $root.VideoClientEvent.Data();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.flush != null)
                message.flush = Boolean(object.flush);
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Data
         * @static
         * @param {VideoClientEvent.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.flush = false;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.flush != null && message.hasOwnProperty("flush"))
                object.flush = message.flush;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    VideoClientEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof VideoClientEvent
         * @interface IOpen
         * @property {number|null} [id] Open id
         */

        /**
         * Constructs a new Open.
         * @memberof VideoClientEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {VideoClientEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open id.
         * @member {number} id
         * @memberof VideoClientEvent.Open
         * @instance
         */
        Open.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen=} [properties] Properties to set
         * @returns {VideoClientEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link VideoClientEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link VideoClientEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof VideoClientEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Open)
                return object;
            let message = new $root.VideoClientEvent.Open();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Open
         * @static
         * @param {VideoClientEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    VideoClientEvent.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof VideoClientEvent
         * @interface IClose
         */

        /**
         * Constructs a new Close.
         * @memberof VideoClientEvent
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {VideoClientEvent.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose=} [properties] Properties to set
         * @returns {VideoClientEvent.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link VideoClientEvent.Close.verify|verify} messages.
         * @function encode
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link VideoClientEvent.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientEvent.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientEvent.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientEvent.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof VideoClientEvent.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientEvent.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientEvent.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientEvent.Close)
                return object;
            return new $root.VideoClientEvent.Close();
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientEvent.Close
         * @static
         * @param {VideoClientEvent.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof VideoClientEvent.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return VideoClientEvent;
})();

export const VideoClientCallRequest = $root.VideoClientCallRequest = (() => {

    /**
     * Properties of a VideoClientCallRequest.
     * @exports IVideoClientCallRequest
     * @interface IVideoClientCallRequest
     * @property {number|null} [id] VideoClientCallRequest id
     * @property {VideoClientCallRequest.IData|null} [data] VideoClientCallRequest data
     * @property {VideoClientCallRequest.IRunClient|null} [runClient] VideoClientCallRequest runClient
     * @property {VideoClientCallRequest.IRunServer|null} [runServer] VideoClientCallRequest runServer
     */

    /**
     * Constructs a new VideoClientCallRequest.
     * @exports VideoClientCallRequest
     * @classdesc Represents a VideoClientCallRequest.
     * @implements IVideoClientCallRequest
     * @constructor
     * @param {IVideoClientCallRequest=} [properties] Properties to set
     */
    function VideoClientCallRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoClientCallRequest id.
     * @member {number} id
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.id = 0;

    /**
     * VideoClientCallRequest data.
     * @member {VideoClientCallRequest.IData|null|undefined} data
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.data = null;

    /**
     * VideoClientCallRequest runClient.
     * @member {VideoClientCallRequest.IRunClient|null|undefined} runClient
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.runClient = null;

    /**
     * VideoClientCallRequest runServer.
     * @member {VideoClientCallRequest.IRunServer|null|undefined} runServer
     * @memberof VideoClientCallRequest
     * @instance
     */
    VideoClientCallRequest.prototype.runServer = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * VideoClientCallRequest body.
     * @member {"data"|"runClient"|"runServer"|undefined} body
     * @memberof VideoClientCallRequest
     * @instance
     */
    Object.defineProperty(VideoClientCallRequest.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["data", "runClient", "runServer"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new VideoClientCallRequest instance using the specified properties.
     * @function create
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest=} [properties] Properties to set
     * @returns {VideoClientCallRequest} VideoClientCallRequest instance
     */
    VideoClientCallRequest.create = function create(properties) {
        return new VideoClientCallRequest(properties);
    };

    /**
     * Encodes the specified VideoClientCallRequest message. Does not implicitly {@link VideoClientCallRequest.verify|verify} messages.
     * @function encode
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest} message VideoClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientCallRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.VideoClientCallRequest.Data.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.runClient != null && Object.hasOwnProperty.call(message, "runClient"))
            $root.VideoClientCallRequest.RunClient.encode(message.runClient, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.runServer != null && Object.hasOwnProperty.call(message, "runServer"))
            $root.VideoClientCallRequest.RunServer.encode(message.runServer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VideoClientCallRequest message, length delimited. Does not implicitly {@link VideoClientCallRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoClientCallRequest
     * @static
     * @param {IVideoClientCallRequest} message VideoClientCallRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoClientCallRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoClientCallRequest message from the specified reader or buffer.
     * @function decode
     * @memberof VideoClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientCallRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint32();
                break;
            case 2:
                message.data = $root.VideoClientCallRequest.Data.decode(reader, reader.uint32());
                break;
            case 3:
                message.runClient = $root.VideoClientCallRequest.RunClient.decode(reader, reader.uint32());
                break;
            case 4:
                message.runServer = $root.VideoClientCallRequest.RunServer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoClientCallRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoClientCallRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoClientCallRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoClientCallRequest message.
     * @function verify
     * @memberof VideoClientCallRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoClientCallRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.data != null && message.hasOwnProperty("data")) {
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.RunClient.verify(message.runClient);
                if (error)
                    return "runClient." + error;
            }
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.VideoClientCallRequest.RunServer.verify(message.runServer);
                if (error)
                    return "runServer." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VideoClientCallRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoClientCallRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoClientCallRequest} VideoClientCallRequest
     */
    VideoClientCallRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoClientCallRequest)
            return object;
        let message = new $root.VideoClientCallRequest();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".VideoClientCallRequest.data: object expected");
            message.data = $root.VideoClientCallRequest.Data.fromObject(object.data);
        }
        if (object.runClient != null) {
            if (typeof object.runClient !== "object")
                throw TypeError(".VideoClientCallRequest.runClient: object expected");
            message.runClient = $root.VideoClientCallRequest.RunClient.fromObject(object.runClient);
        }
        if (object.runServer != null) {
            if (typeof object.runServer !== "object")
                throw TypeError(".VideoClientCallRequest.runServer: object expected");
            message.runServer = $root.VideoClientCallRequest.RunServer.fromObject(object.runServer);
        }
        return message;
    };

    /**
     * Creates a plain object from a VideoClientCallRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoClientCallRequest
     * @static
     * @param {VideoClientCallRequest} message VideoClientCallRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoClientCallRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = 0;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.VideoClientCallRequest.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.runClient != null && message.hasOwnProperty("runClient")) {
            object.runClient = $root.VideoClientCallRequest.RunClient.toObject(message.runClient, options);
            if (options.oneofs)
                object.body = "runClient";
        }
        if (message.runServer != null && message.hasOwnProperty("runServer")) {
            object.runServer = $root.VideoClientCallRequest.RunServer.toObject(message.runServer, options);
            if (options.oneofs)
                object.body = "runServer";
        }
        return object;
    };

    /**
     * Converts this VideoClientCallRequest to JSON.
     * @function toJSON
     * @memberof VideoClientCallRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoClientCallRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    VideoClientCallRequest.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof VideoClientCallRequest
         * @interface IData
         * @property {Uint8Array|null} [body] Data body
         */

        /**
         * Constructs a new Data.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {VideoClientCallRequest.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data body.
         * @member {Uint8Array} body
         * @memberof VideoClientCallRequest.Data
         * @instance
         */
        Data.prototype.body = $util.newBuffer([]);

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData=} [properties] Properties to set
         * @returns {VideoClientCallRequest.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link VideoClientCallRequest.Data.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link VideoClientCallRequest.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                    return "body: buffer expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.Data)
                return object;
            let message = new $root.VideoClientCallRequest.Data();
            if (object.body != null)
                if (typeof object.body === "string")
                    $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                else if (object.body.length)
                    message.body = object.body;
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.Data
         * @static
         * @param {VideoClientCallRequest.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.body = "";
                else {
                    object.body = [];
                    if (options.bytes !== Array)
                        object.body = $util.newBuffer(object.body);
                }
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    VideoClientCallRequest.RunServer = (function() {

        /**
         * Properties of a RunServer.
         * @memberof VideoClientCallRequest
         * @interface IRunServer
         */

        /**
         * Constructs a new RunServer.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a RunServer.
         * @implements IRunServer
         * @constructor
         * @param {VideoClientCallRequest.IRunServer=} [properties] Properties to set
         */
        function RunServer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunServer instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer=} [properties] Properties to set
         * @returns {VideoClientCallRequest.RunServer} RunServer instance
         */
        RunServer.create = function create(properties) {
            return new RunServer(properties);
        };

        /**
         * Encodes the specified RunServer message. Does not implicitly {@link VideoClientCallRequest.RunServer.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunServer message, length delimited. Does not implicitly {@link VideoClientCallRequest.RunServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.IRunServer} message RunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.RunServer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.RunServer} RunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunServer message.
         * @function verify
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.RunServer} RunServer
         */
        RunServer.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.RunServer)
                return object;
            return new $root.VideoClientCallRequest.RunServer();
        };

        /**
         * Creates a plain object from a RunServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.RunServer
         * @static
         * @param {VideoClientCallRequest.RunServer} message RunServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunServer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunServer to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.RunServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunServer;
    })();

    VideoClientCallRequest.RunClient = (function() {

        /**
         * Properties of a RunClient.
         * @memberof VideoClientCallRequest
         * @interface IRunClient
         */

        /**
         * Constructs a new RunClient.
         * @memberof VideoClientCallRequest
         * @classdesc Represents a RunClient.
         * @implements IRunClient
         * @constructor
         * @param {VideoClientCallRequest.IRunClient=} [properties] Properties to set
         */
        function RunClient(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunClient instance using the specified properties.
         * @function create
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient=} [properties] Properties to set
         * @returns {VideoClientCallRequest.RunClient} RunClient instance
         */
        RunClient.create = function create(properties) {
            return new RunClient(properties);
        };

        /**
         * Encodes the specified RunClient message. Does not implicitly {@link VideoClientCallRequest.RunClient.verify|verify} messages.
         * @function encode
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunClient message, length delimited. Does not implicitly {@link VideoClientCallRequest.RunClient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.IRunClient} message RunClient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunClient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer.
         * @function decode
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VideoClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoClientCallRequest.RunClient();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunClient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VideoClientCallRequest.RunClient} RunClient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunClient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunClient message.
         * @function verify
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunClient.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunClient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VideoClientCallRequest.RunClient} RunClient
         */
        RunClient.fromObject = function fromObject(object) {
            if (object instanceof $root.VideoClientCallRequest.RunClient)
                return object;
            return new $root.VideoClientCallRequest.RunClient();
        };

        /**
         * Creates a plain object from a RunClient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VideoClientCallRequest.RunClient
         * @static
         * @param {VideoClientCallRequest.RunClient} message RunClient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunClient.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunClient to JSON.
         * @function toJSON
         * @memberof VideoClientCallRequest.RunClient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunClient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunClient;
    })();

    return VideoClientCallRequest;
})();

export const SwarmThingMessage = $root.SwarmThingMessage = (() => {

    /**
     * Properties of a SwarmThingMessage.
     * @exports ISwarmThingMessage
     * @interface ISwarmThingMessage
     * @property {SwarmThingMessage.IOpen|null} [open] SwarmThingMessage open
     * @property {SwarmThingMessage.IClose|null} [close] SwarmThingMessage close
     */

    /**
     * Constructs a new SwarmThingMessage.
     * @exports SwarmThingMessage
     * @classdesc Represents a SwarmThingMessage.
     * @implements ISwarmThingMessage
     * @constructor
     * @param {ISwarmThingMessage=} [properties] Properties to set
     */
    function SwarmThingMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SwarmThingMessage open.
     * @member {SwarmThingMessage.IOpen|null|undefined} open
     * @memberof SwarmThingMessage
     * @instance
     */
    SwarmThingMessage.prototype.open = null;

    /**
     * SwarmThingMessage close.
     * @member {SwarmThingMessage.IClose|null|undefined} close
     * @memberof SwarmThingMessage
     * @instance
     */
    SwarmThingMessage.prototype.close = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * SwarmThingMessage body.
     * @member {"open"|"close"|undefined} body
     * @memberof SwarmThingMessage
     * @instance
     */
    Object.defineProperty(SwarmThingMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "close"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new SwarmThingMessage instance using the specified properties.
     * @function create
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage=} [properties] Properties to set
     * @returns {SwarmThingMessage} SwarmThingMessage instance
     */
    SwarmThingMessage.create = function create(properties) {
        return new SwarmThingMessage(properties);
    };

    /**
     * Encodes the specified SwarmThingMessage message. Does not implicitly {@link SwarmThingMessage.verify|verify} messages.
     * @function encode
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage} message SwarmThingMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SwarmThingMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.SwarmThingMessage.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.close != null && Object.hasOwnProperty.call(message, "close"))
            $root.SwarmThingMessage.Close.encode(message.close, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SwarmThingMessage message, length delimited. Does not implicitly {@link SwarmThingMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SwarmThingMessage
     * @static
     * @param {ISwarmThingMessage} message SwarmThingMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SwarmThingMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SwarmThingMessage message from the specified reader or buffer.
     * @function decode
     * @memberof SwarmThingMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SwarmThingMessage} SwarmThingMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SwarmThingMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.SwarmThingMessage.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.close = $root.SwarmThingMessage.Close.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SwarmThingMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SwarmThingMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SwarmThingMessage} SwarmThingMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SwarmThingMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SwarmThingMessage message.
     * @function verify
     * @memberof SwarmThingMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SwarmThingMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.SwarmThingMessage.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.SwarmThingMessage.Close.verify(message.close);
                if (error)
                    return "close." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SwarmThingMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SwarmThingMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SwarmThingMessage} SwarmThingMessage
     */
    SwarmThingMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.SwarmThingMessage)
            return object;
        let message = new $root.SwarmThingMessage();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".SwarmThingMessage.open: object expected");
            message.open = $root.SwarmThingMessage.Open.fromObject(object.open);
        }
        if (object.close != null) {
            if (typeof object.close !== "object")
                throw TypeError(".SwarmThingMessage.close: object expected");
            message.close = $root.SwarmThingMessage.Close.fromObject(object.close);
        }
        return message;
    };

    /**
     * Creates a plain object from a SwarmThingMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SwarmThingMessage
     * @static
     * @param {SwarmThingMessage} message SwarmThingMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SwarmThingMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.SwarmThingMessage.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.close != null && message.hasOwnProperty("close")) {
            object.close = $root.SwarmThingMessage.Close.toObject(message.close, options);
            if (options.oneofs)
                object.body = "close";
        }
        return object;
    };

    /**
     * Converts this SwarmThingMessage to JSON.
     * @function toJSON
     * @memberof SwarmThingMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SwarmThingMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    SwarmThingMessage.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof SwarmThingMessage
         * @interface IOpen
         * @property {Uint8Array|null} [swarmId] Open swarmId
         * @property {number|null} [port] Open port
         */

        /**
         * Constructs a new Open.
         * @memberof SwarmThingMessage
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {SwarmThingMessage.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open swarmId.
         * @member {Uint8Array} swarmId
         * @memberof SwarmThingMessage.Open
         * @instance
         */
        Open.prototype.swarmId = $util.newBuffer([]);

        /**
         * Open port.
         * @member {number} port
         * @memberof SwarmThingMessage.Open
         * @instance
         */
        Open.prototype.port = 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen=} [properties] Properties to set
         * @returns {SwarmThingMessage.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link SwarmThingMessage.Open.verify|verify} messages.
         * @function encode
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swarmId != null && Object.hasOwnProperty.call(message, "swarmId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swarmId);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link SwarmThingMessage.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SwarmThingMessage.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.swarmId = reader.bytes();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SwarmThingMessage.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                if (!(message.swarmId && typeof message.swarmId.length === "number" || $util.isString(message.swarmId)))
                    return "swarmId: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SwarmThingMessage.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.SwarmThingMessage.Open)
                return object;
            let message = new $root.SwarmThingMessage.Open();
            if (object.swarmId != null)
                if (typeof object.swarmId === "string")
                    $util.base64.decode(object.swarmId, message.swarmId = $util.newBuffer($util.base64.length(object.swarmId)), 0);
                else if (object.swarmId.length)
                    message.swarmId = object.swarmId;
            if (object.port != null)
                message.port = object.port >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SwarmThingMessage.Open
         * @static
         * @param {SwarmThingMessage.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.swarmId = "";
                else {
                    object.swarmId = [];
                    if (options.bytes !== Array)
                        object.swarmId = $util.newBuffer(object.swarmId);
                }
                object.port = 0;
            }
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                object.swarmId = options.bytes === String ? $util.base64.encode(message.swarmId, 0, message.swarmId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swarmId) : message.swarmId;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof SwarmThingMessage.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    SwarmThingMessage.Close = (function() {

        /**
         * Properties of a Close.
         * @memberof SwarmThingMessage
         * @interface IClose
         * @property {Uint8Array|null} [swarmId] Close swarmId
         */

        /**
         * Constructs a new Close.
         * @memberof SwarmThingMessage
         * @classdesc Represents a Close.
         * @implements IClose
         * @constructor
         * @param {SwarmThingMessage.IClose=} [properties] Properties to set
         */
        function Close(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Close swarmId.
         * @member {Uint8Array} swarmId
         * @memberof SwarmThingMessage.Close
         * @instance
         */
        Close.prototype.swarmId = $util.newBuffer([]);

        /**
         * Creates a new Close instance using the specified properties.
         * @function create
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose=} [properties] Properties to set
         * @returns {SwarmThingMessage.Close} Close instance
         */
        Close.create = function create(properties) {
            return new Close(properties);
        };

        /**
         * Encodes the specified Close message. Does not implicitly {@link SwarmThingMessage.Close.verify|verify} messages.
         * @function encode
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.swarmId != null && Object.hasOwnProperty.call(message, "swarmId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.swarmId);
            return writer;
        };

        /**
         * Encodes the specified Close message, length delimited. Does not implicitly {@link SwarmThingMessage.Close.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.IClose} message Close message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Close.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Close message from the specified reader or buffer.
         * @function decode
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SwarmThingMessage.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SwarmThingMessage.Close();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.swarmId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Close message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SwarmThingMessage.Close} Close
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Close.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Close message.
         * @function verify
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Close.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                if (!(message.swarmId && typeof message.swarmId.length === "number" || $util.isString(message.swarmId)))
                    return "swarmId: buffer expected";
            return null;
        };

        /**
         * Creates a Close message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SwarmThingMessage.Close} Close
         */
        Close.fromObject = function fromObject(object) {
            if (object instanceof $root.SwarmThingMessage.Close)
                return object;
            let message = new $root.SwarmThingMessage.Close();
            if (object.swarmId != null)
                if (typeof object.swarmId === "string")
                    $util.base64.decode(object.swarmId, message.swarmId = $util.newBuffer($util.base64.length(object.swarmId)), 0);
                else if (object.swarmId.length)
                    message.swarmId = object.swarmId;
            return message;
        };

        /**
         * Creates a plain object from a Close message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SwarmThingMessage.Close
         * @static
         * @param {SwarmThingMessage.Close} message Close
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Close.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.swarmId = "";
                else {
                    object.swarmId = [];
                    if (options.bytes !== Array)
                        object.swarmId = $util.newBuffer(object.swarmId);
                }
            if (message.swarmId != null && message.hasOwnProperty("swarmId"))
                object.swarmId = options.bytes === String ? $util.base64.encode(message.swarmId, 0, message.swarmId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swarmId) : message.swarmId;
            return object;
        };

        /**
         * Converts this Close to JSON.
         * @function toJSON
         * @memberof SwarmThingMessage.Close
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Close.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Close;
    })();

    return SwarmThingMessage;
})();

export const StartVPNRequest = $root.StartVPNRequest = (() => {

    /**
     * Properties of a StartVPNRequest.
     * @exports IStartVPNRequest
     * @interface IStartVPNRequest
     * @property {boolean|null} [enableBootstrapPublishing] StartVPNRequest enableBootstrapPublishing
     */

    /**
     * Constructs a new StartVPNRequest.
     * @exports StartVPNRequest
     * @classdesc Represents a StartVPNRequest.
     * @implements IStartVPNRequest
     * @constructor
     * @param {IStartVPNRequest=} [properties] Properties to set
     */
    function StartVPNRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StartVPNRequest enableBootstrapPublishing.
     * @member {boolean} enableBootstrapPublishing
     * @memberof StartVPNRequest
     * @instance
     */
    StartVPNRequest.prototype.enableBootstrapPublishing = false;

    /**
     * Creates a new StartVPNRequest instance using the specified properties.
     * @function create
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest=} [properties] Properties to set
     * @returns {StartVPNRequest} StartVPNRequest instance
     */
    StartVPNRequest.create = function create(properties) {
        return new StartVPNRequest(properties);
    };

    /**
     * Encodes the specified StartVPNRequest message. Does not implicitly {@link StartVPNRequest.verify|verify} messages.
     * @function encode
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest} message StartVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.enableBootstrapPublishing != null && Object.hasOwnProperty.call(message, "enableBootstrapPublishing"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enableBootstrapPublishing);
        return writer;
    };

    /**
     * Encodes the specified StartVPNRequest message, length delimited. Does not implicitly {@link StartVPNRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartVPNRequest
     * @static
     * @param {IStartVPNRequest} message StartVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartVPNRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StartVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartVPNRequest} StartVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartVPNRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.enableBootstrapPublishing = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartVPNRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartVPNRequest} StartVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartVPNRequest message.
     * @function verify
     * @memberof StartVPNRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartVPNRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.enableBootstrapPublishing != null && message.hasOwnProperty("enableBootstrapPublishing"))
            if (typeof message.enableBootstrapPublishing !== "boolean")
                return "enableBootstrapPublishing: boolean expected";
        return null;
    };

    /**
     * Creates a StartVPNRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartVPNRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartVPNRequest} StartVPNRequest
     */
    StartVPNRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StartVPNRequest)
            return object;
        let message = new $root.StartVPNRequest();
        if (object.enableBootstrapPublishing != null)
            message.enableBootstrapPublishing = Boolean(object.enableBootstrapPublishing);
        return message;
    };

    /**
     * Creates a plain object from a StartVPNRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartVPNRequest
     * @static
     * @param {StartVPNRequest} message StartVPNRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartVPNRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.enableBootstrapPublishing = false;
        if (message.enableBootstrapPublishing != null && message.hasOwnProperty("enableBootstrapPublishing"))
            object.enableBootstrapPublishing = message.enableBootstrapPublishing;
        return object;
    };

    /**
     * Converts this StartVPNRequest to JSON.
     * @function toJSON
     * @memberof StartVPNRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartVPNRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartVPNRequest;
})();

export const StartVPNResponse = $root.StartVPNResponse = (() => {

    /**
     * Properties of a StartVPNResponse.
     * @exports IStartVPNResponse
     * @interface IStartVPNResponse
     */

    /**
     * Constructs a new StartVPNResponse.
     * @exports StartVPNResponse
     * @classdesc Represents a StartVPNResponse.
     * @implements IStartVPNResponse
     * @constructor
     * @param {IStartVPNResponse=} [properties] Properties to set
     */
    function StartVPNResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StartVPNResponse instance using the specified properties.
     * @function create
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse=} [properties] Properties to set
     * @returns {StartVPNResponse} StartVPNResponse instance
     */
    StartVPNResponse.create = function create(properties) {
        return new StartVPNResponse(properties);
    };

    /**
     * Encodes the specified StartVPNResponse message. Does not implicitly {@link StartVPNResponse.verify|verify} messages.
     * @function encode
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse} message StartVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StartVPNResponse message, length delimited. Does not implicitly {@link StartVPNResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StartVPNResponse
     * @static
     * @param {IStartVPNResponse} message StartVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StartVPNResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StartVPNResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StartVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StartVPNResponse} StartVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartVPNResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StartVPNResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StartVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StartVPNResponse} StartVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StartVPNResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StartVPNResponse message.
     * @function verify
     * @memberof StartVPNResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StartVPNResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StartVPNResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StartVPNResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StartVPNResponse} StartVPNResponse
     */
    StartVPNResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StartVPNResponse)
            return object;
        return new $root.StartVPNResponse();
    };

    /**
     * Creates a plain object from a StartVPNResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StartVPNResponse
     * @static
     * @param {StartVPNResponse} message StartVPNResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StartVPNResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StartVPNResponse to JSON.
     * @function toJSON
     * @memberof StartVPNResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StartVPNResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StartVPNResponse;
})();

export const StopVPNRequest = $root.StopVPNRequest = (() => {

    /**
     * Properties of a StopVPNRequest.
     * @exports IStopVPNRequest
     * @interface IStopVPNRequest
     */

    /**
     * Constructs a new StopVPNRequest.
     * @exports StopVPNRequest
     * @classdesc Represents a StopVPNRequest.
     * @implements IStopVPNRequest
     * @constructor
     * @param {IStopVPNRequest=} [properties] Properties to set
     */
    function StopVPNRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopVPNRequest instance using the specified properties.
     * @function create
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest=} [properties] Properties to set
     * @returns {StopVPNRequest} StopVPNRequest instance
     */
    StopVPNRequest.create = function create(properties) {
        return new StopVPNRequest(properties);
    };

    /**
     * Encodes the specified StopVPNRequest message. Does not implicitly {@link StopVPNRequest.verify|verify} messages.
     * @function encode
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest} message StopVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopVPNRequest message, length delimited. Does not implicitly {@link StopVPNRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopVPNRequest
     * @static
     * @param {IStopVPNRequest} message StopVPNRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopVPNRequest message from the specified reader or buffer.
     * @function decode
     * @memberof StopVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopVPNRequest} StopVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopVPNRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopVPNRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopVPNRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopVPNRequest} StopVPNRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopVPNRequest message.
     * @function verify
     * @memberof StopVPNRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopVPNRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopVPNRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopVPNRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopVPNRequest} StopVPNRequest
     */
    StopVPNRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.StopVPNRequest)
            return object;
        return new $root.StopVPNRequest();
    };

    /**
     * Creates a plain object from a StopVPNRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopVPNRequest
     * @static
     * @param {StopVPNRequest} message StopVPNRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopVPNRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopVPNRequest to JSON.
     * @function toJSON
     * @memberof StopVPNRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopVPNRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopVPNRequest;
})();

export const StopVPNResponse = $root.StopVPNResponse = (() => {

    /**
     * Properties of a StopVPNResponse.
     * @exports IStopVPNResponse
     * @interface IStopVPNResponse
     */

    /**
     * Constructs a new StopVPNResponse.
     * @exports StopVPNResponse
     * @classdesc Represents a StopVPNResponse.
     * @implements IStopVPNResponse
     * @constructor
     * @param {IStopVPNResponse=} [properties] Properties to set
     */
    function StopVPNResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new StopVPNResponse instance using the specified properties.
     * @function create
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse=} [properties] Properties to set
     * @returns {StopVPNResponse} StopVPNResponse instance
     */
    StopVPNResponse.create = function create(properties) {
        return new StopVPNResponse(properties);
    };

    /**
     * Encodes the specified StopVPNResponse message. Does not implicitly {@link StopVPNResponse.verify|verify} messages.
     * @function encode
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse} message StopVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified StopVPNResponse message, length delimited. Does not implicitly {@link StopVPNResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StopVPNResponse
     * @static
     * @param {IStopVPNResponse} message StopVPNResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StopVPNResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StopVPNResponse message from the specified reader or buffer.
     * @function decode
     * @memberof StopVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StopVPNResponse} StopVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopVPNResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StopVPNResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StopVPNResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StopVPNResponse} StopVPNResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StopVPNResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StopVPNResponse message.
     * @function verify
     * @memberof StopVPNResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StopVPNResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a StopVPNResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StopVPNResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StopVPNResponse} StopVPNResponse
     */
    StopVPNResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.StopVPNResponse)
            return object;
        return new $root.StopVPNResponse();
    };

    /**
     * Creates a plain object from a StopVPNResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StopVPNResponse
     * @static
     * @param {StopVPNResponse} message StopVPNResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StopVPNResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this StopVPNResponse to JSON.
     * @function toJSON
     * @memberof StopVPNResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StopVPNResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StopVPNResponse;
})();

export const NetworkEvent = $root.NetworkEvent = (() => {

    /**
     * Properties of a NetworkEvent.
     * @exports INetworkEvent
     * @interface INetworkEvent
     * @property {NetworkEvent.INetworkOpen|null} [networkOpen] NetworkEvent networkOpen
     * @property {NetworkEvent.INetworkClose|null} [networkClose] NetworkEvent networkClose
     */

    /**
     * Constructs a new NetworkEvent.
     * @exports NetworkEvent
     * @classdesc Represents a NetworkEvent.
     * @implements INetworkEvent
     * @constructor
     * @param {INetworkEvent=} [properties] Properties to set
     */
    function NetworkEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkEvent networkOpen.
     * @member {NetworkEvent.INetworkOpen|null|undefined} networkOpen
     * @memberof NetworkEvent
     * @instance
     */
    NetworkEvent.prototype.networkOpen = null;

    /**
     * NetworkEvent networkClose.
     * @member {NetworkEvent.INetworkClose|null|undefined} networkClose
     * @memberof NetworkEvent
     * @instance
     */
    NetworkEvent.prototype.networkClose = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * NetworkEvent body.
     * @member {"networkOpen"|"networkClose"|undefined} body
     * @memberof NetworkEvent
     * @instance
     */
    Object.defineProperty(NetworkEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["networkOpen", "networkClose"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new NetworkEvent instance using the specified properties.
     * @function create
     * @memberof NetworkEvent
     * @static
     * @param {INetworkEvent=} [properties] Properties to set
     * @returns {NetworkEvent} NetworkEvent instance
     */
    NetworkEvent.create = function create(properties) {
        return new NetworkEvent(properties);
    };

    /**
     * Encodes the specified NetworkEvent message. Does not implicitly {@link NetworkEvent.verify|verify} messages.
     * @function encode
     * @memberof NetworkEvent
     * @static
     * @param {INetworkEvent} message NetworkEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkOpen != null && Object.hasOwnProperty.call(message, "networkOpen"))
            $root.NetworkEvent.NetworkOpen.encode(message.networkOpen, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.networkClose != null && Object.hasOwnProperty.call(message, "networkClose"))
            $root.NetworkEvent.NetworkClose.encode(message.networkClose, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NetworkEvent message, length delimited. Does not implicitly {@link NetworkEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkEvent
     * @static
     * @param {INetworkEvent} message NetworkEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkEvent message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkEvent} NetworkEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkOpen = $root.NetworkEvent.NetworkOpen.decode(reader, reader.uint32());
                break;
            case 2:
                message.networkClose = $root.NetworkEvent.NetworkClose.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkEvent} NetworkEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkEvent message.
     * @function verify
     * @memberof NetworkEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.networkOpen != null && message.hasOwnProperty("networkOpen")) {
            properties.body = 1;
            {
                let error = $root.NetworkEvent.NetworkOpen.verify(message.networkOpen);
                if (error)
                    return "networkOpen." + error;
            }
        }
        if (message.networkClose != null && message.hasOwnProperty("networkClose")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkEvent.NetworkClose.verify(message.networkClose);
                if (error)
                    return "networkClose." + error;
            }
        }
        return null;
    };

    /**
     * Creates a NetworkEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkEvent} NetworkEvent
     */
    NetworkEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkEvent)
            return object;
        let message = new $root.NetworkEvent();
        if (object.networkOpen != null) {
            if (typeof object.networkOpen !== "object")
                throw TypeError(".NetworkEvent.networkOpen: object expected");
            message.networkOpen = $root.NetworkEvent.NetworkOpen.fromObject(object.networkOpen);
        }
        if (object.networkClose != null) {
            if (typeof object.networkClose !== "object")
                throw TypeError(".NetworkEvent.networkClose: object expected");
            message.networkClose = $root.NetworkEvent.NetworkClose.fromObject(object.networkClose);
        }
        return message;
    };

    /**
     * Creates a plain object from a NetworkEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkEvent
     * @static
     * @param {NetworkEvent} message NetworkEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.networkOpen != null && message.hasOwnProperty("networkOpen")) {
            object.networkOpen = $root.NetworkEvent.NetworkOpen.toObject(message.networkOpen, options);
            if (options.oneofs)
                object.body = "networkOpen";
        }
        if (message.networkClose != null && message.hasOwnProperty("networkClose")) {
            object.networkClose = $root.NetworkEvent.NetworkClose.toObject(message.networkClose, options);
            if (options.oneofs)
                object.body = "networkClose";
        }
        return object;
    };

    /**
     * Converts this NetworkEvent to JSON.
     * @function toJSON
     * @memberof NetworkEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    NetworkEvent.NetworkOpen = (function() {

        /**
         * Properties of a NetworkOpen.
         * @memberof NetworkEvent
         * @interface INetworkOpen
         * @property {number|null} [networkId] NetworkOpen networkId
         * @property {Uint8Array|null} [networkKey] NetworkOpen networkKey
         */

        /**
         * Constructs a new NetworkOpen.
         * @memberof NetworkEvent
         * @classdesc Represents a NetworkOpen.
         * @implements INetworkOpen
         * @constructor
         * @param {NetworkEvent.INetworkOpen=} [properties] Properties to set
         */
        function NetworkOpen(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkOpen networkId.
         * @member {number} networkId
         * @memberof NetworkEvent.NetworkOpen
         * @instance
         */
        NetworkOpen.prototype.networkId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * NetworkOpen networkKey.
         * @member {Uint8Array} networkKey
         * @memberof NetworkEvent.NetworkOpen
         * @instance
         */
        NetworkOpen.prototype.networkKey = $util.newBuffer([]);

        /**
         * Creates a new NetworkOpen instance using the specified properties.
         * @function create
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {NetworkEvent.INetworkOpen=} [properties] Properties to set
         * @returns {NetworkEvent.NetworkOpen} NetworkOpen instance
         */
        NetworkOpen.create = function create(properties) {
            return new NetworkOpen(properties);
        };

        /**
         * Encodes the specified NetworkOpen message. Does not implicitly {@link NetworkEvent.NetworkOpen.verify|verify} messages.
         * @function encode
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {NetworkEvent.INetworkOpen} message NetworkOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.networkId);
            if (message.networkKey != null && Object.hasOwnProperty.call(message, "networkKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.networkKey);
            return writer;
        };

        /**
         * Encodes the specified NetworkOpen message, length delimited. Does not implicitly {@link NetworkEvent.NetworkOpen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {NetworkEvent.INetworkOpen} message NetworkOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkOpen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkOpen message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkEvent.NetworkOpen} NetworkOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkEvent.NetworkOpen();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.networkId = reader.uint64();
                    break;
                case 2:
                    message.networkKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkOpen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkEvent.NetworkOpen} NetworkOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkOpen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkOpen message.
         * @function verify
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkOpen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (!$util.isInteger(message.networkId) && !(message.networkId && $util.isInteger(message.networkId.low) && $util.isInteger(message.networkId.high)))
                    return "networkId: integer|Long expected";
            if (message.networkKey != null && message.hasOwnProperty("networkKey"))
                if (!(message.networkKey && typeof message.networkKey.length === "number" || $util.isString(message.networkKey)))
                    return "networkKey: buffer expected";
            return null;
        };

        /**
         * Creates a NetworkOpen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkEvent.NetworkOpen} NetworkOpen
         */
        NetworkOpen.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkEvent.NetworkOpen)
                return object;
            let message = new $root.NetworkEvent.NetworkOpen();
            if (object.networkId != null)
                if ($util.Long)
                    (message.networkId = $util.Long.fromValue(object.networkId)).unsigned = true;
                else if (typeof object.networkId === "string")
                    message.networkId = parseInt(object.networkId, 10);
                else if (typeof object.networkId === "number")
                    message.networkId = object.networkId;
                else if (typeof object.networkId === "object")
                    message.networkId = new $util.LongBits(object.networkId.low >>> 0, object.networkId.high >>> 0).toNumber(true);
            if (object.networkKey != null)
                if (typeof object.networkKey === "string")
                    $util.base64.decode(object.networkKey, message.networkKey = $util.newBuffer($util.base64.length(object.networkKey)), 0);
                else if (object.networkKey.length)
                    message.networkKey = object.networkKey;
            return message;
        };

        /**
         * Creates a plain object from a NetworkOpen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkEvent.NetworkOpen
         * @static
         * @param {NetworkEvent.NetworkOpen} message NetworkOpen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkOpen.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.networkId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.networkId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.networkKey = "";
                else {
                    object.networkKey = [];
                    if (options.bytes !== Array)
                        object.networkKey = $util.newBuffer(object.networkKey);
                }
            }
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (typeof message.networkId === "number")
                    object.networkId = options.longs === String ? String(message.networkId) : message.networkId;
                else
                    object.networkId = options.longs === String ? $util.Long.prototype.toString.call(message.networkId) : options.longs === Number ? new $util.LongBits(message.networkId.low >>> 0, message.networkId.high >>> 0).toNumber(true) : message.networkId;
            if (message.networkKey != null && message.hasOwnProperty("networkKey"))
                object.networkKey = options.bytes === String ? $util.base64.encode(message.networkKey, 0, message.networkKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKey) : message.networkKey;
            return object;
        };

        /**
         * Converts this NetworkOpen to JSON.
         * @function toJSON
         * @memberof NetworkEvent.NetworkOpen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkOpen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkOpen;
    })();

    NetworkEvent.NetworkClose = (function() {

        /**
         * Properties of a NetworkClose.
         * @memberof NetworkEvent
         * @interface INetworkClose
         * @property {number|null} [networkId] NetworkClose networkId
         */

        /**
         * Constructs a new NetworkClose.
         * @memberof NetworkEvent
         * @classdesc Represents a NetworkClose.
         * @implements INetworkClose
         * @constructor
         * @param {NetworkEvent.INetworkClose=} [properties] Properties to set
         */
        function NetworkClose(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkClose networkId.
         * @member {number} networkId
         * @memberof NetworkEvent.NetworkClose
         * @instance
         */
        NetworkClose.prototype.networkId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new NetworkClose instance using the specified properties.
         * @function create
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {NetworkEvent.INetworkClose=} [properties] Properties to set
         * @returns {NetworkEvent.NetworkClose} NetworkClose instance
         */
        NetworkClose.create = function create(properties) {
            return new NetworkClose(properties);
        };

        /**
         * Encodes the specified NetworkClose message. Does not implicitly {@link NetworkEvent.NetworkClose.verify|verify} messages.
         * @function encode
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {NetworkEvent.INetworkClose} message NetworkClose message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkClose.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.networkId);
            return writer;
        };

        /**
         * Encodes the specified NetworkClose message, length delimited. Does not implicitly {@link NetworkEvent.NetworkClose.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {NetworkEvent.INetworkClose} message NetworkClose message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkClose.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkClose message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkEvent.NetworkClose} NetworkClose
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkClose.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkEvent.NetworkClose();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.networkId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkClose message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkEvent.NetworkClose} NetworkClose
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkClose.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkClose message.
         * @function verify
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkClose.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (!$util.isInteger(message.networkId) && !(message.networkId && $util.isInteger(message.networkId.low) && $util.isInteger(message.networkId.high)))
                    return "networkId: integer|Long expected";
            return null;
        };

        /**
         * Creates a NetworkClose message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkEvent.NetworkClose} NetworkClose
         */
        NetworkClose.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkEvent.NetworkClose)
                return object;
            let message = new $root.NetworkEvent.NetworkClose();
            if (object.networkId != null)
                if ($util.Long)
                    (message.networkId = $util.Long.fromValue(object.networkId)).unsigned = true;
                else if (typeof object.networkId === "string")
                    message.networkId = parseInt(object.networkId, 10);
                else if (typeof object.networkId === "number")
                    message.networkId = object.networkId;
                else if (typeof object.networkId === "object")
                    message.networkId = new $util.LongBits(object.networkId.low >>> 0, object.networkId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a NetworkClose message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkEvent.NetworkClose
         * @static
         * @param {NetworkEvent.NetworkClose} message NetworkClose
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkClose.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.networkId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.networkId = options.longs === String ? "0" : 0;
            if (message.networkId != null && message.hasOwnProperty("networkId"))
                if (typeof message.networkId === "number")
                    object.networkId = options.longs === String ? String(message.networkId) : message.networkId;
                else
                    object.networkId = options.longs === String ? $util.Long.prototype.toString.call(message.networkId) : options.longs === Number ? new $util.LongBits(message.networkId.low >>> 0, message.networkId.high >>> 0).toNumber(true) : message.networkId;
            return object;
        };

        /**
         * Converts this NetworkClose to JSON.
         * @function toJSON
         * @memberof NetworkEvent.NetworkClose
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkClose.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkClose;
    })();

    return NetworkEvent;
})();

export const NetworkAddress = $root.NetworkAddress = (() => {

    /**
     * Properties of a NetworkAddress.
     * @exports INetworkAddress
     * @interface INetworkAddress
     * @property {Uint8Array|null} [hostId] NetworkAddress hostId
     * @property {number|null} [port] NetworkAddress port
     */

    /**
     * Constructs a new NetworkAddress.
     * @exports NetworkAddress
     * @classdesc Represents a NetworkAddress.
     * @implements INetworkAddress
     * @constructor
     * @param {INetworkAddress=} [properties] Properties to set
     */
    function NetworkAddress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkAddress hostId.
     * @member {Uint8Array} hostId
     * @memberof NetworkAddress
     * @instance
     */
    NetworkAddress.prototype.hostId = $util.newBuffer([]);

    /**
     * NetworkAddress port.
     * @member {number} port
     * @memberof NetworkAddress
     * @instance
     */
    NetworkAddress.prototype.port = 0;

    /**
     * Creates a new NetworkAddress instance using the specified properties.
     * @function create
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress=} [properties] Properties to set
     * @returns {NetworkAddress} NetworkAddress instance
     */
    NetworkAddress.create = function create(properties) {
        return new NetworkAddress(properties);
    };

    /**
     * Encodes the specified NetworkAddress message. Does not implicitly {@link NetworkAddress.verify|verify} messages.
     * @function encode
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress} message NetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkAddress.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hostId);
        if (message.port != null && Object.hasOwnProperty.call(message, "port"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
        return writer;
    };

    /**
     * Encodes the specified NetworkAddress message, length delimited. Does not implicitly {@link NetworkAddress.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkAddress
     * @static
     * @param {INetworkAddress} message NetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkAddress message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkAddress} NetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkAddress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hostId = reader.bytes();
                break;
            case 2:
                message.port = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkAddress message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkAddress} NetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkAddress message.
     * @function verify
     * @memberof NetworkAddress
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                return "hostId: buffer expected";
        if (message.port != null && message.hasOwnProperty("port"))
            if (!$util.isInteger(message.port))
                return "port: integer expected";
        return null;
    };

    /**
     * Creates a NetworkAddress message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkAddress
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkAddress} NetworkAddress
     */
    NetworkAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkAddress)
            return object;
        let message = new $root.NetworkAddress();
        if (object.hostId != null)
            if (typeof object.hostId === "string")
                $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
            else if (object.hostId.length)
                message.hostId = object.hostId;
        if (object.port != null)
            message.port = object.port >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a NetworkAddress message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkAddress
     * @static
     * @param {NetworkAddress} message NetworkAddress
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkAddress.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.hostId = "";
            else {
                object.hostId = [];
                if (options.bytes !== Array)
                    object.hostId = $util.newBuffer(object.hostId);
            }
            object.port = 0;
        }
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
        if (message.port != null && message.hasOwnProperty("port"))
            object.port = message.port;
        return object;
    };

    /**
     * Converts this NetworkAddress to JSON.
     * @function toJSON
     * @memberof NetworkAddress
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NetworkAddress;
})();

export const PeerInit = $root.PeerInit = (() => {

    /**
     * Properties of a PeerInit.
     * @exports IPeerInit
     * @interface IPeerInit
     * @property {number|null} [protocolVersion] PeerInit protocolVersion
     * @property {ICertificate|null} [certificate] PeerInit certificate
     * @property {string|null} [nodePlatform] PeerInit nodePlatform
     * @property {string|null} [nodeVersion] PeerInit nodeVersion
     */

    /**
     * Constructs a new PeerInit.
     * @exports PeerInit
     * @classdesc Represents a PeerInit.
     * @implements IPeerInit
     * @constructor
     * @param {IPeerInit=} [properties] Properties to set
     */
    function PeerInit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerInit protocolVersion.
     * @member {number} protocolVersion
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.protocolVersion = 0;

    /**
     * PeerInit certificate.
     * @member {ICertificate|null|undefined} certificate
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.certificate = null;

    /**
     * PeerInit nodePlatform.
     * @member {string} nodePlatform
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.nodePlatform = "";

    /**
     * PeerInit nodeVersion.
     * @member {string} nodeVersion
     * @memberof PeerInit
     * @instance
     */
    PeerInit.prototype.nodeVersion = "";

    /**
     * Creates a new PeerInit instance using the specified properties.
     * @function create
     * @memberof PeerInit
     * @static
     * @param {IPeerInit=} [properties] Properties to set
     * @returns {PeerInit} PeerInit instance
     */
    PeerInit.create = function create(properties) {
        return new PeerInit(properties);
    };

    /**
     * Encodes the specified PeerInit message. Does not implicitly {@link PeerInit.verify|verify} messages.
     * @function encode
     * @memberof PeerInit
     * @static
     * @param {IPeerInit} message PeerInit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerInit.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.protocolVersion != null && Object.hasOwnProperty.call(message, "protocolVersion"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.protocolVersion);
        if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
            $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.nodePlatform != null && Object.hasOwnProperty.call(message, "nodePlatform"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.nodePlatform);
        if (message.nodeVersion != null && Object.hasOwnProperty.call(message, "nodeVersion"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.nodeVersion);
        return writer;
    };

    /**
     * Encodes the specified PeerInit message, length delimited. Does not implicitly {@link PeerInit.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerInit
     * @static
     * @param {IPeerInit} message PeerInit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerInit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerInit message from the specified reader or buffer.
     * @function decode
     * @memberof PeerInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerInit} PeerInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerInit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerInit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.protocolVersion = reader.uint32();
                break;
            case 2:
                message.certificate = $root.Certificate.decode(reader, reader.uint32());
                break;
            case 3:
                message.nodePlatform = reader.string();
                break;
            case 4:
                message.nodeVersion = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerInit message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerInit} PeerInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerInit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerInit message.
     * @function verify
     * @memberof PeerInit
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerInit.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
            if (!$util.isInteger(message.protocolVersion))
                return "protocolVersion: integer expected";
        if (message.certificate != null && message.hasOwnProperty("certificate")) {
            let error = $root.Certificate.verify(message.certificate);
            if (error)
                return "certificate." + error;
        }
        if (message.nodePlatform != null && message.hasOwnProperty("nodePlatform"))
            if (!$util.isString(message.nodePlatform))
                return "nodePlatform: string expected";
        if (message.nodeVersion != null && message.hasOwnProperty("nodeVersion"))
            if (!$util.isString(message.nodeVersion))
                return "nodeVersion: string expected";
        return null;
    };

    /**
     * Creates a PeerInit message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerInit
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerInit} PeerInit
     */
    PeerInit.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerInit)
            return object;
        let message = new $root.PeerInit();
        if (object.protocolVersion != null)
            message.protocolVersion = object.protocolVersion >>> 0;
        if (object.certificate != null) {
            if (typeof object.certificate !== "object")
                throw TypeError(".PeerInit.certificate: object expected");
            message.certificate = $root.Certificate.fromObject(object.certificate);
        }
        if (object.nodePlatform != null)
            message.nodePlatform = String(object.nodePlatform);
        if (object.nodeVersion != null)
            message.nodeVersion = String(object.nodeVersion);
        return message;
    };

    /**
     * Creates a plain object from a PeerInit message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerInit
     * @static
     * @param {PeerInit} message PeerInit
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerInit.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.protocolVersion = 0;
            object.certificate = null;
            object.nodePlatform = "";
            object.nodeVersion = "";
        }
        if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
            object.protocolVersion = message.protocolVersion;
        if (message.certificate != null && message.hasOwnProperty("certificate"))
            object.certificate = $root.Certificate.toObject(message.certificate, options);
        if (message.nodePlatform != null && message.hasOwnProperty("nodePlatform"))
            object.nodePlatform = message.nodePlatform;
        if (message.nodeVersion != null && message.hasOwnProperty("nodeVersion"))
            object.nodeVersion = message.nodeVersion;
        return object;
    };

    /**
     * Converts this PeerInit to JSON.
     * @function toJSON
     * @memberof PeerInit
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerInit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PeerInit;
})();

export const NetworkHandshake = $root.NetworkHandshake = (() => {

    /**
     * Properties of a NetworkHandshake.
     * @exports INetworkHandshake
     * @interface INetworkHandshake
     * @property {NetworkHandshake.IInit|null} [init] NetworkHandshake init
     * @property {NetworkHandshake.INetworkBindings|null} [networkBindings] NetworkHandshake networkBindings
     * @property {NetworkHandshake.ICertificateUpgradeOffer|null} [certificateUpgradeOffer] NetworkHandshake certificateUpgradeOffer
     * @property {NetworkHandshake.ICertificateUpgradeRequest|null} [certificateUpgradeRequest] NetworkHandshake certificateUpgradeRequest
     * @property {NetworkHandshake.ICertificateUpgradeResponse|null} [certificateUpgradeResponse] NetworkHandshake certificateUpgradeResponse
     */

    /**
     * Constructs a new NetworkHandshake.
     * @exports NetworkHandshake
     * @classdesc Represents a NetworkHandshake.
     * @implements INetworkHandshake
     * @constructor
     * @param {INetworkHandshake=} [properties] Properties to set
     */
    function NetworkHandshake(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NetworkHandshake init.
     * @member {NetworkHandshake.IInit|null|undefined} init
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.init = null;

    /**
     * NetworkHandshake networkBindings.
     * @member {NetworkHandshake.INetworkBindings|null|undefined} networkBindings
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.networkBindings = null;

    /**
     * NetworkHandshake certificateUpgradeOffer.
     * @member {NetworkHandshake.ICertificateUpgradeOffer|null|undefined} certificateUpgradeOffer
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.certificateUpgradeOffer = null;

    /**
     * NetworkHandshake certificateUpgradeRequest.
     * @member {NetworkHandshake.ICertificateUpgradeRequest|null|undefined} certificateUpgradeRequest
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.certificateUpgradeRequest = null;

    /**
     * NetworkHandshake certificateUpgradeResponse.
     * @member {NetworkHandshake.ICertificateUpgradeResponse|null|undefined} certificateUpgradeResponse
     * @memberof NetworkHandshake
     * @instance
     */
    NetworkHandshake.prototype.certificateUpgradeResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * NetworkHandshake body.
     * @member {"init"|"networkBindings"|"certificateUpgradeOffer"|"certificateUpgradeRequest"|"certificateUpgradeResponse"|undefined} body
     * @memberof NetworkHandshake
     * @instance
     */
    Object.defineProperty(NetworkHandshake.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["init", "networkBindings", "certificateUpgradeOffer", "certificateUpgradeRequest", "certificateUpgradeResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new NetworkHandshake instance using the specified properties.
     * @function create
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake=} [properties] Properties to set
     * @returns {NetworkHandshake} NetworkHandshake instance
     */
    NetworkHandshake.create = function create(properties) {
        return new NetworkHandshake(properties);
    };

    /**
     * Encodes the specified NetworkHandshake message. Does not implicitly {@link NetworkHandshake.verify|verify} messages.
     * @function encode
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake} message NetworkHandshake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkHandshake.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.init != null && Object.hasOwnProperty.call(message, "init"))
            $root.NetworkHandshake.Init.encode(message.init, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.networkBindings != null && Object.hasOwnProperty.call(message, "networkBindings"))
            $root.NetworkHandshake.NetworkBindings.encode(message.networkBindings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.certificateUpgradeOffer != null && Object.hasOwnProperty.call(message, "certificateUpgradeOffer"))
            $root.NetworkHandshake.CertificateUpgradeOffer.encode(message.certificateUpgradeOffer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.certificateUpgradeRequest != null && Object.hasOwnProperty.call(message, "certificateUpgradeRequest"))
            $root.NetworkHandshake.CertificateUpgradeRequest.encode(message.certificateUpgradeRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.certificateUpgradeResponse != null && Object.hasOwnProperty.call(message, "certificateUpgradeResponse"))
            $root.NetworkHandshake.CertificateUpgradeResponse.encode(message.certificateUpgradeResponse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NetworkHandshake message, length delimited. Does not implicitly {@link NetworkHandshake.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NetworkHandshake
     * @static
     * @param {INetworkHandshake} message NetworkHandshake message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NetworkHandshake.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NetworkHandshake message from the specified reader or buffer.
     * @function decode
     * @memberof NetworkHandshake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NetworkHandshake} NetworkHandshake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkHandshake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.init = $root.NetworkHandshake.Init.decode(reader, reader.uint32());
                break;
            case 2:
                message.networkBindings = $root.NetworkHandshake.NetworkBindings.decode(reader, reader.uint32());
                break;
            case 3:
                message.certificateUpgradeOffer = $root.NetworkHandshake.CertificateUpgradeOffer.decode(reader, reader.uint32());
                break;
            case 4:
                message.certificateUpgradeRequest = $root.NetworkHandshake.CertificateUpgradeRequest.decode(reader, reader.uint32());
                break;
            case 5:
                message.certificateUpgradeResponse = $root.NetworkHandshake.CertificateUpgradeResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NetworkHandshake message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NetworkHandshake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NetworkHandshake} NetworkHandshake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NetworkHandshake.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NetworkHandshake message.
     * @function verify
     * @memberof NetworkHandshake
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NetworkHandshake.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.init != null && message.hasOwnProperty("init")) {
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.Init.verify(message.init);
                if (error)
                    return "init." + error;
            }
        }
        if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.NetworkBindings.verify(message.networkBindings);
                if (error)
                    return "networkBindings." + error;
            }
        }
        if (message.certificateUpgradeOffer != null && message.hasOwnProperty("certificateUpgradeOffer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.CertificateUpgradeOffer.verify(message.certificateUpgradeOffer);
                if (error)
                    return "certificateUpgradeOffer." + error;
            }
        }
        if (message.certificateUpgradeRequest != null && message.hasOwnProperty("certificateUpgradeRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.CertificateUpgradeRequest.verify(message.certificateUpgradeRequest);
                if (error)
                    return "certificateUpgradeRequest." + error;
            }
        }
        if (message.certificateUpgradeResponse != null && message.hasOwnProperty("certificateUpgradeResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.NetworkHandshake.CertificateUpgradeResponse.verify(message.certificateUpgradeResponse);
                if (error)
                    return "certificateUpgradeResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a NetworkHandshake message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NetworkHandshake
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NetworkHandshake} NetworkHandshake
     */
    NetworkHandshake.fromObject = function fromObject(object) {
        if (object instanceof $root.NetworkHandshake)
            return object;
        let message = new $root.NetworkHandshake();
        if (object.init != null) {
            if (typeof object.init !== "object")
                throw TypeError(".NetworkHandshake.init: object expected");
            message.init = $root.NetworkHandshake.Init.fromObject(object.init);
        }
        if (object.networkBindings != null) {
            if (typeof object.networkBindings !== "object")
                throw TypeError(".NetworkHandshake.networkBindings: object expected");
            message.networkBindings = $root.NetworkHandshake.NetworkBindings.fromObject(object.networkBindings);
        }
        if (object.certificateUpgradeOffer != null) {
            if (typeof object.certificateUpgradeOffer !== "object")
                throw TypeError(".NetworkHandshake.certificateUpgradeOffer: object expected");
            message.certificateUpgradeOffer = $root.NetworkHandshake.CertificateUpgradeOffer.fromObject(object.certificateUpgradeOffer);
        }
        if (object.certificateUpgradeRequest != null) {
            if (typeof object.certificateUpgradeRequest !== "object")
                throw TypeError(".NetworkHandshake.certificateUpgradeRequest: object expected");
            message.certificateUpgradeRequest = $root.NetworkHandshake.CertificateUpgradeRequest.fromObject(object.certificateUpgradeRequest);
        }
        if (object.certificateUpgradeResponse != null) {
            if (typeof object.certificateUpgradeResponse !== "object")
                throw TypeError(".NetworkHandshake.certificateUpgradeResponse: object expected");
            message.certificateUpgradeResponse = $root.NetworkHandshake.CertificateUpgradeResponse.fromObject(object.certificateUpgradeResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a NetworkHandshake message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NetworkHandshake
     * @static
     * @param {NetworkHandshake} message NetworkHandshake
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NetworkHandshake.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.init != null && message.hasOwnProperty("init")) {
            object.init = $root.NetworkHandshake.Init.toObject(message.init, options);
            if (options.oneofs)
                object.body = "init";
        }
        if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
            object.networkBindings = $root.NetworkHandshake.NetworkBindings.toObject(message.networkBindings, options);
            if (options.oneofs)
                object.body = "networkBindings";
        }
        if (message.certificateUpgradeOffer != null && message.hasOwnProperty("certificateUpgradeOffer")) {
            object.certificateUpgradeOffer = $root.NetworkHandshake.CertificateUpgradeOffer.toObject(message.certificateUpgradeOffer, options);
            if (options.oneofs)
                object.body = "certificateUpgradeOffer";
        }
        if (message.certificateUpgradeRequest != null && message.hasOwnProperty("certificateUpgradeRequest")) {
            object.certificateUpgradeRequest = $root.NetworkHandshake.CertificateUpgradeRequest.toObject(message.certificateUpgradeRequest, options);
            if (options.oneofs)
                object.body = "certificateUpgradeRequest";
        }
        if (message.certificateUpgradeResponse != null && message.hasOwnProperty("certificateUpgradeResponse")) {
            object.certificateUpgradeResponse = $root.NetworkHandshake.CertificateUpgradeResponse.toObject(message.certificateUpgradeResponse, options);
            if (options.oneofs)
                object.body = "certificateUpgradeResponse";
        }
        return object;
    };

    /**
     * Converts this NetworkHandshake to JSON.
     * @function toJSON
     * @memberof NetworkHandshake
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NetworkHandshake.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    NetworkHandshake.Init = (function() {

        /**
         * Properties of an Init.
         * @memberof NetworkHandshake
         * @interface IInit
         * @property {number|null} [keyCount] Init keyCount
         */

        /**
         * Constructs a new Init.
         * @memberof NetworkHandshake
         * @classdesc Represents an Init.
         * @implements IInit
         * @constructor
         * @param {NetworkHandshake.IInit=} [properties] Properties to set
         */
        function Init(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Init keyCount.
         * @member {number} keyCount
         * @memberof NetworkHandshake.Init
         * @instance
         */
        Init.prototype.keyCount = 0;

        /**
         * Creates a new Init instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit=} [properties] Properties to set
         * @returns {NetworkHandshake.Init} Init instance
         */
        Init.create = function create(properties) {
            return new Init(properties);
        };

        /**
         * Encodes the specified Init message. Does not implicitly {@link NetworkHandshake.Init.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit} message Init message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Init.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyCount != null && Object.hasOwnProperty.call(message, "keyCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keyCount);
            return writer;
        };

        /**
         * Encodes the specified Init message, length delimited. Does not implicitly {@link NetworkHandshake.Init.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.IInit} message Init message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Init.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Init message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.Init
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.Init} Init
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Init.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.Init();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Init message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.Init
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.Init} Init
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Init.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Init message.
         * @function verify
         * @memberof NetworkHandshake.Init
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Init.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyCount != null && message.hasOwnProperty("keyCount"))
                if (!$util.isInteger(message.keyCount))
                    return "keyCount: integer expected";
            return null;
        };

        /**
         * Creates an Init message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.Init
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.Init} Init
         */
        Init.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.Init)
                return object;
            let message = new $root.NetworkHandshake.Init();
            if (object.keyCount != null)
                message.keyCount = object.keyCount | 0;
            return message;
        };

        /**
         * Creates a plain object from an Init message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.Init
         * @static
         * @param {NetworkHandshake.Init} message Init
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Init.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.keyCount = 0;
            if (message.keyCount != null && message.hasOwnProperty("keyCount"))
                object.keyCount = message.keyCount;
            return object;
        };

        /**
         * Converts this Init to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.Init
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Init.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Init;
    })();

    NetworkHandshake.NetworkBinding = (function() {

        /**
         * Properties of a NetworkBinding.
         * @memberof NetworkHandshake
         * @interface INetworkBinding
         * @property {number|null} [port] NetworkBinding port
         * @property {ICertificate|null} [certificate] NetworkBinding certificate
         */

        /**
         * Constructs a new NetworkBinding.
         * @memberof NetworkHandshake
         * @classdesc Represents a NetworkBinding.
         * @implements INetworkBinding
         * @constructor
         * @param {NetworkHandshake.INetworkBinding=} [properties] Properties to set
         */
        function NetworkBinding(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkBinding port.
         * @member {number} port
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         */
        NetworkBinding.prototype.port = 0;

        /**
         * NetworkBinding certificate.
         * @member {ICertificate|null|undefined} certificate
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         */
        NetworkBinding.prototype.certificate = null;

        /**
         * Creates a new NetworkBinding instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding=} [properties] Properties to set
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding instance
         */
        NetworkBinding.create = function create(properties) {
            return new NetworkBinding(properties);
        };

        /**
         * Encodes the specified NetworkBinding message. Does not implicitly {@link NetworkHandshake.NetworkBinding.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding} message NetworkBinding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBinding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.port);
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NetworkBinding message, length delimited. Does not implicitly {@link NetworkHandshake.NetworkBinding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.INetworkBinding} message NetworkBinding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBinding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkBinding message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBinding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.NetworkBinding();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.port = reader.uint32();
                    break;
                case 2:
                    message.certificate = $root.Certificate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkBinding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBinding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkBinding message.
         * @function verify
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkBinding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.certificate != null && message.hasOwnProperty("certificate")) {
                let error = $root.Certificate.verify(message.certificate);
                if (error)
                    return "certificate." + error;
            }
            return null;
        };

        /**
         * Creates a NetworkBinding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.NetworkBinding} NetworkBinding
         */
        NetworkBinding.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.NetworkBinding)
                return object;
            let message = new $root.NetworkHandshake.NetworkBinding();
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.certificate != null) {
                if (typeof object.certificate !== "object")
                    throw TypeError(".NetworkHandshake.NetworkBinding.certificate: object expected");
                message.certificate = $root.Certificate.fromObject(object.certificate);
            }
            return message;
        };

        /**
         * Creates a plain object from a NetworkBinding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.NetworkBinding
         * @static
         * @param {NetworkHandshake.NetworkBinding} message NetworkBinding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkBinding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.port = 0;
                object.certificate = null;
            }
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = $root.Certificate.toObject(message.certificate, options);
            return object;
        };

        /**
         * Converts this NetworkBinding to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.NetworkBinding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkBinding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkBinding;
    })();

    NetworkHandshake.NetworkBindings = (function() {

        /**
         * Properties of a NetworkBindings.
         * @memberof NetworkHandshake
         * @interface INetworkBindings
         * @property {Array.<NetworkHandshake.INetworkBinding>|null} [networkBindings] NetworkBindings networkBindings
         */

        /**
         * Constructs a new NetworkBindings.
         * @memberof NetworkHandshake
         * @classdesc Represents a NetworkBindings.
         * @implements INetworkBindings
         * @constructor
         * @param {NetworkHandshake.INetworkBindings=} [properties] Properties to set
         */
        function NetworkBindings(properties) {
            this.networkBindings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkBindings networkBindings.
         * @member {Array.<NetworkHandshake.INetworkBinding>} networkBindings
         * @memberof NetworkHandshake.NetworkBindings
         * @instance
         */
        NetworkBindings.prototype.networkBindings = $util.emptyArray;

        /**
         * Creates a new NetworkBindings instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings=} [properties] Properties to set
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings instance
         */
        NetworkBindings.create = function create(properties) {
            return new NetworkBindings(properties);
        };

        /**
         * Encodes the specified NetworkBindings message. Does not implicitly {@link NetworkHandshake.NetworkBindings.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings} message NetworkBindings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBindings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkBindings != null && message.networkBindings.length)
                for (let i = 0; i < message.networkBindings.length; ++i)
                    $root.NetworkHandshake.NetworkBinding.encode(message.networkBindings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NetworkBindings message, length delimited. Does not implicitly {@link NetworkHandshake.NetworkBindings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.INetworkBindings} message NetworkBindings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkBindings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkBindings message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBindings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.NetworkBindings();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.networkBindings && message.networkBindings.length))
                        message.networkBindings = [];
                    message.networkBindings.push($root.NetworkHandshake.NetworkBinding.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkBindings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkBindings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkBindings message.
         * @function verify
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkBindings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkBindings != null && message.hasOwnProperty("networkBindings")) {
                if (!Array.isArray(message.networkBindings))
                    return "networkBindings: array expected";
                for (let i = 0; i < message.networkBindings.length; ++i) {
                    let error = $root.NetworkHandshake.NetworkBinding.verify(message.networkBindings[i]);
                    if (error)
                        return "networkBindings." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NetworkBindings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.NetworkBindings} NetworkBindings
         */
        NetworkBindings.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.NetworkBindings)
                return object;
            let message = new $root.NetworkHandshake.NetworkBindings();
            if (object.networkBindings) {
                if (!Array.isArray(object.networkBindings))
                    throw TypeError(".NetworkHandshake.NetworkBindings.networkBindings: array expected");
                message.networkBindings = [];
                for (let i = 0; i < object.networkBindings.length; ++i) {
                    if (typeof object.networkBindings[i] !== "object")
                        throw TypeError(".NetworkHandshake.NetworkBindings.networkBindings: object expected");
                    message.networkBindings[i] = $root.NetworkHandshake.NetworkBinding.fromObject(object.networkBindings[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NetworkBindings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.NetworkBindings
         * @static
         * @param {NetworkHandshake.NetworkBindings} message NetworkBindings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkBindings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.networkBindings = [];
            if (message.networkBindings && message.networkBindings.length) {
                object.networkBindings = [];
                for (let j = 0; j < message.networkBindings.length; ++j)
                    object.networkBindings[j] = $root.NetworkHandshake.NetworkBinding.toObject(message.networkBindings[j], options);
            }
            return object;
        };

        /**
         * Converts this NetworkBindings to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.NetworkBindings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkBindings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkBindings;
    })();

    NetworkHandshake.CertificateUpgradeOffer = (function() {

        /**
         * Properties of a CertificateUpgradeOffer.
         * @memberof NetworkHandshake
         * @interface ICertificateUpgradeOffer
         * @property {Array.<Uint8Array>|null} [networkKeys] CertificateUpgradeOffer networkKeys
         */

        /**
         * Constructs a new CertificateUpgradeOffer.
         * @memberof NetworkHandshake
         * @classdesc Represents a CertificateUpgradeOffer.
         * @implements ICertificateUpgradeOffer
         * @constructor
         * @param {NetworkHandshake.ICertificateUpgradeOffer=} [properties] Properties to set
         */
        function CertificateUpgradeOffer(properties) {
            this.networkKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertificateUpgradeOffer networkKeys.
         * @member {Array.<Uint8Array>} networkKeys
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @instance
         */
        CertificateUpgradeOffer.prototype.networkKeys = $util.emptyArray;

        /**
         * Creates a new CertificateUpgradeOffer instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeOffer=} [properties] Properties to set
         * @returns {NetworkHandshake.CertificateUpgradeOffer} CertificateUpgradeOffer instance
         */
        CertificateUpgradeOffer.create = function create(properties) {
            return new CertificateUpgradeOffer(properties);
        };

        /**
         * Encodes the specified CertificateUpgradeOffer message. Does not implicitly {@link NetworkHandshake.CertificateUpgradeOffer.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeOffer} message CertificateUpgradeOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkKeys != null && message.networkKeys.length)
                for (let i = 0; i < message.networkKeys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKeys[i]);
            return writer;
        };

        /**
         * Encodes the specified CertificateUpgradeOffer message, length delimited. Does not implicitly {@link NetworkHandshake.CertificateUpgradeOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeOffer} message CertificateUpgradeOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertificateUpgradeOffer message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.CertificateUpgradeOffer} CertificateUpgradeOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.CertificateUpgradeOffer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.networkKeys && message.networkKeys.length))
                        message.networkKeys = [];
                    message.networkKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertificateUpgradeOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.CertificateUpgradeOffer} CertificateUpgradeOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertificateUpgradeOffer message.
         * @function verify
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertificateUpgradeOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkKeys != null && message.hasOwnProperty("networkKeys")) {
                if (!Array.isArray(message.networkKeys))
                    return "networkKeys: array expected";
                for (let i = 0; i < message.networkKeys.length; ++i)
                    if (!(message.networkKeys[i] && typeof message.networkKeys[i].length === "number" || $util.isString(message.networkKeys[i])))
                        return "networkKeys: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CertificateUpgradeOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.CertificateUpgradeOffer} CertificateUpgradeOffer
         */
        CertificateUpgradeOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.CertificateUpgradeOffer)
                return object;
            let message = new $root.NetworkHandshake.CertificateUpgradeOffer();
            if (object.networkKeys) {
                if (!Array.isArray(object.networkKeys))
                    throw TypeError(".NetworkHandshake.CertificateUpgradeOffer.networkKeys: array expected");
                message.networkKeys = [];
                for (let i = 0; i < object.networkKeys.length; ++i)
                    if (typeof object.networkKeys[i] === "string")
                        $util.base64.decode(object.networkKeys[i], message.networkKeys[i] = $util.newBuffer($util.base64.length(object.networkKeys[i])), 0);
                    else if (object.networkKeys[i].length)
                        message.networkKeys[i] = object.networkKeys[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CertificateUpgradeOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @static
         * @param {NetworkHandshake.CertificateUpgradeOffer} message CertificateUpgradeOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertificateUpgradeOffer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.networkKeys = [];
            if (message.networkKeys && message.networkKeys.length) {
                object.networkKeys = [];
                for (let j = 0; j < message.networkKeys.length; ++j)
                    object.networkKeys[j] = options.bytes === String ? $util.base64.encode(message.networkKeys[j], 0, message.networkKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKeys[j]) : message.networkKeys[j];
            }
            return object;
        };

        /**
         * Converts this CertificateUpgradeOffer to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.CertificateUpgradeOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertificateUpgradeOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CertificateUpgradeOffer;
    })();

    NetworkHandshake.CertificateUpgradeRequest = (function() {

        /**
         * Properties of a CertificateUpgradeRequest.
         * @memberof NetworkHandshake
         * @interface ICertificateUpgradeRequest
         * @property {Array.<Uint8Array>|null} [networkKeys] CertificateUpgradeRequest networkKeys
         */

        /**
         * Constructs a new CertificateUpgradeRequest.
         * @memberof NetworkHandshake
         * @classdesc Represents a CertificateUpgradeRequest.
         * @implements ICertificateUpgradeRequest
         * @constructor
         * @param {NetworkHandshake.ICertificateUpgradeRequest=} [properties] Properties to set
         */
        function CertificateUpgradeRequest(properties) {
            this.networkKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertificateUpgradeRequest networkKeys.
         * @member {Array.<Uint8Array>} networkKeys
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @instance
         */
        CertificateUpgradeRequest.prototype.networkKeys = $util.emptyArray;

        /**
         * Creates a new CertificateUpgradeRequest instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeRequest=} [properties] Properties to set
         * @returns {NetworkHandshake.CertificateUpgradeRequest} CertificateUpgradeRequest instance
         */
        CertificateUpgradeRequest.create = function create(properties) {
            return new CertificateUpgradeRequest(properties);
        };

        /**
         * Encodes the specified CertificateUpgradeRequest message. Does not implicitly {@link NetworkHandshake.CertificateUpgradeRequest.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeRequest} message CertificateUpgradeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkKeys != null && message.networkKeys.length)
                for (let i = 0; i < message.networkKeys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.networkKeys[i]);
            return writer;
        };

        /**
         * Encodes the specified CertificateUpgradeRequest message, length delimited. Does not implicitly {@link NetworkHandshake.CertificateUpgradeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeRequest} message CertificateUpgradeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertificateUpgradeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.CertificateUpgradeRequest} CertificateUpgradeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.CertificateUpgradeRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.networkKeys && message.networkKeys.length))
                        message.networkKeys = [];
                    message.networkKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertificateUpgradeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.CertificateUpgradeRequest} CertificateUpgradeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertificateUpgradeRequest message.
         * @function verify
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertificateUpgradeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.networkKeys != null && message.hasOwnProperty("networkKeys")) {
                if (!Array.isArray(message.networkKeys))
                    return "networkKeys: array expected";
                for (let i = 0; i < message.networkKeys.length; ++i)
                    if (!(message.networkKeys[i] && typeof message.networkKeys[i].length === "number" || $util.isString(message.networkKeys[i])))
                        return "networkKeys: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CertificateUpgradeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.CertificateUpgradeRequest} CertificateUpgradeRequest
         */
        CertificateUpgradeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.CertificateUpgradeRequest)
                return object;
            let message = new $root.NetworkHandshake.CertificateUpgradeRequest();
            if (object.networkKeys) {
                if (!Array.isArray(object.networkKeys))
                    throw TypeError(".NetworkHandshake.CertificateUpgradeRequest.networkKeys: array expected");
                message.networkKeys = [];
                for (let i = 0; i < object.networkKeys.length; ++i)
                    if (typeof object.networkKeys[i] === "string")
                        $util.base64.decode(object.networkKeys[i], message.networkKeys[i] = $util.newBuffer($util.base64.length(object.networkKeys[i])), 0);
                    else if (object.networkKeys[i].length)
                        message.networkKeys[i] = object.networkKeys[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CertificateUpgradeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @static
         * @param {NetworkHandshake.CertificateUpgradeRequest} message CertificateUpgradeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertificateUpgradeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.networkKeys = [];
            if (message.networkKeys && message.networkKeys.length) {
                object.networkKeys = [];
                for (let j = 0; j < message.networkKeys.length; ++j)
                    object.networkKeys[j] = options.bytes === String ? $util.base64.encode(message.networkKeys[j], 0, message.networkKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.networkKeys[j]) : message.networkKeys[j];
            }
            return object;
        };

        /**
         * Converts this CertificateUpgradeRequest to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.CertificateUpgradeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertificateUpgradeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CertificateUpgradeRequest;
    })();

    NetworkHandshake.CertificateUpgradeResponse = (function() {

        /**
         * Properties of a CertificateUpgradeResponse.
         * @memberof NetworkHandshake
         * @interface ICertificateUpgradeResponse
         * @property {Array.<ICertificate>|null} [certificates] CertificateUpgradeResponse certificates
         */

        /**
         * Constructs a new CertificateUpgradeResponse.
         * @memberof NetworkHandshake
         * @classdesc Represents a CertificateUpgradeResponse.
         * @implements ICertificateUpgradeResponse
         * @constructor
         * @param {NetworkHandshake.ICertificateUpgradeResponse=} [properties] Properties to set
         */
        function CertificateUpgradeResponse(properties) {
            this.certificates = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertificateUpgradeResponse certificates.
         * @member {Array.<ICertificate>} certificates
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @instance
         */
        CertificateUpgradeResponse.prototype.certificates = $util.emptyArray;

        /**
         * Creates a new CertificateUpgradeResponse instance using the specified properties.
         * @function create
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeResponse=} [properties] Properties to set
         * @returns {NetworkHandshake.CertificateUpgradeResponse} CertificateUpgradeResponse instance
         */
        CertificateUpgradeResponse.create = function create(properties) {
            return new CertificateUpgradeResponse(properties);
        };

        /**
         * Encodes the specified CertificateUpgradeResponse message. Does not implicitly {@link NetworkHandshake.CertificateUpgradeResponse.verify|verify} messages.
         * @function encode
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeResponse} message CertificateUpgradeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificates != null && message.certificates.length)
                for (let i = 0; i < message.certificates.length; ++i)
                    $root.Certificate.encode(message.certificates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CertificateUpgradeResponse message, length delimited. Does not implicitly {@link NetworkHandshake.CertificateUpgradeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {NetworkHandshake.ICertificateUpgradeResponse} message CertificateUpgradeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateUpgradeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertificateUpgradeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NetworkHandshake.CertificateUpgradeResponse} CertificateUpgradeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NetworkHandshake.CertificateUpgradeResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.certificates && message.certificates.length))
                        message.certificates = [];
                    message.certificates.push($root.Certificate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertificateUpgradeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NetworkHandshake.CertificateUpgradeResponse} CertificateUpgradeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateUpgradeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertificateUpgradeResponse message.
         * @function verify
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertificateUpgradeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.certificates != null && message.hasOwnProperty("certificates")) {
                if (!Array.isArray(message.certificates))
                    return "certificates: array expected";
                for (let i = 0; i < message.certificates.length; ++i) {
                    let error = $root.Certificate.verify(message.certificates[i]);
                    if (error)
                        return "certificates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CertificateUpgradeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NetworkHandshake.CertificateUpgradeResponse} CertificateUpgradeResponse
         */
        CertificateUpgradeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.NetworkHandshake.CertificateUpgradeResponse)
                return object;
            let message = new $root.NetworkHandshake.CertificateUpgradeResponse();
            if (object.certificates) {
                if (!Array.isArray(object.certificates))
                    throw TypeError(".NetworkHandshake.CertificateUpgradeResponse.certificates: array expected");
                message.certificates = [];
                for (let i = 0; i < object.certificates.length; ++i) {
                    if (typeof object.certificates[i] !== "object")
                        throw TypeError(".NetworkHandshake.CertificateUpgradeResponse.certificates: object expected");
                    message.certificates[i] = $root.Certificate.fromObject(object.certificates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CertificateUpgradeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @static
         * @param {NetworkHandshake.CertificateUpgradeResponse} message CertificateUpgradeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertificateUpgradeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.certificates = [];
            if (message.certificates && message.certificates.length) {
                object.certificates = [];
                for (let j = 0; j < message.certificates.length; ++j)
                    object.certificates[j] = $root.Certificate.toObject(message.certificates[j], options);
            }
            return object;
        };

        /**
         * Converts this CertificateUpgradeResponse to JSON.
         * @function toJSON
         * @memberof NetworkHandshake.CertificateUpgradeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertificateUpgradeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CertificateUpgradeResponse;
    })();

    return NetworkHandshake;
})();

export const BrokerProxyRequest = $root.BrokerProxyRequest = (() => {

    /**
     * Properties of a BrokerProxyRequest.
     * @exports IBrokerProxyRequest
     * @interface IBrokerProxyRequest
     * @property {number|null} [connMtu] BrokerProxyRequest connMtu
     */

    /**
     * Constructs a new BrokerProxyRequest.
     * @exports BrokerProxyRequest
     * @classdesc Represents a BrokerProxyRequest.
     * @implements IBrokerProxyRequest
     * @constructor
     * @param {IBrokerProxyRequest=} [properties] Properties to set
     */
    function BrokerProxyRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyRequest connMtu.
     * @member {number} connMtu
     * @memberof BrokerProxyRequest
     * @instance
     */
    BrokerProxyRequest.prototype.connMtu = 0;

    /**
     * Creates a new BrokerProxyRequest instance using the specified properties.
     * @function create
     * @memberof BrokerProxyRequest
     * @static
     * @param {IBrokerProxyRequest=} [properties] Properties to set
     * @returns {BrokerProxyRequest} BrokerProxyRequest instance
     */
    BrokerProxyRequest.create = function create(properties) {
        return new BrokerProxyRequest(properties);
    };

    /**
     * Encodes the specified BrokerProxyRequest message. Does not implicitly {@link BrokerProxyRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyRequest
     * @static
     * @param {IBrokerProxyRequest} message BrokerProxyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connMtu != null && Object.hasOwnProperty.call(message, "connMtu"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.connMtu);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyRequest message, length delimited. Does not implicitly {@link BrokerProxyRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyRequest
     * @static
     * @param {IBrokerProxyRequest} message BrokerProxyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyRequest} BrokerProxyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.connMtu = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyRequest} BrokerProxyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyRequest message.
     * @function verify
     * @memberof BrokerProxyRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connMtu != null && message.hasOwnProperty("connMtu"))
            if (!$util.isInteger(message.connMtu))
                return "connMtu: integer expected";
        return null;
    };

    /**
     * Creates a BrokerProxyRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyRequest} BrokerProxyRequest
     */
    BrokerProxyRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyRequest)
            return object;
        let message = new $root.BrokerProxyRequest();
        if (object.connMtu != null)
            message.connMtu = object.connMtu | 0;
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyRequest
     * @static
     * @param {BrokerProxyRequest} message BrokerProxyRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connMtu = 0;
        if (message.connMtu != null && message.hasOwnProperty("connMtu"))
            object.connMtu = message.connMtu;
        return object;
    };

    /**
     * Converts this BrokerProxyRequest to JSON.
     * @function toJSON
     * @memberof BrokerProxyRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyRequest;
})();

export const BrokerProxyEvent = $root.BrokerProxyEvent = (() => {

    /**
     * Properties of a BrokerProxyEvent.
     * @exports IBrokerProxyEvent
     * @interface IBrokerProxyEvent
     * @property {BrokerProxyEvent.IOpen|null} [open] BrokerProxyEvent open
     * @property {BrokerProxyEvent.IData|null} [data] BrokerProxyEvent data
     * @property {BrokerProxyEvent.IRead|null} [read] BrokerProxyEvent read
     */

    /**
     * Constructs a new BrokerProxyEvent.
     * @exports BrokerProxyEvent
     * @classdesc Represents a BrokerProxyEvent.
     * @implements IBrokerProxyEvent
     * @constructor
     * @param {IBrokerProxyEvent=} [properties] Properties to set
     */
    function BrokerProxyEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyEvent open.
     * @member {BrokerProxyEvent.IOpen|null|undefined} open
     * @memberof BrokerProxyEvent
     * @instance
     */
    BrokerProxyEvent.prototype.open = null;

    /**
     * BrokerProxyEvent data.
     * @member {BrokerProxyEvent.IData|null|undefined} data
     * @memberof BrokerProxyEvent
     * @instance
     */
    BrokerProxyEvent.prototype.data = null;

    /**
     * BrokerProxyEvent read.
     * @member {BrokerProxyEvent.IRead|null|undefined} read
     * @memberof BrokerProxyEvent
     * @instance
     */
    BrokerProxyEvent.prototype.read = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BrokerProxyEvent body.
     * @member {"open"|"data"|"read"|undefined} body
     * @memberof BrokerProxyEvent
     * @instance
     */
    Object.defineProperty(BrokerProxyEvent.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["open", "data", "read"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BrokerProxyEvent instance using the specified properties.
     * @function create
     * @memberof BrokerProxyEvent
     * @static
     * @param {IBrokerProxyEvent=} [properties] Properties to set
     * @returns {BrokerProxyEvent} BrokerProxyEvent instance
     */
    BrokerProxyEvent.create = function create(properties) {
        return new BrokerProxyEvent(properties);
    };

    /**
     * Encodes the specified BrokerProxyEvent message. Does not implicitly {@link BrokerProxyEvent.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyEvent
     * @static
     * @param {IBrokerProxyEvent} message BrokerProxyEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.open != null && Object.hasOwnProperty.call(message, "open"))
            $root.BrokerProxyEvent.Open.encode(message.open, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            $root.BrokerProxyEvent.Data.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.read != null && Object.hasOwnProperty.call(message, "read"))
            $root.BrokerProxyEvent.Read.encode(message.read, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyEvent message, length delimited. Does not implicitly {@link BrokerProxyEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyEvent
     * @static
     * @param {IBrokerProxyEvent} message BrokerProxyEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyEvent message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyEvent} BrokerProxyEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.open = $root.BrokerProxyEvent.Open.decode(reader, reader.uint32());
                break;
            case 2:
                message.data = $root.BrokerProxyEvent.Data.decode(reader, reader.uint32());
                break;
            case 3:
                message.read = $root.BrokerProxyEvent.Read.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyEvent} BrokerProxyEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyEvent message.
     * @function verify
     * @memberof BrokerProxyEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            properties.body = 1;
            {
                let error = $root.BrokerProxyEvent.Open.verify(message.open);
                if (error)
                    return "open." + error;
            }
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BrokerProxyEvent.Data.verify(message.data);
                if (error)
                    return "data." + error;
            }
        }
        if (message.read != null && message.hasOwnProperty("read")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BrokerProxyEvent.Read.verify(message.read);
                if (error)
                    return "read." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BrokerProxyEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyEvent} BrokerProxyEvent
     */
    BrokerProxyEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyEvent)
            return object;
        let message = new $root.BrokerProxyEvent();
        if (object.open != null) {
            if (typeof object.open !== "object")
                throw TypeError(".BrokerProxyEvent.open: object expected");
            message.open = $root.BrokerProxyEvent.Open.fromObject(object.open);
        }
        if (object.data != null) {
            if (typeof object.data !== "object")
                throw TypeError(".BrokerProxyEvent.data: object expected");
            message.data = $root.BrokerProxyEvent.Data.fromObject(object.data);
        }
        if (object.read != null) {
            if (typeof object.read !== "object")
                throw TypeError(".BrokerProxyEvent.read: object expected");
            message.read = $root.BrokerProxyEvent.Read.fromObject(object.read);
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyEvent
     * @static
     * @param {BrokerProxyEvent} message BrokerProxyEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.open != null && message.hasOwnProperty("open")) {
            object.open = $root.BrokerProxyEvent.Open.toObject(message.open, options);
            if (options.oneofs)
                object.body = "open";
        }
        if (message.data != null && message.hasOwnProperty("data")) {
            object.data = $root.BrokerProxyEvent.Data.toObject(message.data, options);
            if (options.oneofs)
                object.body = "data";
        }
        if (message.read != null && message.hasOwnProperty("read")) {
            object.read = $root.BrokerProxyEvent.Read.toObject(message.read, options);
            if (options.oneofs)
                object.body = "read";
        }
        return object;
    };

    /**
     * Converts this BrokerProxyEvent to JSON.
     * @function toJSON
     * @memberof BrokerProxyEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    BrokerProxyEvent.Open = (function() {

        /**
         * Properties of an Open.
         * @memberof BrokerProxyEvent
         * @interface IOpen
         * @property {number|null} [proxyId] Open proxyId
         */

        /**
         * Constructs a new Open.
         * @memberof BrokerProxyEvent
         * @classdesc Represents an Open.
         * @implements IOpen
         * @constructor
         * @param {BrokerProxyEvent.IOpen=} [properties] Properties to set
         */
        function Open(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open proxyId.
         * @member {number} proxyId
         * @memberof BrokerProxyEvent.Open
         * @instance
         */
        Open.prototype.proxyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Open instance using the specified properties.
         * @function create
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {BrokerProxyEvent.IOpen=} [properties] Properties to set
         * @returns {BrokerProxyEvent.Open} Open instance
         */
        Open.create = function create(properties) {
            return new Open(properties);
        };

        /**
         * Encodes the specified Open message. Does not implicitly {@link BrokerProxyEvent.Open.verify|verify} messages.
         * @function encode
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {BrokerProxyEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.proxyId != null && Object.hasOwnProperty.call(message, "proxyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.proxyId);
            return writer;
        };

        /**
         * Encodes the specified Open message, length delimited. Does not implicitly {@link BrokerProxyEvent.Open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {BrokerProxyEvent.IOpen} message Open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Open message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerProxyEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyEvent.Open();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.proxyId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerProxyEvent.Open} Open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Open message.
         * @function verify
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.proxyId != null && message.hasOwnProperty("proxyId"))
                if (!$util.isInteger(message.proxyId) && !(message.proxyId && $util.isInteger(message.proxyId.low) && $util.isInteger(message.proxyId.high)))
                    return "proxyId: integer|Long expected";
            return null;
        };

        /**
         * Creates an Open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerProxyEvent.Open} Open
         */
        Open.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerProxyEvent.Open)
                return object;
            let message = new $root.BrokerProxyEvent.Open();
            if (object.proxyId != null)
                if ($util.Long)
                    (message.proxyId = $util.Long.fromValue(object.proxyId)).unsigned = true;
                else if (typeof object.proxyId === "string")
                    message.proxyId = parseInt(object.proxyId, 10);
                else if (typeof object.proxyId === "number")
                    message.proxyId = object.proxyId;
                else if (typeof object.proxyId === "object")
                    message.proxyId = new $util.LongBits(object.proxyId.low >>> 0, object.proxyId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerProxyEvent.Open
         * @static
         * @param {BrokerProxyEvent.Open} message Open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.proxyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proxyId = options.longs === String ? "0" : 0;
            if (message.proxyId != null && message.hasOwnProperty("proxyId"))
                if (typeof message.proxyId === "number")
                    object.proxyId = options.longs === String ? String(message.proxyId) : message.proxyId;
                else
                    object.proxyId = options.longs === String ? $util.Long.prototype.toString.call(message.proxyId) : options.longs === Number ? new $util.LongBits(message.proxyId.low >>> 0, message.proxyId.high >>> 0).toNumber(true) : message.proxyId;
            return object;
        };

        /**
         * Converts this Open to JSON.
         * @function toJSON
         * @memberof BrokerProxyEvent.Open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Open;
    })();

    BrokerProxyEvent.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof BrokerProxyEvent
         * @interface IData
         * @property {Uint8Array|null} [data] Data data
         */

        /**
         * Constructs a new Data.
         * @memberof BrokerProxyEvent
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {BrokerProxyEvent.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data data.
         * @member {Uint8Array} data
         * @memberof BrokerProxyEvent.Data
         * @instance
         */
        Data.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {BrokerProxyEvent.IData=} [properties] Properties to set
         * @returns {BrokerProxyEvent.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link BrokerProxyEvent.Data.verify|verify} messages.
         * @function encode
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {BrokerProxyEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link BrokerProxyEvent.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {BrokerProxyEvent.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerProxyEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyEvent.Data();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerProxyEvent.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerProxyEvent.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerProxyEvent.Data)
                return object;
            let message = new $root.BrokerProxyEvent.Data();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerProxyEvent.Data
         * @static
         * @param {BrokerProxyEvent.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof BrokerProxyEvent.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Data;
    })();

    BrokerProxyEvent.Read = (function() {

        /**
         * Properties of a Read.
         * @memberof BrokerProxyEvent
         * @interface IRead
         */

        /**
         * Constructs a new Read.
         * @memberof BrokerProxyEvent
         * @classdesc Represents a Read.
         * @implements IRead
         * @constructor
         * @param {BrokerProxyEvent.IRead=} [properties] Properties to set
         */
        function Read(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Read instance using the specified properties.
         * @function create
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {BrokerProxyEvent.IRead=} [properties] Properties to set
         * @returns {BrokerProxyEvent.Read} Read instance
         */
        Read.create = function create(properties) {
            return new Read(properties);
        };

        /**
         * Encodes the specified Read message. Does not implicitly {@link BrokerProxyEvent.Read.verify|verify} messages.
         * @function encode
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {BrokerProxyEvent.IRead} message Read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Read.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Read message, length delimited. Does not implicitly {@link BrokerProxyEvent.Read.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {BrokerProxyEvent.IRead} message Read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Read.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Read message from the specified reader or buffer.
         * @function decode
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BrokerProxyEvent.Read} Read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Read.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyEvent.Read();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Read message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BrokerProxyEvent.Read} Read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Read.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Read message.
         * @function verify
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Read.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Read message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BrokerProxyEvent.Read} Read
         */
        Read.fromObject = function fromObject(object) {
            if (object instanceof $root.BrokerProxyEvent.Read)
                return object;
            return new $root.BrokerProxyEvent.Read();
        };

        /**
         * Creates a plain object from a Read message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BrokerProxyEvent.Read
         * @static
         * @param {BrokerProxyEvent.Read} message Read
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Read.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Read to JSON.
         * @function toJSON
         * @memberof BrokerProxyEvent.Read
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Read.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Read;
    })();

    return BrokerProxyEvent;
})();

export const BrokerProxySendKeysRequest = $root.BrokerProxySendKeysRequest = (() => {

    /**
     * Properties of a BrokerProxySendKeysRequest.
     * @exports IBrokerProxySendKeysRequest
     * @interface IBrokerProxySendKeysRequest
     * @property {number|null} [proxyId] BrokerProxySendKeysRequest proxyId
     * @property {Array.<Uint8Array>|null} [keys] BrokerProxySendKeysRequest keys
     */

    /**
     * Constructs a new BrokerProxySendKeysRequest.
     * @exports BrokerProxySendKeysRequest
     * @classdesc Represents a BrokerProxySendKeysRequest.
     * @implements IBrokerProxySendKeysRequest
     * @constructor
     * @param {IBrokerProxySendKeysRequest=} [properties] Properties to set
     */
    function BrokerProxySendKeysRequest(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxySendKeysRequest proxyId.
     * @member {number} proxyId
     * @memberof BrokerProxySendKeysRequest
     * @instance
     */
    BrokerProxySendKeysRequest.prototype.proxyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BrokerProxySendKeysRequest keys.
     * @member {Array.<Uint8Array>} keys
     * @memberof BrokerProxySendKeysRequest
     * @instance
     */
    BrokerProxySendKeysRequest.prototype.keys = $util.emptyArray;

    /**
     * Creates a new BrokerProxySendKeysRequest instance using the specified properties.
     * @function create
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {IBrokerProxySendKeysRequest=} [properties] Properties to set
     * @returns {BrokerProxySendKeysRequest} BrokerProxySendKeysRequest instance
     */
    BrokerProxySendKeysRequest.create = function create(properties) {
        return new BrokerProxySendKeysRequest(properties);
    };

    /**
     * Encodes the specified BrokerProxySendKeysRequest message. Does not implicitly {@link BrokerProxySendKeysRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {IBrokerProxySendKeysRequest} message BrokerProxySendKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxySendKeysRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.proxyId != null && Object.hasOwnProperty.call(message, "proxyId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.proxyId);
        if (message.keys != null && message.keys.length)
            for (let i = 0; i < message.keys.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys[i]);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxySendKeysRequest message, length delimited. Does not implicitly {@link BrokerProxySendKeysRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {IBrokerProxySendKeysRequest} message BrokerProxySendKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxySendKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxySendKeysRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxySendKeysRequest} BrokerProxySendKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxySendKeysRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxySendKeysRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.proxyId = reader.uint64();
                break;
            case 2:
                if (!(message.keys && message.keys.length))
                    message.keys = [];
                message.keys.push(reader.bytes());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxySendKeysRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxySendKeysRequest} BrokerProxySendKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxySendKeysRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxySendKeysRequest message.
     * @function verify
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxySendKeysRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (!$util.isInteger(message.proxyId) && !(message.proxyId && $util.isInteger(message.proxyId.low) && $util.isInteger(message.proxyId.high)))
                return "proxyId: integer|Long expected";
        if (message.keys != null && message.hasOwnProperty("keys")) {
            if (!Array.isArray(message.keys))
                return "keys: array expected";
            for (let i = 0; i < message.keys.length; ++i)
                if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                    return "keys: buffer[] expected";
        }
        return null;
    };

    /**
     * Creates a BrokerProxySendKeysRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxySendKeysRequest} BrokerProxySendKeysRequest
     */
    BrokerProxySendKeysRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxySendKeysRequest)
            return object;
        let message = new $root.BrokerProxySendKeysRequest();
        if (object.proxyId != null)
            if ($util.Long)
                (message.proxyId = $util.Long.fromValue(object.proxyId)).unsigned = true;
            else if (typeof object.proxyId === "string")
                message.proxyId = parseInt(object.proxyId, 10);
            else if (typeof object.proxyId === "number")
                message.proxyId = object.proxyId;
            else if (typeof object.proxyId === "object")
                message.proxyId = new $util.LongBits(object.proxyId.low >>> 0, object.proxyId.high >>> 0).toNumber(true);
        if (object.keys) {
            if (!Array.isArray(object.keys))
                throw TypeError(".BrokerProxySendKeysRequest.keys: array expected");
            message.keys = [];
            for (let i = 0; i < object.keys.length; ++i)
                if (typeof object.keys[i] === "string")
                    $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                else if (object.keys[i].length)
                    message.keys[i] = object.keys[i];
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxySendKeysRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxySendKeysRequest
     * @static
     * @param {BrokerProxySendKeysRequest} message BrokerProxySendKeysRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxySendKeysRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.keys = [];
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.proxyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.proxyId = options.longs === String ? "0" : 0;
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (typeof message.proxyId === "number")
                object.proxyId = options.longs === String ? String(message.proxyId) : message.proxyId;
            else
                object.proxyId = options.longs === String ? $util.Long.prototype.toString.call(message.proxyId) : options.longs === Number ? new $util.LongBits(message.proxyId.low >>> 0, message.proxyId.high >>> 0).toNumber(true) : message.proxyId;
        if (message.keys && message.keys.length) {
            object.keys = [];
            for (let j = 0; j < message.keys.length; ++j)
                object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
        }
        return object;
    };

    /**
     * Converts this BrokerProxySendKeysRequest to JSON.
     * @function toJSON
     * @memberof BrokerProxySendKeysRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxySendKeysRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxySendKeysRequest;
})();

export const BrokerProxySendKeysResponse = $root.BrokerProxySendKeysResponse = (() => {

    /**
     * Properties of a BrokerProxySendKeysResponse.
     * @exports IBrokerProxySendKeysResponse
     * @interface IBrokerProxySendKeysResponse
     */

    /**
     * Constructs a new BrokerProxySendKeysResponse.
     * @exports BrokerProxySendKeysResponse
     * @classdesc Represents a BrokerProxySendKeysResponse.
     * @implements IBrokerProxySendKeysResponse
     * @constructor
     * @param {IBrokerProxySendKeysResponse=} [properties] Properties to set
     */
    function BrokerProxySendKeysResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BrokerProxySendKeysResponse instance using the specified properties.
     * @function create
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {IBrokerProxySendKeysResponse=} [properties] Properties to set
     * @returns {BrokerProxySendKeysResponse} BrokerProxySendKeysResponse instance
     */
    BrokerProxySendKeysResponse.create = function create(properties) {
        return new BrokerProxySendKeysResponse(properties);
    };

    /**
     * Encodes the specified BrokerProxySendKeysResponse message. Does not implicitly {@link BrokerProxySendKeysResponse.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {IBrokerProxySendKeysResponse} message BrokerProxySendKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxySendKeysResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BrokerProxySendKeysResponse message, length delimited. Does not implicitly {@link BrokerProxySendKeysResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {IBrokerProxySendKeysResponse} message BrokerProxySendKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxySendKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxySendKeysResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxySendKeysResponse} BrokerProxySendKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxySendKeysResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxySendKeysResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxySendKeysResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxySendKeysResponse} BrokerProxySendKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxySendKeysResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxySendKeysResponse message.
     * @function verify
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxySendKeysResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BrokerProxySendKeysResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxySendKeysResponse} BrokerProxySendKeysResponse
     */
    BrokerProxySendKeysResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxySendKeysResponse)
            return object;
        return new $root.BrokerProxySendKeysResponse();
    };

    /**
     * Creates a plain object from a BrokerProxySendKeysResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxySendKeysResponse
     * @static
     * @param {BrokerProxySendKeysResponse} message BrokerProxySendKeysResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxySendKeysResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BrokerProxySendKeysResponse to JSON.
     * @function toJSON
     * @memberof BrokerProxySendKeysResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxySendKeysResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxySendKeysResponse;
})();

export const BrokerProxyReceiveKeysRequest = $root.BrokerProxyReceiveKeysRequest = (() => {

    /**
     * Properties of a BrokerProxyReceiveKeysRequest.
     * @exports IBrokerProxyReceiveKeysRequest
     * @interface IBrokerProxyReceiveKeysRequest
     * @property {number|null} [proxyId] BrokerProxyReceiveKeysRequest proxyId
     * @property {Array.<Uint8Array>|null} [keys] BrokerProxyReceiveKeysRequest keys
     */

    /**
     * Constructs a new BrokerProxyReceiveKeysRequest.
     * @exports BrokerProxyReceiveKeysRequest
     * @classdesc Represents a BrokerProxyReceiveKeysRequest.
     * @implements IBrokerProxyReceiveKeysRequest
     * @constructor
     * @param {IBrokerProxyReceiveKeysRequest=} [properties] Properties to set
     */
    function BrokerProxyReceiveKeysRequest(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyReceiveKeysRequest proxyId.
     * @member {number} proxyId
     * @memberof BrokerProxyReceiveKeysRequest
     * @instance
     */
    BrokerProxyReceiveKeysRequest.prototype.proxyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BrokerProxyReceiveKeysRequest keys.
     * @member {Array.<Uint8Array>} keys
     * @memberof BrokerProxyReceiveKeysRequest
     * @instance
     */
    BrokerProxyReceiveKeysRequest.prototype.keys = $util.emptyArray;

    /**
     * Creates a new BrokerProxyReceiveKeysRequest instance using the specified properties.
     * @function create
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {IBrokerProxyReceiveKeysRequest=} [properties] Properties to set
     * @returns {BrokerProxyReceiveKeysRequest} BrokerProxyReceiveKeysRequest instance
     */
    BrokerProxyReceiveKeysRequest.create = function create(properties) {
        return new BrokerProxyReceiveKeysRequest(properties);
    };

    /**
     * Encodes the specified BrokerProxyReceiveKeysRequest message. Does not implicitly {@link BrokerProxyReceiveKeysRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {IBrokerProxyReceiveKeysRequest} message BrokerProxyReceiveKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyReceiveKeysRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.proxyId != null && Object.hasOwnProperty.call(message, "proxyId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.proxyId);
        if (message.keys != null && message.keys.length)
            for (let i = 0; i < message.keys.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys[i]);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyReceiveKeysRequest message, length delimited. Does not implicitly {@link BrokerProxyReceiveKeysRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {IBrokerProxyReceiveKeysRequest} message BrokerProxyReceiveKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyReceiveKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyReceiveKeysRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyReceiveKeysRequest} BrokerProxyReceiveKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyReceiveKeysRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyReceiveKeysRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.proxyId = reader.uint64();
                break;
            case 2:
                if (!(message.keys && message.keys.length))
                    message.keys = [];
                message.keys.push(reader.bytes());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyReceiveKeysRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyReceiveKeysRequest} BrokerProxyReceiveKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyReceiveKeysRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyReceiveKeysRequest message.
     * @function verify
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyReceiveKeysRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (!$util.isInteger(message.proxyId) && !(message.proxyId && $util.isInteger(message.proxyId.low) && $util.isInteger(message.proxyId.high)))
                return "proxyId: integer|Long expected";
        if (message.keys != null && message.hasOwnProperty("keys")) {
            if (!Array.isArray(message.keys))
                return "keys: array expected";
            for (let i = 0; i < message.keys.length; ++i)
                if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                    return "keys: buffer[] expected";
        }
        return null;
    };

    /**
     * Creates a BrokerProxyReceiveKeysRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyReceiveKeysRequest} BrokerProxyReceiveKeysRequest
     */
    BrokerProxyReceiveKeysRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyReceiveKeysRequest)
            return object;
        let message = new $root.BrokerProxyReceiveKeysRequest();
        if (object.proxyId != null)
            if ($util.Long)
                (message.proxyId = $util.Long.fromValue(object.proxyId)).unsigned = true;
            else if (typeof object.proxyId === "string")
                message.proxyId = parseInt(object.proxyId, 10);
            else if (typeof object.proxyId === "number")
                message.proxyId = object.proxyId;
            else if (typeof object.proxyId === "object")
                message.proxyId = new $util.LongBits(object.proxyId.low >>> 0, object.proxyId.high >>> 0).toNumber(true);
        if (object.keys) {
            if (!Array.isArray(object.keys))
                throw TypeError(".BrokerProxyReceiveKeysRequest.keys: array expected");
            message.keys = [];
            for (let i = 0; i < object.keys.length; ++i)
                if (typeof object.keys[i] === "string")
                    $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                else if (object.keys[i].length)
                    message.keys[i] = object.keys[i];
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyReceiveKeysRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyReceiveKeysRequest
     * @static
     * @param {BrokerProxyReceiveKeysRequest} message BrokerProxyReceiveKeysRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyReceiveKeysRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.keys = [];
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.proxyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.proxyId = options.longs === String ? "0" : 0;
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (typeof message.proxyId === "number")
                object.proxyId = options.longs === String ? String(message.proxyId) : message.proxyId;
            else
                object.proxyId = options.longs === String ? $util.Long.prototype.toString.call(message.proxyId) : options.longs === Number ? new $util.LongBits(message.proxyId.low >>> 0, message.proxyId.high >>> 0).toNumber(true) : message.proxyId;
        if (message.keys && message.keys.length) {
            object.keys = [];
            for (let j = 0; j < message.keys.length; ++j)
                object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
        }
        return object;
    };

    /**
     * Converts this BrokerProxyReceiveKeysRequest to JSON.
     * @function toJSON
     * @memberof BrokerProxyReceiveKeysRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyReceiveKeysRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyReceiveKeysRequest;
})();

export const BrokerProxyReceiveKeysResponse = $root.BrokerProxyReceiveKeysResponse = (() => {

    /**
     * Properties of a BrokerProxyReceiveKeysResponse.
     * @exports IBrokerProxyReceiveKeysResponse
     * @interface IBrokerProxyReceiveKeysResponse
     * @property {Array.<Uint8Array>|null} [keys] BrokerProxyReceiveKeysResponse keys
     */

    /**
     * Constructs a new BrokerProxyReceiveKeysResponse.
     * @exports BrokerProxyReceiveKeysResponse
     * @classdesc Represents a BrokerProxyReceiveKeysResponse.
     * @implements IBrokerProxyReceiveKeysResponse
     * @constructor
     * @param {IBrokerProxyReceiveKeysResponse=} [properties] Properties to set
     */
    function BrokerProxyReceiveKeysResponse(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyReceiveKeysResponse keys.
     * @member {Array.<Uint8Array>} keys
     * @memberof BrokerProxyReceiveKeysResponse
     * @instance
     */
    BrokerProxyReceiveKeysResponse.prototype.keys = $util.emptyArray;

    /**
     * Creates a new BrokerProxyReceiveKeysResponse instance using the specified properties.
     * @function create
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {IBrokerProxyReceiveKeysResponse=} [properties] Properties to set
     * @returns {BrokerProxyReceiveKeysResponse} BrokerProxyReceiveKeysResponse instance
     */
    BrokerProxyReceiveKeysResponse.create = function create(properties) {
        return new BrokerProxyReceiveKeysResponse(properties);
    };

    /**
     * Encodes the specified BrokerProxyReceiveKeysResponse message. Does not implicitly {@link BrokerProxyReceiveKeysResponse.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {IBrokerProxyReceiveKeysResponse} message BrokerProxyReceiveKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyReceiveKeysResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.keys != null && message.keys.length)
            for (let i = 0; i < message.keys.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys[i]);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyReceiveKeysResponse message, length delimited. Does not implicitly {@link BrokerProxyReceiveKeysResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {IBrokerProxyReceiveKeysResponse} message BrokerProxyReceiveKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyReceiveKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyReceiveKeysResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyReceiveKeysResponse} BrokerProxyReceiveKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyReceiveKeysResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyReceiveKeysResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.keys && message.keys.length))
                    message.keys = [];
                message.keys.push(reader.bytes());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyReceiveKeysResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyReceiveKeysResponse} BrokerProxyReceiveKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyReceiveKeysResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyReceiveKeysResponse message.
     * @function verify
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyReceiveKeysResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.keys != null && message.hasOwnProperty("keys")) {
            if (!Array.isArray(message.keys))
                return "keys: array expected";
            for (let i = 0; i < message.keys.length; ++i)
                if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                    return "keys: buffer[] expected";
        }
        return null;
    };

    /**
     * Creates a BrokerProxyReceiveKeysResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyReceiveKeysResponse} BrokerProxyReceiveKeysResponse
     */
    BrokerProxyReceiveKeysResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyReceiveKeysResponse)
            return object;
        let message = new $root.BrokerProxyReceiveKeysResponse();
        if (object.keys) {
            if (!Array.isArray(object.keys))
                throw TypeError(".BrokerProxyReceiveKeysResponse.keys: array expected");
            message.keys = [];
            for (let i = 0; i < object.keys.length; ++i)
                if (typeof object.keys[i] === "string")
                    $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                else if (object.keys[i].length)
                    message.keys[i] = object.keys[i];
        }
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyReceiveKeysResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyReceiveKeysResponse
     * @static
     * @param {BrokerProxyReceiveKeysResponse} message BrokerProxyReceiveKeysResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyReceiveKeysResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.keys = [];
        if (message.keys && message.keys.length) {
            object.keys = [];
            for (let j = 0; j < message.keys.length; ++j)
                object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
        }
        return object;
    };

    /**
     * Converts this BrokerProxyReceiveKeysResponse to JSON.
     * @function toJSON
     * @memberof BrokerProxyReceiveKeysResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyReceiveKeysResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyReceiveKeysResponse;
})();

export const BrokerProxyDataRequest = $root.BrokerProxyDataRequest = (() => {

    /**
     * Properties of a BrokerProxyDataRequest.
     * @exports IBrokerProxyDataRequest
     * @interface IBrokerProxyDataRequest
     * @property {number|null} [proxyId] BrokerProxyDataRequest proxyId
     * @property {Uint8Array|null} [data] BrokerProxyDataRequest data
     */

    /**
     * Constructs a new BrokerProxyDataRequest.
     * @exports BrokerProxyDataRequest
     * @classdesc Represents a BrokerProxyDataRequest.
     * @implements IBrokerProxyDataRequest
     * @constructor
     * @param {IBrokerProxyDataRequest=} [properties] Properties to set
     */
    function BrokerProxyDataRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyDataRequest proxyId.
     * @member {number} proxyId
     * @memberof BrokerProxyDataRequest
     * @instance
     */
    BrokerProxyDataRequest.prototype.proxyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BrokerProxyDataRequest data.
     * @member {Uint8Array} data
     * @memberof BrokerProxyDataRequest
     * @instance
     */
    BrokerProxyDataRequest.prototype.data = $util.newBuffer([]);

    /**
     * Creates a new BrokerProxyDataRequest instance using the specified properties.
     * @function create
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {IBrokerProxyDataRequest=} [properties] Properties to set
     * @returns {BrokerProxyDataRequest} BrokerProxyDataRequest instance
     */
    BrokerProxyDataRequest.create = function create(properties) {
        return new BrokerProxyDataRequest(properties);
    };

    /**
     * Encodes the specified BrokerProxyDataRequest message. Does not implicitly {@link BrokerProxyDataRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {IBrokerProxyDataRequest} message BrokerProxyDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyDataRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.proxyId != null && Object.hasOwnProperty.call(message, "proxyId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.proxyId);
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyDataRequest message, length delimited. Does not implicitly {@link BrokerProxyDataRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {IBrokerProxyDataRequest} message BrokerProxyDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyDataRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyDataRequest} BrokerProxyDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyDataRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyDataRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.proxyId = reader.uint64();
                break;
            case 2:
                message.data = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyDataRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyDataRequest} BrokerProxyDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyDataRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyDataRequest message.
     * @function verify
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyDataRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (!$util.isInteger(message.proxyId) && !(message.proxyId && $util.isInteger(message.proxyId.low) && $util.isInteger(message.proxyId.high)))
                return "proxyId: integer|Long expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                return "data: buffer expected";
        return null;
    };

    /**
     * Creates a BrokerProxyDataRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyDataRequest} BrokerProxyDataRequest
     */
    BrokerProxyDataRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyDataRequest)
            return object;
        let message = new $root.BrokerProxyDataRequest();
        if (object.proxyId != null)
            if ($util.Long)
                (message.proxyId = $util.Long.fromValue(object.proxyId)).unsigned = true;
            else if (typeof object.proxyId === "string")
                message.proxyId = parseInt(object.proxyId, 10);
            else if (typeof object.proxyId === "number")
                message.proxyId = object.proxyId;
            else if (typeof object.proxyId === "object")
                message.proxyId = new $util.LongBits(object.proxyId.low >>> 0, object.proxyId.high >>> 0).toNumber(true);
        if (object.data != null)
            if (typeof object.data === "string")
                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            else if (object.data.length)
                message.data = object.data;
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyDataRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyDataRequest
     * @static
     * @param {BrokerProxyDataRequest} message BrokerProxyDataRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyDataRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.proxyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.proxyId = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.data = "";
            else {
                object.data = [];
                if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
            }
        }
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (typeof message.proxyId === "number")
                object.proxyId = options.longs === String ? String(message.proxyId) : message.proxyId;
            else
                object.proxyId = options.longs === String ? $util.Long.prototype.toString.call(message.proxyId) : options.longs === Number ? new $util.LongBits(message.proxyId.low >>> 0, message.proxyId.high >>> 0).toNumber(true) : message.proxyId;
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
        return object;
    };

    /**
     * Converts this BrokerProxyDataRequest to JSON.
     * @function toJSON
     * @memberof BrokerProxyDataRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyDataRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyDataRequest;
})();

export const BrokerProxyDataResponse = $root.BrokerProxyDataResponse = (() => {

    /**
     * Properties of a BrokerProxyDataResponse.
     * @exports IBrokerProxyDataResponse
     * @interface IBrokerProxyDataResponse
     */

    /**
     * Constructs a new BrokerProxyDataResponse.
     * @exports BrokerProxyDataResponse
     * @classdesc Represents a BrokerProxyDataResponse.
     * @implements IBrokerProxyDataResponse
     * @constructor
     * @param {IBrokerProxyDataResponse=} [properties] Properties to set
     */
    function BrokerProxyDataResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BrokerProxyDataResponse instance using the specified properties.
     * @function create
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {IBrokerProxyDataResponse=} [properties] Properties to set
     * @returns {BrokerProxyDataResponse} BrokerProxyDataResponse instance
     */
    BrokerProxyDataResponse.create = function create(properties) {
        return new BrokerProxyDataResponse(properties);
    };

    /**
     * Encodes the specified BrokerProxyDataResponse message. Does not implicitly {@link BrokerProxyDataResponse.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {IBrokerProxyDataResponse} message BrokerProxyDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyDataResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyDataResponse message, length delimited. Does not implicitly {@link BrokerProxyDataResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {IBrokerProxyDataResponse} message BrokerProxyDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyDataResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyDataResponse} BrokerProxyDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyDataResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyDataResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyDataResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyDataResponse} BrokerProxyDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyDataResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyDataResponse message.
     * @function verify
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyDataResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BrokerProxyDataResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyDataResponse} BrokerProxyDataResponse
     */
    BrokerProxyDataResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyDataResponse)
            return object;
        return new $root.BrokerProxyDataResponse();
    };

    /**
     * Creates a plain object from a BrokerProxyDataResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyDataResponse
     * @static
     * @param {BrokerProxyDataResponse} message BrokerProxyDataResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyDataResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BrokerProxyDataResponse to JSON.
     * @function toJSON
     * @memberof BrokerProxyDataResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyDataResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyDataResponse;
})();

export const BrokerProxyCloseRequest = $root.BrokerProxyCloseRequest = (() => {

    /**
     * Properties of a BrokerProxyCloseRequest.
     * @exports IBrokerProxyCloseRequest
     * @interface IBrokerProxyCloseRequest
     * @property {number|null} [proxyId] BrokerProxyCloseRequest proxyId
     */

    /**
     * Constructs a new BrokerProxyCloseRequest.
     * @exports BrokerProxyCloseRequest
     * @classdesc Represents a BrokerProxyCloseRequest.
     * @implements IBrokerProxyCloseRequest
     * @constructor
     * @param {IBrokerProxyCloseRequest=} [properties] Properties to set
     */
    function BrokerProxyCloseRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrokerProxyCloseRequest proxyId.
     * @member {number} proxyId
     * @memberof BrokerProxyCloseRequest
     * @instance
     */
    BrokerProxyCloseRequest.prototype.proxyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new BrokerProxyCloseRequest instance using the specified properties.
     * @function create
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {IBrokerProxyCloseRequest=} [properties] Properties to set
     * @returns {BrokerProxyCloseRequest} BrokerProxyCloseRequest instance
     */
    BrokerProxyCloseRequest.create = function create(properties) {
        return new BrokerProxyCloseRequest(properties);
    };

    /**
     * Encodes the specified BrokerProxyCloseRequest message. Does not implicitly {@link BrokerProxyCloseRequest.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {IBrokerProxyCloseRequest} message BrokerProxyCloseRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyCloseRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.proxyId != null && Object.hasOwnProperty.call(message, "proxyId"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.proxyId);
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyCloseRequest message, length delimited. Does not implicitly {@link BrokerProxyCloseRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {IBrokerProxyCloseRequest} message BrokerProxyCloseRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyCloseRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyCloseRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyCloseRequest} BrokerProxyCloseRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyCloseRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyCloseRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.proxyId = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyCloseRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyCloseRequest} BrokerProxyCloseRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyCloseRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyCloseRequest message.
     * @function verify
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyCloseRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (!$util.isInteger(message.proxyId) && !(message.proxyId && $util.isInteger(message.proxyId.low) && $util.isInteger(message.proxyId.high)))
                return "proxyId: integer|Long expected";
        return null;
    };

    /**
     * Creates a BrokerProxyCloseRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyCloseRequest} BrokerProxyCloseRequest
     */
    BrokerProxyCloseRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyCloseRequest)
            return object;
        let message = new $root.BrokerProxyCloseRequest();
        if (object.proxyId != null)
            if ($util.Long)
                (message.proxyId = $util.Long.fromValue(object.proxyId)).unsigned = true;
            else if (typeof object.proxyId === "string")
                message.proxyId = parseInt(object.proxyId, 10);
            else if (typeof object.proxyId === "number")
                message.proxyId = object.proxyId;
            else if (typeof object.proxyId === "object")
                message.proxyId = new $util.LongBits(object.proxyId.low >>> 0, object.proxyId.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a BrokerProxyCloseRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyCloseRequest
     * @static
     * @param {BrokerProxyCloseRequest} message BrokerProxyCloseRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyCloseRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.proxyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.proxyId = options.longs === String ? "0" : 0;
        if (message.proxyId != null && message.hasOwnProperty("proxyId"))
            if (typeof message.proxyId === "number")
                object.proxyId = options.longs === String ? String(message.proxyId) : message.proxyId;
            else
                object.proxyId = options.longs === String ? $util.Long.prototype.toString.call(message.proxyId) : options.longs === Number ? new $util.LongBits(message.proxyId.low >>> 0, message.proxyId.high >>> 0).toNumber(true) : message.proxyId;
        return object;
    };

    /**
     * Converts this BrokerProxyCloseRequest to JSON.
     * @function toJSON
     * @memberof BrokerProxyCloseRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyCloseRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyCloseRequest;
})();

export const BrokerProxyCloseResponse = $root.BrokerProxyCloseResponse = (() => {

    /**
     * Properties of a BrokerProxyCloseResponse.
     * @exports IBrokerProxyCloseResponse
     * @interface IBrokerProxyCloseResponse
     */

    /**
     * Constructs a new BrokerProxyCloseResponse.
     * @exports BrokerProxyCloseResponse
     * @classdesc Represents a BrokerProxyCloseResponse.
     * @implements IBrokerProxyCloseResponse
     * @constructor
     * @param {IBrokerProxyCloseResponse=} [properties] Properties to set
     */
    function BrokerProxyCloseResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BrokerProxyCloseResponse instance using the specified properties.
     * @function create
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {IBrokerProxyCloseResponse=} [properties] Properties to set
     * @returns {BrokerProxyCloseResponse} BrokerProxyCloseResponse instance
     */
    BrokerProxyCloseResponse.create = function create(properties) {
        return new BrokerProxyCloseResponse(properties);
    };

    /**
     * Encodes the specified BrokerProxyCloseResponse message. Does not implicitly {@link BrokerProxyCloseResponse.verify|verify} messages.
     * @function encode
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {IBrokerProxyCloseResponse} message BrokerProxyCloseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyCloseResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BrokerProxyCloseResponse message, length delimited. Does not implicitly {@link BrokerProxyCloseResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {IBrokerProxyCloseResponse} message BrokerProxyCloseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrokerProxyCloseResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrokerProxyCloseResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrokerProxyCloseResponse} BrokerProxyCloseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyCloseResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrokerProxyCloseResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrokerProxyCloseResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrokerProxyCloseResponse} BrokerProxyCloseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrokerProxyCloseResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrokerProxyCloseResponse message.
     * @function verify
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrokerProxyCloseResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BrokerProxyCloseResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrokerProxyCloseResponse} BrokerProxyCloseResponse
     */
    BrokerProxyCloseResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BrokerProxyCloseResponse)
            return object;
        return new $root.BrokerProxyCloseResponse();
    };

    /**
     * Creates a plain object from a BrokerProxyCloseResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrokerProxyCloseResponse
     * @static
     * @param {BrokerProxyCloseResponse} message BrokerProxyCloseResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrokerProxyCloseResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BrokerProxyCloseResponse to JSON.
     * @function toJSON
     * @memberof BrokerProxyCloseResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrokerProxyCloseResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrokerProxyCloseResponse;
})();

export const BootstrapClient = $root.BootstrapClient = (() => {

    /**
     * Properties of a BootstrapClient.
     * @exports IBootstrapClient
     * @interface IBootstrapClient
     * @property {number|null} [id] BootstrapClient id
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] BootstrapClient websocketOptions
     */

    /**
     * Constructs a new BootstrapClient.
     * @exports BootstrapClient
     * @classdesc Represents a BootstrapClient.
     * @implements IBootstrapClient
     * @constructor
     * @param {IBootstrapClient=} [properties] Properties to set
     */
    function BootstrapClient(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapClient id.
     * @member {number} id
     * @memberof BootstrapClient
     * @instance
     */
    BootstrapClient.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * BootstrapClient websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof BootstrapClient
     * @instance
     */
    BootstrapClient.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BootstrapClient clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof BootstrapClient
     * @instance
     */
    Object.defineProperty(BootstrapClient.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BootstrapClient instance using the specified properties.
     * @function create
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient=} [properties] Properties to set
     * @returns {BootstrapClient} BootstrapClient instance
     */
    BootstrapClient.create = function create(properties) {
        return new BootstrapClient(properties);
    };

    /**
     * Encodes the specified BootstrapClient message. Does not implicitly {@link BootstrapClient.verify|verify} messages.
     * @function encode
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient} message BootstrapClient message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClient.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BootstrapClient message, length delimited. Does not implicitly {@link BootstrapClient.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapClient
     * @static
     * @param {IBootstrapClient} message BootstrapClient message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClient.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapClient message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapClient} BootstrapClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClient.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapClient();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapClient message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapClient} BootstrapClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClient.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapClient message.
     * @function verify
     * @memberof BootstrapClient
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapClient.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BootstrapClient message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapClient
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapClient} BootstrapClient
     */
    BootstrapClient.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapClient)
            return object;
        let message = new $root.BootstrapClient();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".BootstrapClient.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapClient message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapClient
     * @static
     * @param {BootstrapClient} message BootstrapClient
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapClient.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this BootstrapClient to JSON.
     * @function toJSON
     * @memberof BootstrapClient
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapClient.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapClient;
})();

export const BootstrapClientWebSocketOptions = $root.BootstrapClientWebSocketOptions = (() => {

    /**
     * Properties of a BootstrapClientWebSocketOptions.
     * @exports IBootstrapClientWebSocketOptions
     * @interface IBootstrapClientWebSocketOptions
     * @property {string|null} [url] BootstrapClientWebSocketOptions url
     * @property {boolean|null} [insecureSkipVerifyTls] BootstrapClientWebSocketOptions insecureSkipVerifyTls
     */

    /**
     * Constructs a new BootstrapClientWebSocketOptions.
     * @exports BootstrapClientWebSocketOptions
     * @classdesc Represents a BootstrapClientWebSocketOptions.
     * @implements IBootstrapClientWebSocketOptions
     * @constructor
     * @param {IBootstrapClientWebSocketOptions=} [properties] Properties to set
     */
    function BootstrapClientWebSocketOptions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapClientWebSocketOptions url.
     * @member {string} url
     * @memberof BootstrapClientWebSocketOptions
     * @instance
     */
    BootstrapClientWebSocketOptions.prototype.url = "";

    /**
     * BootstrapClientWebSocketOptions insecureSkipVerifyTls.
     * @member {boolean} insecureSkipVerifyTls
     * @memberof BootstrapClientWebSocketOptions
     * @instance
     */
    BootstrapClientWebSocketOptions.prototype.insecureSkipVerifyTls = false;

    /**
     * Creates a new BootstrapClientWebSocketOptions instance using the specified properties.
     * @function create
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions=} [properties] Properties to set
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions instance
     */
    BootstrapClientWebSocketOptions.create = function create(properties) {
        return new BootstrapClientWebSocketOptions(properties);
    };

    /**
     * Encodes the specified BootstrapClientWebSocketOptions message. Does not implicitly {@link BootstrapClientWebSocketOptions.verify|verify} messages.
     * @function encode
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClientWebSocketOptions.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.insecureSkipVerifyTls != null && Object.hasOwnProperty.call(message, "insecureSkipVerifyTls"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.insecureSkipVerifyTls);
        return writer;
    };

    /**
     * Encodes the specified BootstrapClientWebSocketOptions message, length delimited. Does not implicitly {@link BootstrapClientWebSocketOptions.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {IBootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapClientWebSocketOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapClientWebSocketOptions message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClientWebSocketOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapClientWebSocketOptions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.insecureSkipVerifyTls = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapClientWebSocketOptions message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapClientWebSocketOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapClientWebSocketOptions message.
     * @function verify
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapClientWebSocketOptions.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.insecureSkipVerifyTls != null && message.hasOwnProperty("insecureSkipVerifyTls"))
            if (typeof message.insecureSkipVerifyTls !== "boolean")
                return "insecureSkipVerifyTls: boolean expected";
        return null;
    };

    /**
     * Creates a BootstrapClientWebSocketOptions message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapClientWebSocketOptions} BootstrapClientWebSocketOptions
     */
    BootstrapClientWebSocketOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapClientWebSocketOptions)
            return object;
        let message = new $root.BootstrapClientWebSocketOptions();
        if (object.url != null)
            message.url = String(object.url);
        if (object.insecureSkipVerifyTls != null)
            message.insecureSkipVerifyTls = Boolean(object.insecureSkipVerifyTls);
        return message;
    };

    /**
     * Creates a plain object from a BootstrapClientWebSocketOptions message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapClientWebSocketOptions
     * @static
     * @param {BootstrapClientWebSocketOptions} message BootstrapClientWebSocketOptions
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapClientWebSocketOptions.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.url = "";
            object.insecureSkipVerifyTls = false;
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.insecureSkipVerifyTls != null && message.hasOwnProperty("insecureSkipVerifyTls"))
            object.insecureSkipVerifyTls = message.insecureSkipVerifyTls;
        return object;
    };

    /**
     * Converts this BootstrapClientWebSocketOptions to JSON.
     * @function toJSON
     * @memberof BootstrapClientWebSocketOptions
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapClientWebSocketOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapClientWebSocketOptions;
})();

export const CreateBootstrapClientRequest = $root.CreateBootstrapClientRequest = (() => {

    /**
     * Properties of a CreateBootstrapClientRequest.
     * @exports ICreateBootstrapClientRequest
     * @interface ICreateBootstrapClientRequest
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] CreateBootstrapClientRequest websocketOptions
     */

    /**
     * Constructs a new CreateBootstrapClientRequest.
     * @exports CreateBootstrapClientRequest
     * @classdesc Represents a CreateBootstrapClientRequest.
     * @implements ICreateBootstrapClientRequest
     * @constructor
     * @param {ICreateBootstrapClientRequest=} [properties] Properties to set
     */
    function CreateBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateBootstrapClientRequest websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof CreateBootstrapClientRequest
     * @instance
     */
    CreateBootstrapClientRequest.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * CreateBootstrapClientRequest clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof CreateBootstrapClientRequest
     * @instance
     */
    Object.defineProperty(CreateBootstrapClientRequest.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new CreateBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest=} [properties] Properties to set
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest instance
     */
    CreateBootstrapClientRequest.create = function create(properties) {
        return new CreateBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified CreateBootstrapClientRequest message. Does not implicitly {@link CreateBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest} message CreateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateBootstrapClientRequest message, length delimited. Does not implicitly {@link CreateBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {ICreateBootstrapClientRequest} message CreateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateBootstrapClientRequest message.
     * @function verify
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CreateBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateBootstrapClientRequest} CreateBootstrapClientRequest
     */
    CreateBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateBootstrapClientRequest)
            return object;
        let message = new $root.CreateBootstrapClientRequest();
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".CreateBootstrapClientRequest.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateBootstrapClientRequest
     * @static
     * @param {CreateBootstrapClientRequest} message CreateBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this CreateBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof CreateBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateBootstrapClientRequest;
})();

export const CreateBootstrapClientResponse = $root.CreateBootstrapClientResponse = (() => {

    /**
     * Properties of a CreateBootstrapClientResponse.
     * @exports ICreateBootstrapClientResponse
     * @interface ICreateBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] CreateBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new CreateBootstrapClientResponse.
     * @exports CreateBootstrapClientResponse
     * @classdesc Represents a CreateBootstrapClientResponse.
     * @implements ICreateBootstrapClientResponse
     * @constructor
     * @param {ICreateBootstrapClientResponse=} [properties] Properties to set
     */
    function CreateBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof CreateBootstrapClientResponse
     * @instance
     */
    CreateBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new CreateBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse=} [properties] Properties to set
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse instance
     */
    CreateBootstrapClientResponse.create = function create(properties) {
        return new CreateBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified CreateBootstrapClientResponse message. Does not implicitly {@link CreateBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse} message CreateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateBootstrapClientResponse message, length delimited. Does not implicitly {@link CreateBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {ICreateBootstrapClientResponse} message CreateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateBootstrapClientResponse message.
     * @function verify
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates a CreateBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateBootstrapClientResponse} CreateBootstrapClientResponse
     */
    CreateBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateBootstrapClientResponse)
            return object;
        let message = new $root.CreateBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".CreateBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateBootstrapClientResponse
     * @static
     * @param {CreateBootstrapClientResponse} message CreateBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this CreateBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof CreateBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateBootstrapClientResponse;
})();

export const UpdateBootstrapClientRequest = $root.UpdateBootstrapClientRequest = (() => {

    /**
     * Properties of an UpdateBootstrapClientRequest.
     * @exports IUpdateBootstrapClientRequest
     * @interface IUpdateBootstrapClientRequest
     * @property {number|null} [id] UpdateBootstrapClientRequest id
     * @property {IBootstrapClientWebSocketOptions|null} [websocketOptions] UpdateBootstrapClientRequest websocketOptions
     */

    /**
     * Constructs a new UpdateBootstrapClientRequest.
     * @exports UpdateBootstrapClientRequest
     * @classdesc Represents an UpdateBootstrapClientRequest.
     * @implements IUpdateBootstrapClientRequest
     * @constructor
     * @param {IUpdateBootstrapClientRequest=} [properties] Properties to set
     */
    function UpdateBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateBootstrapClientRequest id.
     * @member {number} id
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    UpdateBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UpdateBootstrapClientRequest websocketOptions.
     * @member {IBootstrapClientWebSocketOptions|null|undefined} websocketOptions
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    UpdateBootstrapClientRequest.prototype.websocketOptions = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * UpdateBootstrapClientRequest clientOptions.
     * @member {"websocketOptions"|undefined} clientOptions
     * @memberof UpdateBootstrapClientRequest
     * @instance
     */
    Object.defineProperty(UpdateBootstrapClientRequest.prototype, "clientOptions", {
        get: $util.oneOfGetter($oneOfFields = ["websocketOptions"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new UpdateBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest=} [properties] Properties to set
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest instance
     */
    UpdateBootstrapClientRequest.create = function create(properties) {
        return new UpdateBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified UpdateBootstrapClientRequest message. Does not implicitly {@link UpdateBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest} message UpdateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        if (message.websocketOptions != null && Object.hasOwnProperty.call(message, "websocketOptions"))
            $root.BootstrapClientWebSocketOptions.encode(message.websocketOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateBootstrapClientRequest message, length delimited. Does not implicitly {@link UpdateBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {IUpdateBootstrapClientRequest} message UpdateBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            case 2:
                message.websocketOptions = $root.BootstrapClientWebSocketOptions.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateBootstrapClientRequest message.
     * @function verify
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            properties.clientOptions = 1;
            {
                let error = $root.BootstrapClientWebSocketOptions.verify(message.websocketOptions);
                if (error)
                    return "websocketOptions." + error;
            }
        }
        return null;
    };

    /**
     * Creates an UpdateBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateBootstrapClientRequest} UpdateBootstrapClientRequest
     */
    UpdateBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateBootstrapClientRequest)
            return object;
        let message = new $root.UpdateBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.websocketOptions != null) {
            if (typeof object.websocketOptions !== "object")
                throw TypeError(".UpdateBootstrapClientRequest.websocketOptions: object expected");
            message.websocketOptions = $root.BootstrapClientWebSocketOptions.fromObject(object.websocketOptions);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateBootstrapClientRequest
     * @static
     * @param {UpdateBootstrapClientRequest} message UpdateBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        if (message.websocketOptions != null && message.hasOwnProperty("websocketOptions")) {
            object.websocketOptions = $root.BootstrapClientWebSocketOptions.toObject(message.websocketOptions, options);
            if (options.oneofs)
                object.clientOptions = "websocketOptions";
        }
        return object;
    };

    /**
     * Converts this UpdateBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof UpdateBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateBootstrapClientRequest;
})();

export const UpdateBootstrapClientResponse = $root.UpdateBootstrapClientResponse = (() => {

    /**
     * Properties of an UpdateBootstrapClientResponse.
     * @exports IUpdateBootstrapClientResponse
     * @interface IUpdateBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] UpdateBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new UpdateBootstrapClientResponse.
     * @exports UpdateBootstrapClientResponse
     * @classdesc Represents an UpdateBootstrapClientResponse.
     * @implements IUpdateBootstrapClientResponse
     * @constructor
     * @param {IUpdateBootstrapClientResponse=} [properties] Properties to set
     */
    function UpdateBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof UpdateBootstrapClientResponse
     * @instance
     */
    UpdateBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new UpdateBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse=} [properties] Properties to set
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse instance
     */
    UpdateBootstrapClientResponse.create = function create(properties) {
        return new UpdateBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified UpdateBootstrapClientResponse message. Does not implicitly {@link UpdateBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse} message UpdateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateBootstrapClientResponse message, length delimited. Does not implicitly {@link UpdateBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {IUpdateBootstrapClientResponse} message UpdateBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateBootstrapClientResponse message.
     * @function verify
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateBootstrapClientResponse} UpdateBootstrapClientResponse
     */
    UpdateBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateBootstrapClientResponse)
            return object;
        let message = new $root.UpdateBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".UpdateBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateBootstrapClientResponse
     * @static
     * @param {UpdateBootstrapClientResponse} message UpdateBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this UpdateBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof UpdateBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateBootstrapClientResponse;
})();

export const DeleteBootstrapClientRequest = $root.DeleteBootstrapClientRequest = (() => {

    /**
     * Properties of a DeleteBootstrapClientRequest.
     * @exports IDeleteBootstrapClientRequest
     * @interface IDeleteBootstrapClientRequest
     * @property {number|null} [id] DeleteBootstrapClientRequest id
     */

    /**
     * Constructs a new DeleteBootstrapClientRequest.
     * @exports DeleteBootstrapClientRequest
     * @classdesc Represents a DeleteBootstrapClientRequest.
     * @implements IDeleteBootstrapClientRequest
     * @constructor
     * @param {IDeleteBootstrapClientRequest=} [properties] Properties to set
     */
    function DeleteBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteBootstrapClientRequest id.
     * @member {number} id
     * @memberof DeleteBootstrapClientRequest
     * @instance
     */
    DeleteBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest=} [properties] Properties to set
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest instance
     */
    DeleteBootstrapClientRequest.create = function create(properties) {
        return new DeleteBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified DeleteBootstrapClientRequest message. Does not implicitly {@link DeleteBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest} message DeleteBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified DeleteBootstrapClientRequest message, length delimited. Does not implicitly {@link DeleteBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {IDeleteBootstrapClientRequest} message DeleteBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteBootstrapClientRequest message.
     * @function verify
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteBootstrapClientRequest} DeleteBootstrapClientRequest
     */
    DeleteBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteBootstrapClientRequest)
            return object;
        let message = new $root.DeleteBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteBootstrapClientRequest
     * @static
     * @param {DeleteBootstrapClientRequest} message DeleteBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this DeleteBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof DeleteBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteBootstrapClientRequest;
})();

export const DeleteBootstrapClientResponse = $root.DeleteBootstrapClientResponse = (() => {

    /**
     * Properties of a DeleteBootstrapClientResponse.
     * @exports IDeleteBootstrapClientResponse
     * @interface IDeleteBootstrapClientResponse
     */

    /**
     * Constructs a new DeleteBootstrapClientResponse.
     * @exports DeleteBootstrapClientResponse
     * @classdesc Represents a DeleteBootstrapClientResponse.
     * @implements IDeleteBootstrapClientResponse
     * @constructor
     * @param {IDeleteBootstrapClientResponse=} [properties] Properties to set
     */
    function DeleteBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DeleteBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse=} [properties] Properties to set
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse instance
     */
    DeleteBootstrapClientResponse.create = function create(properties) {
        return new DeleteBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified DeleteBootstrapClientResponse message. Does not implicitly {@link DeleteBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse} message DeleteBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DeleteBootstrapClientResponse message, length delimited. Does not implicitly {@link DeleteBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {IDeleteBootstrapClientResponse} message DeleteBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteBootstrapClientResponse message.
     * @function verify
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DeleteBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteBootstrapClientResponse} DeleteBootstrapClientResponse
     */
    DeleteBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteBootstrapClientResponse)
            return object;
        return new $root.DeleteBootstrapClientResponse();
    };

    /**
     * Creates a plain object from a DeleteBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteBootstrapClientResponse
     * @static
     * @param {DeleteBootstrapClientResponse} message DeleteBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteBootstrapClientResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DeleteBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof DeleteBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteBootstrapClientResponse;
})();

export const GetBootstrapClientRequest = $root.GetBootstrapClientRequest = (() => {

    /**
     * Properties of a GetBootstrapClientRequest.
     * @exports IGetBootstrapClientRequest
     * @interface IGetBootstrapClientRequest
     * @property {number|null} [id] GetBootstrapClientRequest id
     */

    /**
     * Constructs a new GetBootstrapClientRequest.
     * @exports GetBootstrapClientRequest
     * @classdesc Represents a GetBootstrapClientRequest.
     * @implements IGetBootstrapClientRequest
     * @constructor
     * @param {IGetBootstrapClientRequest=} [properties] Properties to set
     */
    function GetBootstrapClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapClientRequest id.
     * @member {number} id
     * @memberof GetBootstrapClientRequest
     * @instance
     */
    GetBootstrapClientRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new GetBootstrapClientRequest instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest=} [properties] Properties to set
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest instance
     */
    GetBootstrapClientRequest.create = function create(properties) {
        return new GetBootstrapClientRequest(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientRequest message. Does not implicitly {@link GetBootstrapClientRequest.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest} message GetBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientRequest message, length delimited. Does not implicitly {@link GetBootstrapClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {IGetBootstrapClientRequest} message GetBootstrapClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientRequest message.
     * @function verify
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetBootstrapClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientRequest} GetBootstrapClientRequest
     */
    GetBootstrapClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientRequest)
            return object;
        let message = new $root.GetBootstrapClientRequest();
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientRequest
     * @static
     * @param {GetBootstrapClientRequest} message GetBootstrapClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
        return object;
    };

    /**
     * Converts this GetBootstrapClientRequest to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientRequest;
})();

export const GetBootstrapClientResponse = $root.GetBootstrapClientResponse = (() => {

    /**
     * Properties of a GetBootstrapClientResponse.
     * @exports IGetBootstrapClientResponse
     * @interface IGetBootstrapClientResponse
     * @property {IBootstrapClient|null} [bootstrapClient] GetBootstrapClientResponse bootstrapClient
     */

    /**
     * Constructs a new GetBootstrapClientResponse.
     * @exports GetBootstrapClientResponse
     * @classdesc Represents a GetBootstrapClientResponse.
     * @implements IGetBootstrapClientResponse
     * @constructor
     * @param {IGetBootstrapClientResponse=} [properties] Properties to set
     */
    function GetBootstrapClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetBootstrapClientResponse bootstrapClient.
     * @member {IBootstrapClient|null|undefined} bootstrapClient
     * @memberof GetBootstrapClientResponse
     * @instance
     */
    GetBootstrapClientResponse.prototype.bootstrapClient = null;

    /**
     * Creates a new GetBootstrapClientResponse instance using the specified properties.
     * @function create
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse=} [properties] Properties to set
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse instance
     */
    GetBootstrapClientResponse.create = function create(properties) {
        return new GetBootstrapClientResponse(properties);
    };

    /**
     * Encodes the specified GetBootstrapClientResponse message. Does not implicitly {@link GetBootstrapClientResponse.verify|verify} messages.
     * @function encode
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse} message GetBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClient != null && Object.hasOwnProperty.call(message, "bootstrapClient"))
            $root.BootstrapClient.encode(message.bootstrapClient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetBootstrapClientResponse message, length delimited. Does not implicitly {@link GetBootstrapClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {IGetBootstrapClientResponse} message GetBootstrapClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetBootstrapClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetBootstrapClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetBootstrapClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bootstrapClient = $root.BootstrapClient.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetBootstrapClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetBootstrapClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetBootstrapClientResponse message.
     * @function verify
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetBootstrapClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient")) {
            let error = $root.BootstrapClient.verify(message.bootstrapClient);
            if (error)
                return "bootstrapClient." + error;
        }
        return null;
    };

    /**
     * Creates a GetBootstrapClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetBootstrapClientResponse} GetBootstrapClientResponse
     */
    GetBootstrapClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetBootstrapClientResponse)
            return object;
        let message = new $root.GetBootstrapClientResponse();
        if (object.bootstrapClient != null) {
            if (typeof object.bootstrapClient !== "object")
                throw TypeError(".GetBootstrapClientResponse.bootstrapClient: object expected");
            message.bootstrapClient = $root.BootstrapClient.fromObject(object.bootstrapClient);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetBootstrapClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetBootstrapClientResponse
     * @static
     * @param {GetBootstrapClientResponse} message GetBootstrapClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetBootstrapClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.bootstrapClient = null;
        if (message.bootstrapClient != null && message.hasOwnProperty("bootstrapClient"))
            object.bootstrapClient = $root.BootstrapClient.toObject(message.bootstrapClient, options);
        return object;
    };

    /**
     * Converts this GetBootstrapClientResponse to JSON.
     * @function toJSON
     * @memberof GetBootstrapClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetBootstrapClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetBootstrapClientResponse;
})();

export const ListBootstrapClientsRequest = $root.ListBootstrapClientsRequest = (() => {

    /**
     * Properties of a ListBootstrapClientsRequest.
     * @exports IListBootstrapClientsRequest
     * @interface IListBootstrapClientsRequest
     */

    /**
     * Constructs a new ListBootstrapClientsRequest.
     * @exports ListBootstrapClientsRequest
     * @classdesc Represents a ListBootstrapClientsRequest.
     * @implements IListBootstrapClientsRequest
     * @constructor
     * @param {IListBootstrapClientsRequest=} [properties] Properties to set
     */
    function ListBootstrapClientsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ListBootstrapClientsRequest instance using the specified properties.
     * @function create
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {IListBootstrapClientsRequest=} [properties] Properties to set
     * @returns {ListBootstrapClientsRequest} ListBootstrapClientsRequest instance
     */
    ListBootstrapClientsRequest.create = function create(properties) {
        return new ListBootstrapClientsRequest(properties);
    };

    /**
     * Encodes the specified ListBootstrapClientsRequest message. Does not implicitly {@link ListBootstrapClientsRequest.verify|verify} messages.
     * @function encode
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {IListBootstrapClientsRequest} message ListBootstrapClientsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapClientsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ListBootstrapClientsRequest message, length delimited. Does not implicitly {@link ListBootstrapClientsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {IListBootstrapClientsRequest} message ListBootstrapClientsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapClientsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListBootstrapClientsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListBootstrapClientsRequest} ListBootstrapClientsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapClientsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBootstrapClientsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListBootstrapClientsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListBootstrapClientsRequest} ListBootstrapClientsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapClientsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListBootstrapClientsRequest message.
     * @function verify
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListBootstrapClientsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ListBootstrapClientsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListBootstrapClientsRequest} ListBootstrapClientsRequest
     */
    ListBootstrapClientsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ListBootstrapClientsRequest)
            return object;
        return new $root.ListBootstrapClientsRequest();
    };

    /**
     * Creates a plain object from a ListBootstrapClientsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListBootstrapClientsRequest
     * @static
     * @param {ListBootstrapClientsRequest} message ListBootstrapClientsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListBootstrapClientsRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ListBootstrapClientsRequest to JSON.
     * @function toJSON
     * @memberof ListBootstrapClientsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListBootstrapClientsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListBootstrapClientsRequest;
})();

export const ListBootstrapClientsResponse = $root.ListBootstrapClientsResponse = (() => {

    /**
     * Properties of a ListBootstrapClientsResponse.
     * @exports IListBootstrapClientsResponse
     * @interface IListBootstrapClientsResponse
     * @property {Array.<IBootstrapClient>|null} [bootstrapClients] ListBootstrapClientsResponse bootstrapClients
     */

    /**
     * Constructs a new ListBootstrapClientsResponse.
     * @exports ListBootstrapClientsResponse
     * @classdesc Represents a ListBootstrapClientsResponse.
     * @implements IListBootstrapClientsResponse
     * @constructor
     * @param {IListBootstrapClientsResponse=} [properties] Properties to set
     */
    function ListBootstrapClientsResponse(properties) {
        this.bootstrapClients = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListBootstrapClientsResponse bootstrapClients.
     * @member {Array.<IBootstrapClient>} bootstrapClients
     * @memberof ListBootstrapClientsResponse
     * @instance
     */
    ListBootstrapClientsResponse.prototype.bootstrapClients = $util.emptyArray;

    /**
     * Creates a new ListBootstrapClientsResponse instance using the specified properties.
     * @function create
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {IListBootstrapClientsResponse=} [properties] Properties to set
     * @returns {ListBootstrapClientsResponse} ListBootstrapClientsResponse instance
     */
    ListBootstrapClientsResponse.create = function create(properties) {
        return new ListBootstrapClientsResponse(properties);
    };

    /**
     * Encodes the specified ListBootstrapClientsResponse message. Does not implicitly {@link ListBootstrapClientsResponse.verify|verify} messages.
     * @function encode
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {IListBootstrapClientsResponse} message ListBootstrapClientsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapClientsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bootstrapClients != null && message.bootstrapClients.length)
            for (let i = 0; i < message.bootstrapClients.length; ++i)
                $root.BootstrapClient.encode(message.bootstrapClients[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListBootstrapClientsResponse message, length delimited. Does not implicitly {@link ListBootstrapClientsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {IListBootstrapClientsResponse} message ListBootstrapClientsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapClientsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListBootstrapClientsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListBootstrapClientsResponse} ListBootstrapClientsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapClientsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBootstrapClientsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.bootstrapClients && message.bootstrapClients.length))
                    message.bootstrapClients = [];
                message.bootstrapClients.push($root.BootstrapClient.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListBootstrapClientsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListBootstrapClientsResponse} ListBootstrapClientsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapClientsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListBootstrapClientsResponse message.
     * @function verify
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListBootstrapClientsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bootstrapClients != null && message.hasOwnProperty("bootstrapClients")) {
            if (!Array.isArray(message.bootstrapClients))
                return "bootstrapClients: array expected";
            for (let i = 0; i < message.bootstrapClients.length; ++i) {
                let error = $root.BootstrapClient.verify(message.bootstrapClients[i]);
                if (error)
                    return "bootstrapClients." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListBootstrapClientsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListBootstrapClientsResponse} ListBootstrapClientsResponse
     */
    ListBootstrapClientsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListBootstrapClientsResponse)
            return object;
        let message = new $root.ListBootstrapClientsResponse();
        if (object.bootstrapClients) {
            if (!Array.isArray(object.bootstrapClients))
                throw TypeError(".ListBootstrapClientsResponse.bootstrapClients: array expected");
            message.bootstrapClients = [];
            for (let i = 0; i < object.bootstrapClients.length; ++i) {
                if (typeof object.bootstrapClients[i] !== "object")
                    throw TypeError(".ListBootstrapClientsResponse.bootstrapClients: object expected");
                message.bootstrapClients[i] = $root.BootstrapClient.fromObject(object.bootstrapClients[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListBootstrapClientsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListBootstrapClientsResponse
     * @static
     * @param {ListBootstrapClientsResponse} message ListBootstrapClientsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListBootstrapClientsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.bootstrapClients = [];
        if (message.bootstrapClients && message.bootstrapClients.length) {
            object.bootstrapClients = [];
            for (let j = 0; j < message.bootstrapClients.length; ++j)
                object.bootstrapClients[j] = $root.BootstrapClient.toObject(message.bootstrapClients[j], options);
        }
        return object;
    };

    /**
     * Converts this ListBootstrapClientsResponse to JSON.
     * @function toJSON
     * @memberof ListBootstrapClientsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListBootstrapClientsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListBootstrapClientsResponse;
})();

export const ListBootstrapPeersRequest = $root.ListBootstrapPeersRequest = (() => {

    /**
     * Properties of a ListBootstrapPeersRequest.
     * @exports IListBootstrapPeersRequest
     * @interface IListBootstrapPeersRequest
     */

    /**
     * Constructs a new ListBootstrapPeersRequest.
     * @exports ListBootstrapPeersRequest
     * @classdesc Represents a ListBootstrapPeersRequest.
     * @implements IListBootstrapPeersRequest
     * @constructor
     * @param {IListBootstrapPeersRequest=} [properties] Properties to set
     */
    function ListBootstrapPeersRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ListBootstrapPeersRequest instance using the specified properties.
     * @function create
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {IListBootstrapPeersRequest=} [properties] Properties to set
     * @returns {ListBootstrapPeersRequest} ListBootstrapPeersRequest instance
     */
    ListBootstrapPeersRequest.create = function create(properties) {
        return new ListBootstrapPeersRequest(properties);
    };

    /**
     * Encodes the specified ListBootstrapPeersRequest message. Does not implicitly {@link ListBootstrapPeersRequest.verify|verify} messages.
     * @function encode
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {IListBootstrapPeersRequest} message ListBootstrapPeersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapPeersRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ListBootstrapPeersRequest message, length delimited. Does not implicitly {@link ListBootstrapPeersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {IListBootstrapPeersRequest} message ListBootstrapPeersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListBootstrapPeersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListBootstrapPeersRequest} ListBootstrapPeersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapPeersRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBootstrapPeersRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListBootstrapPeersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListBootstrapPeersRequest} ListBootstrapPeersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapPeersRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListBootstrapPeersRequest message.
     * @function verify
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListBootstrapPeersRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ListBootstrapPeersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListBootstrapPeersRequest} ListBootstrapPeersRequest
     */
    ListBootstrapPeersRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ListBootstrapPeersRequest)
            return object;
        return new $root.ListBootstrapPeersRequest();
    };

    /**
     * Creates a plain object from a ListBootstrapPeersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListBootstrapPeersRequest
     * @static
     * @param {ListBootstrapPeersRequest} message ListBootstrapPeersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListBootstrapPeersRequest.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ListBootstrapPeersRequest to JSON.
     * @function toJSON
     * @memberof ListBootstrapPeersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListBootstrapPeersRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListBootstrapPeersRequest;
})();

export const ListBootstrapPeersResponse = $root.ListBootstrapPeersResponse = (() => {

    /**
     * Properties of a ListBootstrapPeersResponse.
     * @exports IListBootstrapPeersResponse
     * @interface IListBootstrapPeersResponse
     * @property {Array.<IBootstrapPeer>|null} [peers] ListBootstrapPeersResponse peers
     */

    /**
     * Constructs a new ListBootstrapPeersResponse.
     * @exports ListBootstrapPeersResponse
     * @classdesc Represents a ListBootstrapPeersResponse.
     * @implements IListBootstrapPeersResponse
     * @constructor
     * @param {IListBootstrapPeersResponse=} [properties] Properties to set
     */
    function ListBootstrapPeersResponse(properties) {
        this.peers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListBootstrapPeersResponse peers.
     * @member {Array.<IBootstrapPeer>} peers
     * @memberof ListBootstrapPeersResponse
     * @instance
     */
    ListBootstrapPeersResponse.prototype.peers = $util.emptyArray;

    /**
     * Creates a new ListBootstrapPeersResponse instance using the specified properties.
     * @function create
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {IListBootstrapPeersResponse=} [properties] Properties to set
     * @returns {ListBootstrapPeersResponse} ListBootstrapPeersResponse instance
     */
    ListBootstrapPeersResponse.create = function create(properties) {
        return new ListBootstrapPeersResponse(properties);
    };

    /**
     * Encodes the specified ListBootstrapPeersResponse message. Does not implicitly {@link ListBootstrapPeersResponse.verify|verify} messages.
     * @function encode
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {IListBootstrapPeersResponse} message ListBootstrapPeersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapPeersResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.peers != null && message.peers.length)
            for (let i = 0; i < message.peers.length; ++i)
                $root.BootstrapPeer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListBootstrapPeersResponse message, length delimited. Does not implicitly {@link ListBootstrapPeersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {IListBootstrapPeersResponse} message ListBootstrapPeersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListBootstrapPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListBootstrapPeersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListBootstrapPeersResponse} ListBootstrapPeersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapPeersResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBootstrapPeersResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.peers && message.peers.length))
                    message.peers = [];
                message.peers.push($root.BootstrapPeer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListBootstrapPeersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListBootstrapPeersResponse} ListBootstrapPeersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListBootstrapPeersResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListBootstrapPeersResponse message.
     * @function verify
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListBootstrapPeersResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.peers != null && message.hasOwnProperty("peers")) {
            if (!Array.isArray(message.peers))
                return "peers: array expected";
            for (let i = 0; i < message.peers.length; ++i) {
                let error = $root.BootstrapPeer.verify(message.peers[i]);
                if (error)
                    return "peers." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListBootstrapPeersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListBootstrapPeersResponse} ListBootstrapPeersResponse
     */
    ListBootstrapPeersResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListBootstrapPeersResponse)
            return object;
        let message = new $root.ListBootstrapPeersResponse();
        if (object.peers) {
            if (!Array.isArray(object.peers))
                throw TypeError(".ListBootstrapPeersResponse.peers: array expected");
            message.peers = [];
            for (let i = 0; i < object.peers.length; ++i) {
                if (typeof object.peers[i] !== "object")
                    throw TypeError(".ListBootstrapPeersResponse.peers: object expected");
                message.peers[i] = $root.BootstrapPeer.fromObject(object.peers[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListBootstrapPeersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListBootstrapPeersResponse
     * @static
     * @param {ListBootstrapPeersResponse} message ListBootstrapPeersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListBootstrapPeersResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.peers = [];
        if (message.peers && message.peers.length) {
            object.peers = [];
            for (let j = 0; j < message.peers.length; ++j)
                object.peers[j] = $root.BootstrapPeer.toObject(message.peers[j], options);
        }
        return object;
    };

    /**
     * Converts this ListBootstrapPeersResponse to JSON.
     * @function toJSON
     * @memberof ListBootstrapPeersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListBootstrapPeersResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListBootstrapPeersResponse;
})();

export const BootstrapPeer = $root.BootstrapPeer = (() => {

    /**
     * Properties of a BootstrapPeer.
     * @exports IBootstrapPeer
     * @interface IBootstrapPeer
     * @property {Uint8Array|null} [hostId] BootstrapPeer hostId
     * @property {string|null} [label] BootstrapPeer label
     */

    /**
     * Constructs a new BootstrapPeer.
     * @exports BootstrapPeer
     * @classdesc Represents a BootstrapPeer.
     * @implements IBootstrapPeer
     * @constructor
     * @param {IBootstrapPeer=} [properties] Properties to set
     */
    function BootstrapPeer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapPeer hostId.
     * @member {Uint8Array} hostId
     * @memberof BootstrapPeer
     * @instance
     */
    BootstrapPeer.prototype.hostId = $util.newBuffer([]);

    /**
     * BootstrapPeer label.
     * @member {string} label
     * @memberof BootstrapPeer
     * @instance
     */
    BootstrapPeer.prototype.label = "";

    /**
     * Creates a new BootstrapPeer instance using the specified properties.
     * @function create
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer=} [properties] Properties to set
     * @returns {BootstrapPeer} BootstrapPeer instance
     */
    BootstrapPeer.create = function create(properties) {
        return new BootstrapPeer(properties);
    };

    /**
     * Encodes the specified BootstrapPeer message. Does not implicitly {@link BootstrapPeer.verify|verify} messages.
     * @function encode
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer} message BootstrapPeer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapPeer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hostId);
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
        return writer;
    };

    /**
     * Encodes the specified BootstrapPeer message, length delimited. Does not implicitly {@link BootstrapPeer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapPeer
     * @static
     * @param {IBootstrapPeer} message BootstrapPeer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapPeer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapPeer message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapPeer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapPeer} BootstrapPeer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapPeer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapPeer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hostId = reader.bytes();
                break;
            case 2:
                message.label = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapPeer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapPeer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapPeer} BootstrapPeer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapPeer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapPeer message.
     * @function verify
     * @memberof BootstrapPeer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapPeer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                return "hostId: buffer expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        return null;
    };

    /**
     * Creates a BootstrapPeer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapPeer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapPeer} BootstrapPeer
     */
    BootstrapPeer.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapPeer)
            return object;
        let message = new $root.BootstrapPeer();
        if (object.hostId != null)
            if (typeof object.hostId === "string")
                $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
            else if (object.hostId.length)
                message.hostId = object.hostId;
        if (object.label != null)
            message.label = String(object.label);
        return message;
    };

    /**
     * Creates a plain object from a BootstrapPeer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapPeer
     * @static
     * @param {BootstrapPeer} message BootstrapPeer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapPeer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.hostId = "";
            else {
                object.hostId = [];
                if (options.bytes !== Array)
                    object.hostId = $util.newBuffer(object.hostId);
            }
            object.label = "";
        }
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        return object;
    };

    /**
     * Converts this BootstrapPeer to JSON.
     * @function toJSON
     * @memberof BootstrapPeer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapPeer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BootstrapPeer;
})();

export const BootstrapServiceMessage = $root.BootstrapServiceMessage = (() => {

    /**
     * Properties of a BootstrapServiceMessage.
     * @exports IBootstrapServiceMessage
     * @interface IBootstrapServiceMessage
     * @property {BootstrapServiceMessage.IBrokerOffer|null} [brokerOffer] BootstrapServiceMessage brokerOffer
     * @property {BootstrapServiceMessage.IPublishRequest|null} [publishRequest] BootstrapServiceMessage publishRequest
     * @property {BootstrapServiceMessage.IPublishResponse|null} [publishResponse] BootstrapServiceMessage publishResponse
     */

    /**
     * Constructs a new BootstrapServiceMessage.
     * @exports BootstrapServiceMessage
     * @classdesc Represents a BootstrapServiceMessage.
     * @implements IBootstrapServiceMessage
     * @constructor
     * @param {IBootstrapServiceMessage=} [properties] Properties to set
     */
    function BootstrapServiceMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BootstrapServiceMessage brokerOffer.
     * @member {BootstrapServiceMessage.IBrokerOffer|null|undefined} brokerOffer
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.brokerOffer = null;

    /**
     * BootstrapServiceMessage publishRequest.
     * @member {BootstrapServiceMessage.IPublishRequest|null|undefined} publishRequest
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.publishRequest = null;

    /**
     * BootstrapServiceMessage publishResponse.
     * @member {BootstrapServiceMessage.IPublishResponse|null|undefined} publishResponse
     * @memberof BootstrapServiceMessage
     * @instance
     */
    BootstrapServiceMessage.prototype.publishResponse = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * BootstrapServiceMessage body.
     * @member {"brokerOffer"|"publishRequest"|"publishResponse"|undefined} body
     * @memberof BootstrapServiceMessage
     * @instance
     */
    Object.defineProperty(BootstrapServiceMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["brokerOffer", "publishRequest", "publishResponse"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new BootstrapServiceMessage instance using the specified properties.
     * @function create
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage=} [properties] Properties to set
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage instance
     */
    BootstrapServiceMessage.create = function create(properties) {
        return new BootstrapServiceMessage(properties);
    };

    /**
     * Encodes the specified BootstrapServiceMessage message. Does not implicitly {@link BootstrapServiceMessage.verify|verify} messages.
     * @function encode
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage} message BootstrapServiceMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapServiceMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.brokerOffer != null && Object.hasOwnProperty.call(message, "brokerOffer"))
            $root.BootstrapServiceMessage.BrokerOffer.encode(message.brokerOffer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.publishRequest != null && Object.hasOwnProperty.call(message, "publishRequest"))
            $root.BootstrapServiceMessage.PublishRequest.encode(message.publishRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.publishResponse != null && Object.hasOwnProperty.call(message, "publishResponse"))
            $root.BootstrapServiceMessage.PublishResponse.encode(message.publishResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BootstrapServiceMessage message, length delimited. Does not implicitly {@link BootstrapServiceMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BootstrapServiceMessage
     * @static
     * @param {IBootstrapServiceMessage} message BootstrapServiceMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BootstrapServiceMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BootstrapServiceMessage message from the specified reader or buffer.
     * @function decode
     * @memberof BootstrapServiceMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapServiceMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.decode(reader, reader.uint32());
                break;
            case 2:
                message.publishRequest = $root.BootstrapServiceMessage.PublishRequest.decode(reader, reader.uint32());
                break;
            case 3:
                message.publishResponse = $root.BootstrapServiceMessage.PublishResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BootstrapServiceMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BootstrapServiceMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BootstrapServiceMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BootstrapServiceMessage message.
     * @function verify
     * @memberof BootstrapServiceMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BootstrapServiceMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.brokerOffer != null && message.hasOwnProperty("brokerOffer")) {
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.BrokerOffer.verify(message.brokerOffer);
                if (error)
                    return "brokerOffer." + error;
            }
        }
        if (message.publishRequest != null && message.hasOwnProperty("publishRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.PublishRequest.verify(message.publishRequest);
                if (error)
                    return "publishRequest." + error;
            }
        }
        if (message.publishResponse != null && message.hasOwnProperty("publishResponse")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.BootstrapServiceMessage.PublishResponse.verify(message.publishResponse);
                if (error)
                    return "publishResponse." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BootstrapServiceMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BootstrapServiceMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BootstrapServiceMessage} BootstrapServiceMessage
     */
    BootstrapServiceMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.BootstrapServiceMessage)
            return object;
        let message = new $root.BootstrapServiceMessage();
        if (object.brokerOffer != null) {
            if (typeof object.brokerOffer !== "object")
                throw TypeError(".BootstrapServiceMessage.brokerOffer: object expected");
            message.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.fromObject(object.brokerOffer);
        }
        if (object.publishRequest != null) {
            if (typeof object.publishRequest !== "object")
                throw TypeError(".BootstrapServiceMessage.publishRequest: object expected");
            message.publishRequest = $root.BootstrapServiceMessage.PublishRequest.fromObject(object.publishRequest);
        }
        if (object.publishResponse != null) {
            if (typeof object.publishResponse !== "object")
                throw TypeError(".BootstrapServiceMessage.publishResponse: object expected");
            message.publishResponse = $root.BootstrapServiceMessage.PublishResponse.fromObject(object.publishResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a BootstrapServiceMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BootstrapServiceMessage
     * @static
     * @param {BootstrapServiceMessage} message BootstrapServiceMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BootstrapServiceMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.brokerOffer != null && message.hasOwnProperty("brokerOffer")) {
            object.brokerOffer = $root.BootstrapServiceMessage.BrokerOffer.toObject(message.brokerOffer, options);
            if (options.oneofs)
                object.body = "brokerOffer";
        }
        if (message.publishRequest != null && message.hasOwnProperty("publishRequest")) {
            object.publishRequest = $root.BootstrapServiceMessage.PublishRequest.toObject(message.publishRequest, options);
            if (options.oneofs)
                object.body = "publishRequest";
        }
        if (message.publishResponse != null && message.hasOwnProperty("publishResponse")) {
            object.publishResponse = $root.BootstrapServiceMessage.PublishResponse.toObject(message.publishResponse, options);
            if (options.oneofs)
                object.body = "publishResponse";
        }
        return object;
    };

    /**
     * Converts this BootstrapServiceMessage to JSON.
     * @function toJSON
     * @memberof BootstrapServiceMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BootstrapServiceMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    BootstrapServiceMessage.BrokerOffer = (function() {

        /**
         * Properties of a BrokerOffer.
         * @memberof BootstrapServiceMessage
         * @interface IBrokerOffer
         */

        /**
         * Constructs a new BrokerOffer.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a BrokerOffer.
         * @implements IBrokerOffer
         * @constructor
         * @param {BootstrapServiceMessage.IBrokerOffer=} [properties] Properties to set
         */
        function BrokerOffer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BrokerOffer instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer instance
         */
        BrokerOffer.create = function create(properties) {
            return new BrokerOffer(properties);
        };

        /**
         * Encodes the specified BrokerOffer message. Does not implicitly {@link BootstrapServiceMessage.BrokerOffer.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer} message BrokerOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BrokerOffer message, length delimited. Does not implicitly {@link BootstrapServiceMessage.BrokerOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.IBrokerOffer} message BrokerOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BrokerOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BrokerOffer message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.BrokerOffer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BrokerOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BrokerOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BrokerOffer message.
         * @function verify
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BrokerOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a BrokerOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.BrokerOffer} BrokerOffer
         */
        BrokerOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.BrokerOffer)
                return object;
            return new $root.BootstrapServiceMessage.BrokerOffer();
        };

        /**
         * Creates a plain object from a BrokerOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @static
         * @param {BootstrapServiceMessage.BrokerOffer} message BrokerOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BrokerOffer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BrokerOffer to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.BrokerOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BrokerOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BrokerOffer;
    })();

    BootstrapServiceMessage.PublishRequest = (function() {

        /**
         * Properties of a PublishRequest.
         * @memberof BootstrapServiceMessage
         * @interface IPublishRequest
         * @property {string|null} [name] PublishRequest name
         * @property {ICertificate|null} [certificate] PublishRequest certificate
         */

        /**
         * Constructs a new PublishRequest.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a PublishRequest.
         * @implements IPublishRequest
         * @constructor
         * @param {BootstrapServiceMessage.IPublishRequest=} [properties] Properties to set
         */
        function PublishRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishRequest name.
         * @member {string} name
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         */
        PublishRequest.prototype.name = "";

        /**
         * PublishRequest certificate.
         * @member {ICertificate|null|undefined} certificate
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         */
        PublishRequest.prototype.certificate = null;

        /**
         * Creates a new PublishRequest instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest instance
         */
        PublishRequest.create = function create(properties) {
            return new PublishRequest(properties);
        };

        /**
         * Encodes the specified PublishRequest message. Does not implicitly {@link BootstrapServiceMessage.PublishRequest.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest} message PublishRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                $root.Certificate.encode(message.certificate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PublishRequest message, length delimited. Does not implicitly {@link BootstrapServiceMessage.PublishRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.IPublishRequest} message PublishRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.PublishRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.certificate = $root.Certificate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishRequest message.
         * @function verify
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.certificate != null && message.hasOwnProperty("certificate")) {
                let error = $root.Certificate.verify(message.certificate);
                if (error)
                    return "certificate." + error;
            }
            return null;
        };

        /**
         * Creates a PublishRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.PublishRequest} PublishRequest
         */
        PublishRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.PublishRequest)
                return object;
            let message = new $root.BootstrapServiceMessage.PublishRequest();
            if (object.name != null)
                message.name = String(object.name);
            if (object.certificate != null) {
                if (typeof object.certificate !== "object")
                    throw TypeError(".BootstrapServiceMessage.PublishRequest.certificate: object expected");
                message.certificate = $root.Certificate.fromObject(object.certificate);
            }
            return message;
        };

        /**
         * Creates a plain object from a PublishRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.PublishRequest
         * @static
         * @param {BootstrapServiceMessage.PublishRequest} message PublishRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.certificate = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = $root.Certificate.toObject(message.certificate, options);
            return object;
        };

        /**
         * Converts this PublishRequest to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.PublishRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishRequest;
    })();

    BootstrapServiceMessage.PublishResponse = (function() {

        /**
         * Properties of a PublishResponse.
         * @memberof BootstrapServiceMessage
         * @interface IPublishResponse
         * @property {string|null} [error] PublishResponse error
         */

        /**
         * Constructs a new PublishResponse.
         * @memberof BootstrapServiceMessage
         * @classdesc Represents a PublishResponse.
         * @implements IPublishResponse
         * @constructor
         * @param {BootstrapServiceMessage.IPublishResponse=} [properties] Properties to set
         */
        function PublishResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishResponse error.
         * @member {string} error
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         */
        PublishResponse.prototype.error = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PublishResponse body.
         * @member {"error"|undefined} body
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         */
        Object.defineProperty(PublishResponse.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["error"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PublishResponse instance using the specified properties.
         * @function create
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse=} [properties] Properties to set
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse instance
         */
        PublishResponse.create = function create(properties) {
            return new PublishResponse(properties);
        };

        /**
         * Encodes the specified PublishResponse message. Does not implicitly {@link BootstrapServiceMessage.PublishResponse.verify|verify} messages.
         * @function encode
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse} message PublishResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
            return writer;
        };

        /**
         * Encodes the specified PublishResponse message, length delimited. Does not implicitly {@link BootstrapServiceMessage.PublishResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.IPublishResponse} message PublishResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BootstrapServiceMessage.PublishResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishResponse message.
         * @function verify
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.error != null && message.hasOwnProperty("error")) {
                properties.body = 1;
                if (!$util.isString(message.error))
                    return "error: string expected";
            }
            return null;
        };

        /**
         * Creates a PublishResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BootstrapServiceMessage.PublishResponse} PublishResponse
         */
        PublishResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BootstrapServiceMessage.PublishResponse)
                return object;
            let message = new $root.BootstrapServiceMessage.PublishResponse();
            if (object.error != null)
                message.error = String(object.error);
            return message;
        };

        /**
         * Creates a plain object from a PublishResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BootstrapServiceMessage.PublishResponse
         * @static
         * @param {BootstrapServiceMessage.PublishResponse} message PublishResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.error != null && message.hasOwnProperty("error")) {
                object.error = message.error;
                if (options.oneofs)
                    object.body = "error";
            }
            return object;
        };

        /**
         * Converts this PublishResponse to JSON.
         * @function toJSON
         * @memberof BootstrapServiceMessage.PublishResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishResponse;
    })();

    return BootstrapServiceMessage;
})();

export const PublishNetworkToBootstrapPeerRequest = $root.PublishNetworkToBootstrapPeerRequest = (() => {

    /**
     * Properties of a PublishNetworkToBootstrapPeerRequest.
     * @exports IPublishNetworkToBootstrapPeerRequest
     * @interface IPublishNetworkToBootstrapPeerRequest
     * @property {Uint8Array|null} [hostId] PublishNetworkToBootstrapPeerRequest hostId
     * @property {INetwork|null} [network] PublishNetworkToBootstrapPeerRequest network
     */

    /**
     * Constructs a new PublishNetworkToBootstrapPeerRequest.
     * @exports PublishNetworkToBootstrapPeerRequest
     * @classdesc Represents a PublishNetworkToBootstrapPeerRequest.
     * @implements IPublishNetworkToBootstrapPeerRequest
     * @constructor
     * @param {IPublishNetworkToBootstrapPeerRequest=} [properties] Properties to set
     */
    function PublishNetworkToBootstrapPeerRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PublishNetworkToBootstrapPeerRequest hostId.
     * @member {Uint8Array} hostId
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     */
    PublishNetworkToBootstrapPeerRequest.prototype.hostId = $util.newBuffer([]);

    /**
     * PublishNetworkToBootstrapPeerRequest network.
     * @member {INetwork|null|undefined} network
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     */
    PublishNetworkToBootstrapPeerRequest.prototype.network = null;

    /**
     * Creates a new PublishNetworkToBootstrapPeerRequest instance using the specified properties.
     * @function create
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest=} [properties] Properties to set
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest instance
     */
    PublishNetworkToBootstrapPeerRequest.create = function create(properties) {
        return new PublishNetworkToBootstrapPeerRequest(properties);
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerRequest message. Does not implicitly {@link PublishNetworkToBootstrapPeerRequest.verify|verify} messages.
     * @function encode
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hostId != null && Object.hasOwnProperty.call(message, "hostId"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hostId);
        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
            $root.Network.encode(message.network, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerRequest message, length delimited. Does not implicitly {@link PublishNetworkToBootstrapPeerRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {IPublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishNetworkToBootstrapPeerRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hostId = reader.bytes();
                break;
            case 2:
                message.network = $root.Network.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishNetworkToBootstrapPeerRequest message.
     * @function verify
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishNetworkToBootstrapPeerRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            if (!(message.hostId && typeof message.hostId.length === "number" || $util.isString(message.hostId)))
                return "hostId: buffer expected";
        if (message.network != null && message.hasOwnProperty("network")) {
            let error = $root.Network.verify(message.network);
            if (error)
                return "network." + error;
        }
        return null;
    };

    /**
     * Creates a PublishNetworkToBootstrapPeerRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishNetworkToBootstrapPeerRequest} PublishNetworkToBootstrapPeerRequest
     */
    PublishNetworkToBootstrapPeerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishNetworkToBootstrapPeerRequest)
            return object;
        let message = new $root.PublishNetworkToBootstrapPeerRequest();
        if (object.hostId != null)
            if (typeof object.hostId === "string")
                $util.base64.decode(object.hostId, message.hostId = $util.newBuffer($util.base64.length(object.hostId)), 0);
            else if (object.hostId.length)
                message.hostId = object.hostId;
        if (object.network != null) {
            if (typeof object.network !== "object")
                throw TypeError(".PublishNetworkToBootstrapPeerRequest.network: object expected");
            message.network = $root.Network.fromObject(object.network);
        }
        return message;
    };

    /**
     * Creates a plain object from a PublishNetworkToBootstrapPeerRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @static
     * @param {PublishNetworkToBootstrapPeerRequest} message PublishNetworkToBootstrapPeerRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishNetworkToBootstrapPeerRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.hostId = "";
            else {
                object.hostId = [];
                if (options.bytes !== Array)
                    object.hostId = $util.newBuffer(object.hostId);
            }
            object.network = null;
        }
        if (message.hostId != null && message.hasOwnProperty("hostId"))
            object.hostId = options.bytes === String ? $util.base64.encode(message.hostId, 0, message.hostId.length) : options.bytes === Array ? Array.prototype.slice.call(message.hostId) : message.hostId;
        if (message.network != null && message.hasOwnProperty("network"))
            object.network = $root.Network.toObject(message.network, options);
        return object;
    };

    /**
     * Converts this PublishNetworkToBootstrapPeerRequest to JSON.
     * @function toJSON
     * @memberof PublishNetworkToBootstrapPeerRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishNetworkToBootstrapPeerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishNetworkToBootstrapPeerRequest;
})();

export const PublishNetworkToBootstrapPeerResponse = $root.PublishNetworkToBootstrapPeerResponse = (() => {

    /**
     * Properties of a PublishNetworkToBootstrapPeerResponse.
     * @exports IPublishNetworkToBootstrapPeerResponse
     * @interface IPublishNetworkToBootstrapPeerResponse
     */

    /**
     * Constructs a new PublishNetworkToBootstrapPeerResponse.
     * @exports PublishNetworkToBootstrapPeerResponse
     * @classdesc Represents a PublishNetworkToBootstrapPeerResponse.
     * @implements IPublishNetworkToBootstrapPeerResponse
     * @constructor
     * @param {IPublishNetworkToBootstrapPeerResponse=} [properties] Properties to set
     */
    function PublishNetworkToBootstrapPeerResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new PublishNetworkToBootstrapPeerResponse instance using the specified properties.
     * @function create
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse=} [properties] Properties to set
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse instance
     */
    PublishNetworkToBootstrapPeerResponse.create = function create(properties) {
        return new PublishNetworkToBootstrapPeerResponse(properties);
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerResponse message. Does not implicitly {@link PublishNetworkToBootstrapPeerResponse.verify|verify} messages.
     * @function encode
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified PublishNetworkToBootstrapPeerResponse message, length delimited. Does not implicitly {@link PublishNetworkToBootstrapPeerResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {IPublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublishNetworkToBootstrapPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishNetworkToBootstrapPeerResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublishNetworkToBootstrapPeerResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublishNetworkToBootstrapPeerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublishNetworkToBootstrapPeerResponse message.
     * @function verify
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublishNetworkToBootstrapPeerResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a PublishNetworkToBootstrapPeerResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublishNetworkToBootstrapPeerResponse} PublishNetworkToBootstrapPeerResponse
     */
    PublishNetworkToBootstrapPeerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PublishNetworkToBootstrapPeerResponse)
            return object;
        return new $root.PublishNetworkToBootstrapPeerResponse();
    };

    /**
     * Creates a plain object from a PublishNetworkToBootstrapPeerResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @static
     * @param {PublishNetworkToBootstrapPeerResponse} message PublishNetworkToBootstrapPeerResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublishNetworkToBootstrapPeerResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this PublishNetworkToBootstrapPeerResponse to JSON.
     * @function toJSON
     * @memberof PublishNetworkToBootstrapPeerResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublishNetworkToBootstrapPeerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublishNetworkToBootstrapPeerResponse;
})();

export const PeerExchangeMessage = $root.PeerExchangeMessage = (() => {

    /**
     * Properties of a PeerExchangeMessage.
     * @exports IPeerExchangeMessage
     * @interface IPeerExchangeMessage
     * @property {PeerExchangeMessage.IRequest|null} [request] PeerExchangeMessage request
     * @property {PeerExchangeMessage.IResponse|null} [response] PeerExchangeMessage response
     * @property {PeerExchangeMessage.IOffer|null} [offer] PeerExchangeMessage offer
     * @property {PeerExchangeMessage.IAnswer|null} [answer] PeerExchangeMessage answer
     * @property {PeerExchangeMessage.IIceCandidate|null} [iceCandidate] PeerExchangeMessage iceCandidate
     * @property {PeerExchangeMessage.ICallbackRequest|null} [callbackRequest] PeerExchangeMessage callbackRequest
     */

    /**
     * Constructs a new PeerExchangeMessage.
     * @exports PeerExchangeMessage
     * @classdesc Represents a PeerExchangeMessage.
     * @implements IPeerExchangeMessage
     * @constructor
     * @param {IPeerExchangeMessage=} [properties] Properties to set
     */
    function PeerExchangeMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PeerExchangeMessage request.
     * @member {PeerExchangeMessage.IRequest|null|undefined} request
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.request = null;

    /**
     * PeerExchangeMessage response.
     * @member {PeerExchangeMessage.IResponse|null|undefined} response
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.response = null;

    /**
     * PeerExchangeMessage offer.
     * @member {PeerExchangeMessage.IOffer|null|undefined} offer
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.offer = null;

    /**
     * PeerExchangeMessage answer.
     * @member {PeerExchangeMessage.IAnswer|null|undefined} answer
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.answer = null;

    /**
     * PeerExchangeMessage iceCandidate.
     * @member {PeerExchangeMessage.IIceCandidate|null|undefined} iceCandidate
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.iceCandidate = null;

    /**
     * PeerExchangeMessage callbackRequest.
     * @member {PeerExchangeMessage.ICallbackRequest|null|undefined} callbackRequest
     * @memberof PeerExchangeMessage
     * @instance
     */
    PeerExchangeMessage.prototype.callbackRequest = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * PeerExchangeMessage body.
     * @member {"request"|"response"|"offer"|"answer"|"iceCandidate"|"callbackRequest"|undefined} body
     * @memberof PeerExchangeMessage
     * @instance
     */
    Object.defineProperty(PeerExchangeMessage.prototype, "body", {
        get: $util.oneOfGetter($oneOfFields = ["request", "response", "offer", "answer", "iceCandidate", "callbackRequest"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new PeerExchangeMessage instance using the specified properties.
     * @function create
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage=} [properties] Properties to set
     * @returns {PeerExchangeMessage} PeerExchangeMessage instance
     */
    PeerExchangeMessage.create = function create(properties) {
        return new PeerExchangeMessage(properties);
    };

    /**
     * Encodes the specified PeerExchangeMessage message. Does not implicitly {@link PeerExchangeMessage.verify|verify} messages.
     * @function encode
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage} message PeerExchangeMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerExchangeMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.request != null && Object.hasOwnProperty.call(message, "request"))
            $root.PeerExchangeMessage.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.response != null && Object.hasOwnProperty.call(message, "response"))
            $root.PeerExchangeMessage.Response.encode(message.response, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
            $root.PeerExchangeMessage.Offer.encode(message.offer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.answer != null && Object.hasOwnProperty.call(message, "answer"))
            $root.PeerExchangeMessage.Answer.encode(message.answer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.iceCandidate != null && Object.hasOwnProperty.call(message, "iceCandidate"))
            $root.PeerExchangeMessage.IceCandidate.encode(message.iceCandidate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.callbackRequest != null && Object.hasOwnProperty.call(message, "callbackRequest"))
            $root.PeerExchangeMessage.CallbackRequest.encode(message.callbackRequest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PeerExchangeMessage message, length delimited. Does not implicitly {@link PeerExchangeMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PeerExchangeMessage
     * @static
     * @param {IPeerExchangeMessage} message PeerExchangeMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PeerExchangeMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PeerExchangeMessage message from the specified reader or buffer.
     * @function decode
     * @memberof PeerExchangeMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerExchangeMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.request = $root.PeerExchangeMessage.Request.decode(reader, reader.uint32());
                break;
            case 2:
                message.response = $root.PeerExchangeMessage.Response.decode(reader, reader.uint32());
                break;
            case 3:
                message.offer = $root.PeerExchangeMessage.Offer.decode(reader, reader.uint32());
                break;
            case 4:
                message.answer = $root.PeerExchangeMessage.Answer.decode(reader, reader.uint32());
                break;
            case 5:
                message.iceCandidate = $root.PeerExchangeMessage.IceCandidate.decode(reader, reader.uint32());
                break;
            case 6:
                message.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PeerExchangeMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PeerExchangeMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PeerExchangeMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PeerExchangeMessage message.
     * @function verify
     * @memberof PeerExchangeMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PeerExchangeMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.request != null && message.hasOwnProperty("request")) {
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Request.verify(message.request);
                if (error)
                    return "request." + error;
            }
        }
        if (message.response != null && message.hasOwnProperty("response")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Response.verify(message.response);
                if (error)
                    return "response." + error;
            }
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Offer.verify(message.offer);
                if (error)
                    return "offer." + error;
            }
        }
        if (message.answer != null && message.hasOwnProperty("answer")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.Answer.verify(message.answer);
                if (error)
                    return "answer." + error;
            }
        }
        if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.IceCandidate.verify(message.iceCandidate);
                if (error)
                    return "iceCandidate." + error;
            }
        }
        if (message.callbackRequest != null && message.hasOwnProperty("callbackRequest")) {
            if (properties.body === 1)
                return "body: multiple values";
            properties.body = 1;
            {
                let error = $root.PeerExchangeMessage.CallbackRequest.verify(message.callbackRequest);
                if (error)
                    return "callbackRequest." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PeerExchangeMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PeerExchangeMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PeerExchangeMessage} PeerExchangeMessage
     */
    PeerExchangeMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.PeerExchangeMessage)
            return object;
        let message = new $root.PeerExchangeMessage();
        if (object.request != null) {
            if (typeof object.request !== "object")
                throw TypeError(".PeerExchangeMessage.request: object expected");
            message.request = $root.PeerExchangeMessage.Request.fromObject(object.request);
        }
        if (object.response != null) {
            if (typeof object.response !== "object")
                throw TypeError(".PeerExchangeMessage.response: object expected");
            message.response = $root.PeerExchangeMessage.Response.fromObject(object.response);
        }
        if (object.offer != null) {
            if (typeof object.offer !== "object")
                throw TypeError(".PeerExchangeMessage.offer: object expected");
            message.offer = $root.PeerExchangeMessage.Offer.fromObject(object.offer);
        }
        if (object.answer != null) {
            if (typeof object.answer !== "object")
                throw TypeError(".PeerExchangeMessage.answer: object expected");
            message.answer = $root.PeerExchangeMessage.Answer.fromObject(object.answer);
        }
        if (object.iceCandidate != null) {
            if (typeof object.iceCandidate !== "object")
                throw TypeError(".PeerExchangeMessage.iceCandidate: object expected");
            message.iceCandidate = $root.PeerExchangeMessage.IceCandidate.fromObject(object.iceCandidate);
        }
        if (object.callbackRequest != null) {
            if (typeof object.callbackRequest !== "object")
                throw TypeError(".PeerExchangeMessage.callbackRequest: object expected");
            message.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.fromObject(object.callbackRequest);
        }
        return message;
    };

    /**
     * Creates a plain object from a PeerExchangeMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PeerExchangeMessage
     * @static
     * @param {PeerExchangeMessage} message PeerExchangeMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PeerExchangeMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.request != null && message.hasOwnProperty("request")) {
            object.request = $root.PeerExchangeMessage.Request.toObject(message.request, options);
            if (options.oneofs)
                object.body = "request";
        }
        if (message.response != null && message.hasOwnProperty("response")) {
            object.response = $root.PeerExchangeMessage.Response.toObject(message.response, options);
            if (options.oneofs)
                object.body = "response";
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            object.offer = $root.PeerExchangeMessage.Offer.toObject(message.offer, options);
            if (options.oneofs)
                object.body = "offer";
        }
        if (message.answer != null && message.hasOwnProperty("answer")) {
            object.answer = $root.PeerExchangeMessage.Answer.toObject(message.answer, options);
            if (options.oneofs)
                object.body = "answer";
        }
        if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
            object.iceCandidate = $root.PeerExchangeMessage.IceCandidate.toObject(message.iceCandidate, options);
            if (options.oneofs)
                object.body = "iceCandidate";
        }
        if (message.callbackRequest != null && message.hasOwnProperty("callbackRequest")) {
            object.callbackRequest = $root.PeerExchangeMessage.CallbackRequest.toObject(message.callbackRequest, options);
            if (options.oneofs)
                object.body = "callbackRequest";
        }
        return object;
    };

    /**
     * Converts this PeerExchangeMessage to JSON.
     * @function toJSON
     * @memberof PeerExchangeMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PeerExchangeMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PeerExchangeMessage.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof PeerExchangeMessage
         * @interface IRequest
         * @property {number|null} [count] Request count
         */

        /**
         * Constructs a new Request.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {PeerExchangeMessage.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request count.
         * @member {number} count
         * @memberof PeerExchangeMessage.Request
         * @instance
         */
        Request.prototype.count = 0;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link PeerExchangeMessage.Request.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.count);
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link PeerExchangeMessage.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Request)
                return object;
            let message = new $root.PeerExchangeMessage.Request();
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Request
         * @static
         * @param {PeerExchangeMessage.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    PeerExchangeMessage.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof PeerExchangeMessage
         * @interface IResponse
         * @property {Array.<Uint8Array>|null} [ids] Response ids
         */

        /**
         * Constructs a new Response.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {PeerExchangeMessage.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            this.ids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response ids.
         * @member {Array.<Uint8Array>} ids
         * @memberof PeerExchangeMessage.Response
         * @instance
         */
        Response.prototype.ids = $util.emptyArray;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link PeerExchangeMessage.Response.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (let i = 0; i < message.ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ids[i]);
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link PeerExchangeMessage.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Response();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (let i = 0; i < message.ids.length; ++i)
                    if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                        return "ids: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Response)
                return object;
            let message = new $root.PeerExchangeMessage.Response();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".PeerExchangeMessage.Response.ids: array expected");
                message.ids = [];
                for (let i = 0; i < object.ids.length; ++i)
                    if (typeof object.ids[i] === "string")
                        $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                    else if (object.ids[i].length)
                        message.ids[i] = object.ids[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Response
         * @static
         * @param {PeerExchangeMessage.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (let j = 0; j < message.ids.length; ++j)
                    object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
            }
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    PeerExchangeMessage.Offer = (function() {

        /**
         * Properties of an Offer.
         * @memberof PeerExchangeMessage
         * @interface IOffer
         * @property {number|null} [mediationId] Offer mediationId
         * @property {Uint8Array|null} [data] Offer data
         */

        /**
         * Constructs a new Offer.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an Offer.
         * @implements IOffer
         * @constructor
         * @param {PeerExchangeMessage.IOffer=} [properties] Properties to set
         */
        function Offer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Offer mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.Offer
         * @instance
         */
        Offer.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Offer data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.Offer
         * @instance
         */
        Offer.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Offer instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Offer} Offer instance
         */
        Offer.create = function create(properties) {
            return new Offer(properties);
        };

        /**
         * Encodes the specified Offer message. Does not implicitly {@link PeerExchangeMessage.Offer.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Offer message, length delimited. Does not implicitly {@link PeerExchangeMessage.Offer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Offer message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Offer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Offer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Offer message.
         * @function verify
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Offer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an Offer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Offer} Offer
         */
        Offer.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Offer)
                return object;
            let message = new $root.PeerExchangeMessage.Offer();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an Offer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Offer
         * @static
         * @param {PeerExchangeMessage.Offer} message Offer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Offer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Offer to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Offer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Offer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Offer;
    })();

    PeerExchangeMessage.Answer = (function() {

        /**
         * Properties of an Answer.
         * @memberof PeerExchangeMessage
         * @interface IAnswer
         * @property {number|null} [mediationId] Answer mediationId
         * @property {Uint8Array|null} [data] Answer data
         */

        /**
         * Constructs a new Answer.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an Answer.
         * @implements IAnswer
         * @constructor
         * @param {PeerExchangeMessage.IAnswer=} [properties] Properties to set
         */
        function Answer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Answer mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.Answer
         * @instance
         */
        Answer.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Answer data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.Answer
         * @instance
         */
        Answer.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Answer instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer=} [properties] Properties to set
         * @returns {PeerExchangeMessage.Answer} Answer instance
         */
        Answer.create = function create(properties) {
            return new Answer(properties);
        };

        /**
         * Encodes the specified Answer message. Does not implicitly {@link PeerExchangeMessage.Answer.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Answer message, length delimited. Does not implicitly {@link PeerExchangeMessage.Answer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Answer message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.Answer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Answer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Answer message.
         * @function verify
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Answer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an Answer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.Answer} Answer
         */
        Answer.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.Answer)
                return object;
            let message = new $root.PeerExchangeMessage.Answer();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an Answer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.Answer
         * @static
         * @param {PeerExchangeMessage.Answer} message Answer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Answer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Answer to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.Answer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Answer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Answer;
    })();

    PeerExchangeMessage.IceCandidate = (function() {

        /**
         * Properties of an IceCandidate.
         * @memberof PeerExchangeMessage
         * @interface IIceCandidate
         * @property {number|null} [mediationId] IceCandidate mediationId
         * @property {number|null} [index] IceCandidate index
         * @property {Uint8Array|null} [data] IceCandidate data
         */

        /**
         * Constructs a new IceCandidate.
         * @memberof PeerExchangeMessage
         * @classdesc Represents an IceCandidate.
         * @implements IIceCandidate
         * @constructor
         * @param {PeerExchangeMessage.IIceCandidate=} [properties] Properties to set
         */
        function IceCandidate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceCandidate mediationId.
         * @member {number} mediationId
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.mediationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IceCandidate index.
         * @member {number} index
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IceCandidate data.
         * @member {Uint8Array} data
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         */
        IceCandidate.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new IceCandidate instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate=} [properties] Properties to set
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate instance
         */
        IceCandidate.create = function create(properties) {
            return new IceCandidate(properties);
        };

        /**
         * Encodes the specified IceCandidate message. Does not implicitly {@link PeerExchangeMessage.IceCandidate.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mediationId != null && Object.hasOwnProperty.call(message, "mediationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mediationId);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link PeerExchangeMessage.IceCandidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.IceCandidate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mediationId = reader.uint64();
                    break;
                case 2:
                    message.index = reader.uint64();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceCandidate message.
         * @function verify
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceCandidate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (!$util.isInteger(message.mediationId) && !(message.mediationId && $util.isInteger(message.mediationId.low) && $util.isInteger(message.mediationId.high)))
                    return "mediationId: integer|Long expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.IceCandidate} IceCandidate
         */
        IceCandidate.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.IceCandidate)
                return object;
            let message = new $root.PeerExchangeMessage.IceCandidate();
            if (object.mediationId != null)
                if ($util.Long)
                    (message.mediationId = $util.Long.fromValue(object.mediationId)).unsigned = true;
                else if (typeof object.mediationId === "string")
                    message.mediationId = parseInt(object.mediationId, 10);
                else if (typeof object.mediationId === "number")
                    message.mediationId = object.mediationId;
                else if (typeof object.mediationId === "object")
                    message.mediationId = new $util.LongBits(object.mediationId.low >>> 0, object.mediationId.high >>> 0).toNumber(true);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.IceCandidate
         * @static
         * @param {PeerExchangeMessage.IceCandidate} message IceCandidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceCandidate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mediationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediationId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.mediationId != null && message.hasOwnProperty("mediationId"))
                if (typeof message.mediationId === "number")
                    object.mediationId = options.longs === String ? String(message.mediationId) : message.mediationId;
                else
                    object.mediationId = options.longs === String ? $util.Long.prototype.toString.call(message.mediationId) : options.longs === Number ? new $util.LongBits(message.mediationId.low >>> 0, message.mediationId.high >>> 0).toNumber(true) : message.mediationId;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this IceCandidate to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.IceCandidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceCandidate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceCandidate;
    })();

    PeerExchangeMessage.CallbackRequest = (function() {

        /**
         * Properties of a CallbackRequest.
         * @memberof PeerExchangeMessage
         * @interface ICallbackRequest
         */

        /**
         * Constructs a new CallbackRequest.
         * @memberof PeerExchangeMessage
         * @classdesc Represents a CallbackRequest.
         * @implements ICallbackRequest
         * @constructor
         * @param {PeerExchangeMessage.ICallbackRequest=} [properties] Properties to set
         */
        function CallbackRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CallbackRequest instance using the specified properties.
         * @function create
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest=} [properties] Properties to set
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest instance
         */
        CallbackRequest.create = function create(properties) {
            return new CallbackRequest(properties);
        };

        /**
         * Encodes the specified CallbackRequest message. Does not implicitly {@link PeerExchangeMessage.CallbackRequest.verify|verify} messages.
         * @function encode
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest} message CallbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallbackRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CallbackRequest message, length delimited. Does not implicitly {@link PeerExchangeMessage.CallbackRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.ICallbackRequest} message CallbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallbackRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallbackRequest message from the specified reader or buffer.
         * @function decode
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallbackRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PeerExchangeMessage.CallbackRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallbackRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallbackRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallbackRequest message.
         * @function verify
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallbackRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CallbackRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PeerExchangeMessage.CallbackRequest} CallbackRequest
         */
        CallbackRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.PeerExchangeMessage.CallbackRequest)
                return object;
            return new $root.PeerExchangeMessage.CallbackRequest();
        };

        /**
         * Creates a plain object from a CallbackRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PeerExchangeMessage.CallbackRequest
         * @static
         * @param {PeerExchangeMessage.CallbackRequest} message CallbackRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallbackRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CallbackRequest to JSON.
         * @function toJSON
         * @memberof PeerExchangeMessage.CallbackRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallbackRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallbackRequest;
    })();

    return PeerExchangeMessage;
})();

/**
 * SwarmEventType enum.
 * @exports SwarmEventType
 * @enum {number}
 * @property {number} CREATE_SWARM=0 CREATE_SWARM value
 * @property {number} UPDATE_SWARM=1 UPDATE_SWARM value
 * @property {number} DELETE_SWARM=2 DELETE_SWARM value
 */
$root.SwarmEventType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CREATE_SWARM"] = 0;
    values[valuesById[1] = "UPDATE_SWARM"] = 1;
    values[valuesById[2] = "DELETE_SWARM"] = 2;
    return values;
})();

/**
 * WRTCSDPType enum.
 * @exports WRTCSDPType
 * @enum {number}
 * @property {number} OFFER=0 OFFER value
 * @property {number} ANSWER=1 ANSWER value
 */
$root.WRTCSDPType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "OFFER"] = 0;
    values[valuesById[1] = "ANSWER"] = 1;
    return values;
})();

/**
 * MetricsFormat enum.
 * @exports MetricsFormat
 * @enum {number}
 * @property {number} METRICS_FORMAT_TEXT=0 METRICS_FORMAT_TEXT value
 * @property {number} METRICS_FORMAT_PROTO_DELIM=1 METRICS_FORMAT_PROTO_DELIM value
 * @property {number} METRICS_FORMAT_PROTO_TEXT=2 METRICS_FORMAT_PROTO_TEXT value
 * @property {number} METRICS_FORMAT_PROTO_COMPACT=3 METRICS_FORMAT_PROTO_COMPACT value
 * @property {number} METRICS_FORMAT_OPEN_METRICS=4 METRICS_FORMAT_OPEN_METRICS value
 */
$root.MetricsFormat = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "METRICS_FORMAT_TEXT"] = 0;
    values[valuesById[1] = "METRICS_FORMAT_PROTO_DELIM"] = 1;
    values[valuesById[2] = "METRICS_FORMAT_PROTO_TEXT"] = 2;
    values[valuesById[3] = "METRICS_FORMAT_PROTO_COMPACT"] = 3;
    values[valuesById[4] = "METRICS_FORMAT_OPEN_METRICS"] = 4;
    return values;
})();

/**
 * KDFType enum.
 * @exports KDFType
 * @enum {number}
 * @property {number} KDF_TYPE_UNDEFINED=0 KDF_TYPE_UNDEFINED value
 * @property {number} KDF_TYPE_PBKDF2_SHA256=1 KDF_TYPE_PBKDF2_SHA256 value
 */
$root.KDFType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KDF_TYPE_UNDEFINED"] = 0;
    values[valuesById[1] = "KDF_TYPE_PBKDF2_SHA256"] = 1;
    return values;
})();

/**
 * KeyType enum.
 * @exports KeyType
 * @enum {number}
 * @property {number} KEY_TYPE_UNDEFINED=0 KEY_TYPE_UNDEFINED value
 * @property {number} KEY_TYPE_ED25519=1 KEY_TYPE_ED25519 value
 * @property {number} KEY_TYPE_X25519=2 KEY_TYPE_X25519 value
 */
$root.KeyType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KEY_TYPE_UNDEFINED"] = 0;
    values[valuesById[1] = "KEY_TYPE_ED25519"] = 1;
    values[valuesById[2] = "KEY_TYPE_X25519"] = 2;
    return values;
})();

/**
 * KeyUsage enum.
 * @exports KeyUsage
 * @enum {number}
 * @property {number} KEY_USAGE_UNDEFINED=0 KEY_USAGE_UNDEFINED value
 * @property {number} KEY_USAGE_PEER=1 KEY_USAGE_PEER value
 * @property {number} KEY_USAGE_BOOTSTRAP=2 KEY_USAGE_BOOTSTRAP value
 * @property {number} KEY_USAGE_SIGN=4 KEY_USAGE_SIGN value
 * @property {number} KEY_USAGE_BROKER=8 KEY_USAGE_BROKER value
 * @property {number} KEY_USAGE_ENCIPHERMENT=16 KEY_USAGE_ENCIPHERMENT value
 */
$root.KeyUsage = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "KEY_USAGE_UNDEFINED"] = 0;
    values[valuesById[1] = "KEY_USAGE_PEER"] = 1;
    values[valuesById[2] = "KEY_USAGE_BOOTSTRAP"] = 2;
    values[valuesById[4] = "KEY_USAGE_SIGN"] = 4;
    values[valuesById[8] = "KEY_USAGE_BROKER"] = 8;
    values[valuesById[16] = "KEY_USAGE_ENCIPHERMENT"] = 16;
    return values;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                let message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
